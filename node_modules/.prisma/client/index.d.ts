
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model JobReport
 * 
 */
export type JobReport = $Result.DefaultSelection<Prisma.$JobReportPayload>
/**
 * Model RepairEstimate
 * 
 */
export type RepairEstimate = $Result.DefaultSelection<Prisma.$RepairEstimatePayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model DetectedDamage
 * 
 */
export type DetectedDamage = $Result.DefaultSelection<Prisma.$DetectedDamagePayload>
/**
 * Model ActualRepair
 * 
 */
export type ActualRepair = $Result.DefaultSelection<Prisma.$ActualRepairPayload>
/**
 * Model TrainingImage
 * 
 */
export type TrainingImage = $Result.DefaultSelection<Prisma.$TrainingImagePayload>
/**
 * Model VINMetadata
 * 
 */
export type VINMetadata = $Result.DefaultSelection<Prisma.$VINMetadataPayload>
/**
 * Model TruckSection
 * 
 */
export type TruckSection = $Result.DefaultSelection<Prisma.$TruckSectionPayload>
/**
 * Model VehiclePart
 * 
 */
export type VehiclePart = $Result.DefaultSelection<Prisma.$VehiclePartPayload>
/**
 * Model DamageType
 * 
 */
export type DamageType = $Result.DefaultSelection<Prisma.$DamageTypePayload>
/**
 * Model SeverityLevel
 * 
 */
export type SeverityLevel = $Result.DefaultSelection<Prisma.$SeverityLevelPayload>
/**
 * Model ImageVehiclePart
 * 
 */
export type ImageVehiclePart = $Result.DefaultSelection<Prisma.$ImageVehiclePartPayload>
/**
 * Model ImageDamageType
 * 
 */
export type ImageDamageType = $Result.DefaultSelection<Prisma.$ImageDamageTypePayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model VehicleReferenceImage
 * 
 */
export type VehicleReferenceImage = $Result.DefaultSelection<Prisma.$VehicleReferenceImagePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs>;

  /**
   * `prisma.jobReport`: Exposes CRUD operations for the **JobReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobReports
    * const jobReports = await prisma.jobReport.findMany()
    * ```
    */
  get jobReport(): Prisma.JobReportDelegate<ExtArgs>;

  /**
   * `prisma.repairEstimate`: Exposes CRUD operations for the **RepairEstimate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairEstimates
    * const repairEstimates = await prisma.repairEstimate.findMany()
    * ```
    */
  get repairEstimate(): Prisma.RepairEstimateDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs>;

  /**
   * `prisma.detectedDamage`: Exposes CRUD operations for the **DetectedDamage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetectedDamages
    * const detectedDamages = await prisma.detectedDamage.findMany()
    * ```
    */
  get detectedDamage(): Prisma.DetectedDamageDelegate<ExtArgs>;

  /**
   * `prisma.actualRepair`: Exposes CRUD operations for the **ActualRepair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActualRepairs
    * const actualRepairs = await prisma.actualRepair.findMany()
    * ```
    */
  get actualRepair(): Prisma.ActualRepairDelegate<ExtArgs>;

  /**
   * `prisma.trainingImage`: Exposes CRUD operations for the **TrainingImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingImages
    * const trainingImages = await prisma.trainingImage.findMany()
    * ```
    */
  get trainingImage(): Prisma.TrainingImageDelegate<ExtArgs>;

  /**
   * `prisma.vINMetadata`: Exposes CRUD operations for the **VINMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VINMetadata
    * const vINMetadata = await prisma.vINMetadata.findMany()
    * ```
    */
  get vINMetadata(): Prisma.VINMetadataDelegate<ExtArgs>;

  /**
   * `prisma.truckSection`: Exposes CRUD operations for the **TruckSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TruckSections
    * const truckSections = await prisma.truckSection.findMany()
    * ```
    */
  get truckSection(): Prisma.TruckSectionDelegate<ExtArgs>;

  /**
   * `prisma.vehiclePart`: Exposes CRUD operations for the **VehiclePart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleParts
    * const vehicleParts = await prisma.vehiclePart.findMany()
    * ```
    */
  get vehiclePart(): Prisma.VehiclePartDelegate<ExtArgs>;

  /**
   * `prisma.damageType`: Exposes CRUD operations for the **DamageType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DamageTypes
    * const damageTypes = await prisma.damageType.findMany()
    * ```
    */
  get damageType(): Prisma.DamageTypeDelegate<ExtArgs>;

  /**
   * `prisma.severityLevel`: Exposes CRUD operations for the **SeverityLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeverityLevels
    * const severityLevels = await prisma.severityLevel.findMany()
    * ```
    */
  get severityLevel(): Prisma.SeverityLevelDelegate<ExtArgs>;

  /**
   * `prisma.imageVehiclePart`: Exposes CRUD operations for the **ImageVehiclePart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageVehicleParts
    * const imageVehicleParts = await prisma.imageVehiclePart.findMany()
    * ```
    */
  get imageVehiclePart(): Prisma.ImageVehiclePartDelegate<ExtArgs>;

  /**
   * `prisma.imageDamageType`: Exposes CRUD operations for the **ImageDamageType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageDamageTypes
    * const imageDamageTypes = await prisma.imageDamageType.findMany()
    * ```
    */
  get imageDamageType(): Prisma.ImageDamageTypeDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.vehicleReferenceImage`: Exposes CRUD operations for the **VehicleReferenceImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleReferenceImages
    * const vehicleReferenceImages = await prisma.vehicleReferenceImage.findMany()
    * ```
    */
  get vehicleReferenceImage(): Prisma.VehicleReferenceImageDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Vehicle: 'Vehicle',
    JobReport: 'JobReport',
    RepairEstimate: 'RepairEstimate',
    Feedback: 'Feedback',
    Image: 'Image',
    DetectedDamage: 'DetectedDamage',
    ActualRepair: 'ActualRepair',
    TrainingImage: 'TrainingImage',
    VINMetadata: 'VINMetadata',
    TruckSection: 'TruckSection',
    VehiclePart: 'VehiclePart',
    DamageType: 'DamageType',
    SeverityLevel: 'SeverityLevel',
    ImageVehiclePart: 'ImageVehiclePart',
    ImageDamageType: 'ImageDamageType',
    PasswordResetToken: 'PasswordResetToken',
    VehicleReferenceImage: 'VehicleReferenceImage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "vehicle" | "jobReport" | "repairEstimate" | "feedback" | "image" | "detectedDamage" | "actualRepair" | "trainingImage" | "vINMetadata" | "truckSection" | "vehiclePart" | "damageType" | "severityLevel" | "imageVehiclePart" | "imageDamageType" | "passwordResetToken" | "vehicleReferenceImage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      JobReport: {
        payload: Prisma.$JobReportPayload<ExtArgs>
        fields: Prisma.JobReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload>
          }
          findFirst: {
            args: Prisma.JobReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload>
          }
          findMany: {
            args: Prisma.JobReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload>[]
          }
          create: {
            args: Prisma.JobReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload>
          }
          createMany: {
            args: Prisma.JobReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload>[]
          }
          delete: {
            args: Prisma.JobReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload>
          }
          update: {
            args: Prisma.JobReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload>
          }
          deleteMany: {
            args: Prisma.JobReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobReportPayload>
          }
          aggregate: {
            args: Prisma.JobReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobReport>
          }
          groupBy: {
            args: Prisma.JobReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobReportCountArgs<ExtArgs>
            result: $Utils.Optional<JobReportCountAggregateOutputType> | number
          }
        }
      }
      RepairEstimate: {
        payload: Prisma.$RepairEstimatePayload<ExtArgs>
        fields: Prisma.RepairEstimateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepairEstimateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepairEstimateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload>
          }
          findFirst: {
            args: Prisma.RepairEstimateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepairEstimateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload>
          }
          findMany: {
            args: Prisma.RepairEstimateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload>[]
          }
          create: {
            args: Prisma.RepairEstimateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload>
          }
          createMany: {
            args: Prisma.RepairEstimateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RepairEstimateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload>[]
          }
          delete: {
            args: Prisma.RepairEstimateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload>
          }
          update: {
            args: Prisma.RepairEstimateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload>
          }
          deleteMany: {
            args: Prisma.RepairEstimateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepairEstimateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RepairEstimateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairEstimatePayload>
          }
          aggregate: {
            args: Prisma.RepairEstimateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepairEstimate>
          }
          groupBy: {
            args: Prisma.RepairEstimateGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepairEstimateGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepairEstimateCountArgs<ExtArgs>
            result: $Utils.Optional<RepairEstimateCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      DetectedDamage: {
        payload: Prisma.$DetectedDamagePayload<ExtArgs>
        fields: Prisma.DetectedDamageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetectedDamageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetectedDamageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload>
          }
          findFirst: {
            args: Prisma.DetectedDamageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetectedDamageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload>
          }
          findMany: {
            args: Prisma.DetectedDamageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload>[]
          }
          create: {
            args: Prisma.DetectedDamageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload>
          }
          createMany: {
            args: Prisma.DetectedDamageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetectedDamageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload>[]
          }
          delete: {
            args: Prisma.DetectedDamageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload>
          }
          update: {
            args: Prisma.DetectedDamageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload>
          }
          deleteMany: {
            args: Prisma.DetectedDamageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetectedDamageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DetectedDamageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedDamagePayload>
          }
          aggregate: {
            args: Prisma.DetectedDamageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetectedDamage>
          }
          groupBy: {
            args: Prisma.DetectedDamageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetectedDamageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetectedDamageCountArgs<ExtArgs>
            result: $Utils.Optional<DetectedDamageCountAggregateOutputType> | number
          }
        }
      }
      ActualRepair: {
        payload: Prisma.$ActualRepairPayload<ExtArgs>
        fields: Prisma.ActualRepairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActualRepairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActualRepairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload>
          }
          findFirst: {
            args: Prisma.ActualRepairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActualRepairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload>
          }
          findMany: {
            args: Prisma.ActualRepairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload>[]
          }
          create: {
            args: Prisma.ActualRepairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload>
          }
          createMany: {
            args: Prisma.ActualRepairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActualRepairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload>[]
          }
          delete: {
            args: Prisma.ActualRepairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload>
          }
          update: {
            args: Prisma.ActualRepairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload>
          }
          deleteMany: {
            args: Prisma.ActualRepairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActualRepairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActualRepairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActualRepairPayload>
          }
          aggregate: {
            args: Prisma.ActualRepairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActualRepair>
          }
          groupBy: {
            args: Prisma.ActualRepairGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActualRepairGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActualRepairCountArgs<ExtArgs>
            result: $Utils.Optional<ActualRepairCountAggregateOutputType> | number
          }
        }
      }
      TrainingImage: {
        payload: Prisma.$TrainingImagePayload<ExtArgs>
        fields: Prisma.TrainingImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload>
          }
          findFirst: {
            args: Prisma.TrainingImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload>
          }
          findMany: {
            args: Prisma.TrainingImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload>[]
          }
          create: {
            args: Prisma.TrainingImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload>
          }
          createMany: {
            args: Prisma.TrainingImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload>[]
          }
          delete: {
            args: Prisma.TrainingImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload>
          }
          update: {
            args: Prisma.TrainingImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload>
          }
          deleteMany: {
            args: Prisma.TrainingImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingImagePayload>
          }
          aggregate: {
            args: Prisma.TrainingImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingImage>
          }
          groupBy: {
            args: Prisma.TrainingImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingImageCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingImageCountAggregateOutputType> | number
          }
        }
      }
      VINMetadata: {
        payload: Prisma.$VINMetadataPayload<ExtArgs>
        fields: Prisma.VINMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VINMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VINMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload>
          }
          findFirst: {
            args: Prisma.VINMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VINMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload>
          }
          findMany: {
            args: Prisma.VINMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload>[]
          }
          create: {
            args: Prisma.VINMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload>
          }
          createMany: {
            args: Prisma.VINMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VINMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload>[]
          }
          delete: {
            args: Prisma.VINMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload>
          }
          update: {
            args: Prisma.VINMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload>
          }
          deleteMany: {
            args: Prisma.VINMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VINMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VINMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VINMetadataPayload>
          }
          aggregate: {
            args: Prisma.VINMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVINMetadata>
          }
          groupBy: {
            args: Prisma.VINMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<VINMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.VINMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<VINMetadataCountAggregateOutputType> | number
          }
        }
      }
      TruckSection: {
        payload: Prisma.$TruckSectionPayload<ExtArgs>
        fields: Prisma.TruckSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TruckSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TruckSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload>
          }
          findFirst: {
            args: Prisma.TruckSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TruckSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload>
          }
          findMany: {
            args: Prisma.TruckSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload>[]
          }
          create: {
            args: Prisma.TruckSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload>
          }
          createMany: {
            args: Prisma.TruckSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TruckSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload>[]
          }
          delete: {
            args: Prisma.TruckSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload>
          }
          update: {
            args: Prisma.TruckSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload>
          }
          deleteMany: {
            args: Prisma.TruckSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TruckSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TruckSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckSectionPayload>
          }
          aggregate: {
            args: Prisma.TruckSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTruckSection>
          }
          groupBy: {
            args: Prisma.TruckSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TruckSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TruckSectionCountArgs<ExtArgs>
            result: $Utils.Optional<TruckSectionCountAggregateOutputType> | number
          }
        }
      }
      VehiclePart: {
        payload: Prisma.$VehiclePartPayload<ExtArgs>
        fields: Prisma.VehiclePartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehiclePartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehiclePartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload>
          }
          findFirst: {
            args: Prisma.VehiclePartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehiclePartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload>
          }
          findMany: {
            args: Prisma.VehiclePartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload>[]
          }
          create: {
            args: Prisma.VehiclePartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload>
          }
          createMany: {
            args: Prisma.VehiclePartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehiclePartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload>[]
          }
          delete: {
            args: Prisma.VehiclePartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload>
          }
          update: {
            args: Prisma.VehiclePartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload>
          }
          deleteMany: {
            args: Prisma.VehiclePartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehiclePartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehiclePartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePartPayload>
          }
          aggregate: {
            args: Prisma.VehiclePartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehiclePart>
          }
          groupBy: {
            args: Prisma.VehiclePartGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehiclePartGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehiclePartCountArgs<ExtArgs>
            result: $Utils.Optional<VehiclePartCountAggregateOutputType> | number
          }
        }
      }
      DamageType: {
        payload: Prisma.$DamageTypePayload<ExtArgs>
        fields: Prisma.DamageTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DamageTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DamageTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          findFirst: {
            args: Prisma.DamageTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DamageTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          findMany: {
            args: Prisma.DamageTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>[]
          }
          create: {
            args: Prisma.DamageTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          createMany: {
            args: Prisma.DamageTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DamageTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>[]
          }
          delete: {
            args: Prisma.DamageTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          update: {
            args: Prisma.DamageTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          deleteMany: {
            args: Prisma.DamageTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DamageTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DamageTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          aggregate: {
            args: Prisma.DamageTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDamageType>
          }
          groupBy: {
            args: Prisma.DamageTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DamageTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DamageTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DamageTypeCountAggregateOutputType> | number
          }
        }
      }
      SeverityLevel: {
        payload: Prisma.$SeverityLevelPayload<ExtArgs>
        fields: Prisma.SeverityLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeverityLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeverityLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload>
          }
          findFirst: {
            args: Prisma.SeverityLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeverityLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload>
          }
          findMany: {
            args: Prisma.SeverityLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload>[]
          }
          create: {
            args: Prisma.SeverityLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload>
          }
          createMany: {
            args: Prisma.SeverityLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeverityLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload>[]
          }
          delete: {
            args: Prisma.SeverityLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload>
          }
          update: {
            args: Prisma.SeverityLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload>
          }
          deleteMany: {
            args: Prisma.SeverityLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeverityLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeverityLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityLevelPayload>
          }
          aggregate: {
            args: Prisma.SeverityLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeverityLevel>
          }
          groupBy: {
            args: Prisma.SeverityLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeverityLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeverityLevelCountArgs<ExtArgs>
            result: $Utils.Optional<SeverityLevelCountAggregateOutputType> | number
          }
        }
      }
      ImageVehiclePart: {
        payload: Prisma.$ImageVehiclePartPayload<ExtArgs>
        fields: Prisma.ImageVehiclePartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageVehiclePartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageVehiclePartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload>
          }
          findFirst: {
            args: Prisma.ImageVehiclePartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageVehiclePartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload>
          }
          findMany: {
            args: Prisma.ImageVehiclePartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload>[]
          }
          create: {
            args: Prisma.ImageVehiclePartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload>
          }
          createMany: {
            args: Prisma.ImageVehiclePartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageVehiclePartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload>[]
          }
          delete: {
            args: Prisma.ImageVehiclePartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload>
          }
          update: {
            args: Prisma.ImageVehiclePartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload>
          }
          deleteMany: {
            args: Prisma.ImageVehiclePartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageVehiclePartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageVehiclePartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageVehiclePartPayload>
          }
          aggregate: {
            args: Prisma.ImageVehiclePartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImageVehiclePart>
          }
          groupBy: {
            args: Prisma.ImageVehiclePartGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageVehiclePartGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageVehiclePartCountArgs<ExtArgs>
            result: $Utils.Optional<ImageVehiclePartCountAggregateOutputType> | number
          }
        }
      }
      ImageDamageType: {
        payload: Prisma.$ImageDamageTypePayload<ExtArgs>
        fields: Prisma.ImageDamageTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageDamageTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageDamageTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload>
          }
          findFirst: {
            args: Prisma.ImageDamageTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageDamageTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload>
          }
          findMany: {
            args: Prisma.ImageDamageTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload>[]
          }
          create: {
            args: Prisma.ImageDamageTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload>
          }
          createMany: {
            args: Prisma.ImageDamageTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageDamageTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload>[]
          }
          delete: {
            args: Prisma.ImageDamageTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload>
          }
          update: {
            args: Prisma.ImageDamageTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload>
          }
          deleteMany: {
            args: Prisma.ImageDamageTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageDamageTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageDamageTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageDamageTypePayload>
          }
          aggregate: {
            args: Prisma.ImageDamageTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImageDamageType>
          }
          groupBy: {
            args: Prisma.ImageDamageTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageDamageTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageDamageTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ImageDamageTypeCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      VehicleReferenceImage: {
        payload: Prisma.$VehicleReferenceImagePayload<ExtArgs>
        fields: Prisma.VehicleReferenceImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleReferenceImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleReferenceImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload>
          }
          findFirst: {
            args: Prisma.VehicleReferenceImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleReferenceImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload>
          }
          findMany: {
            args: Prisma.VehicleReferenceImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload>[]
          }
          create: {
            args: Prisma.VehicleReferenceImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload>
          }
          createMany: {
            args: Prisma.VehicleReferenceImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleReferenceImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload>[]
          }
          delete: {
            args: Prisma.VehicleReferenceImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload>
          }
          update: {
            args: Prisma.VehicleReferenceImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload>
          }
          deleteMany: {
            args: Prisma.VehicleReferenceImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleReferenceImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleReferenceImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleReferenceImagePayload>
          }
          aggregate: {
            args: Prisma.VehicleReferenceImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleReferenceImage>
          }
          groupBy: {
            args: Prisma.VehicleReferenceImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleReferenceImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleReferenceImageCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleReferenceImageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    jobs: number
    confirmedRepairs: number
    feedbacks: number
    resetTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | UserCountOutputTypeCountJobsArgs
    confirmedRepairs?: boolean | UserCountOutputTypeCountConfirmedRepairsArgs
    feedbacks?: boolean | UserCountOutputTypeCountFeedbacksArgs
    resetTokens?: boolean | UserCountOutputTypeCountResetTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConfirmedRepairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActualRepairWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    jobs: number
    referenceImages: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | VehicleCountOutputTypeCountJobsArgs
    referenceImages?: boolean | VehicleCountOutputTypeCountReferenceImagesArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobReportWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountReferenceImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleReferenceImageWhereInput
  }


  /**
   * Count Type JobReportCountOutputType
   */

  export type JobReportCountOutputType = {
    images: number
    detectedDamages: number
    repairEstimates: number
    actualRepairs: number
    feedbacks: number
    vinMetadata: number
  }

  export type JobReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | JobReportCountOutputTypeCountImagesArgs
    detectedDamages?: boolean | JobReportCountOutputTypeCountDetectedDamagesArgs
    repairEstimates?: boolean | JobReportCountOutputTypeCountRepairEstimatesArgs
    actualRepairs?: boolean | JobReportCountOutputTypeCountActualRepairsArgs
    feedbacks?: boolean | JobReportCountOutputTypeCountFeedbacksArgs
    vinMetadata?: boolean | JobReportCountOutputTypeCountVinMetadataArgs
  }

  // Custom InputTypes
  /**
   * JobReportCountOutputType without action
   */
  export type JobReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReportCountOutputType
     */
    select?: JobReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobReportCountOutputType without action
   */
  export type JobReportCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * JobReportCountOutputType without action
   */
  export type JobReportCountOutputTypeCountDetectedDamagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetectedDamageWhereInput
  }

  /**
   * JobReportCountOutputType without action
   */
  export type JobReportCountOutputTypeCountRepairEstimatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairEstimateWhereInput
  }

  /**
   * JobReportCountOutputType without action
   */
  export type JobReportCountOutputTypeCountActualRepairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActualRepairWhereInput
  }

  /**
   * JobReportCountOutputType without action
   */
  export type JobReportCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * JobReportCountOutputType without action
   */
  export type JobReportCountOutputTypeCountVinMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VINMetadataWhereInput
  }


  /**
   * Count Type ImageCountOutputType
   */

  export type ImageCountOutputType = {
    vehicleParts: number
    damageTypes: number
  }

  export type ImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleParts?: boolean | ImageCountOutputTypeCountVehiclePartsArgs
    damageTypes?: boolean | ImageCountOutputTypeCountDamageTypesArgs
  }

  // Custom InputTypes
  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageCountOutputType
     */
    select?: ImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountVehiclePartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageVehiclePartWhereInput
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountDamageTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageDamageTypeWhereInput
  }


  /**
   * Count Type TruckSectionCountOutputType
   */

  export type TruckSectionCountOutputType = {
    vehicleParts: number
    images: number
  }

  export type TruckSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleParts?: boolean | TruckSectionCountOutputTypeCountVehiclePartsArgs
    images?: boolean | TruckSectionCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * TruckSectionCountOutputType without action
   */
  export type TruckSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSectionCountOutputType
     */
    select?: TruckSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TruckSectionCountOutputType without action
   */
  export type TruckSectionCountOutputTypeCountVehiclePartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehiclePartWhereInput
  }

  /**
   * TruckSectionCountOutputType without action
   */
  export type TruckSectionCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }


  /**
   * Count Type VehiclePartCountOutputType
   */

  export type VehiclePartCountOutputType = {
    images: number
  }

  export type VehiclePartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | VehiclePartCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * VehiclePartCountOutputType without action
   */
  export type VehiclePartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePartCountOutputType
     */
    select?: VehiclePartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehiclePartCountOutputType without action
   */
  export type VehiclePartCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageVehiclePartWhereInput
  }


  /**
   * Count Type DamageTypeCountOutputType
   */

  export type DamageTypeCountOutputType = {
    images: number
  }

  export type DamageTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | DamageTypeCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageTypeCountOutputType
     */
    select?: DamageTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageDamageTypeWhereInput
  }


  /**
   * Count Type SeverityLevelCountOutputType
   */

  export type SeverityLevelCountOutputType = {
    images: number
  }

  export type SeverityLevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | SeverityLevelCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * SeverityLevelCountOutputType without action
   */
  export type SeverityLevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevelCountOutputType
     */
    select?: SeverityLevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeverityLevelCountOutputType without action
   */
  export type SeverityLevelCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    experienceLevel: number | null
  }

  export type UserSumAggregateOutputType = {
    experienceLevel: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    hashedPassword: string | null
    createdAt: Date | null
    role: string | null
    experienceLevel: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    hashedPassword: string | null
    createdAt: Date | null
    role: string | null
    experienceLevel: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    hashedPassword: number
    createdAt: number
    role: number
    experienceLevel: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    experienceLevel?: true
  }

  export type UserSumAggregateInputType = {
    experienceLevel?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    hashedPassword?: true
    createdAt?: true
    role?: true
    experienceLevel?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    hashedPassword?: true
    createdAt?: true
    role?: true
    experienceLevel?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    hashedPassword?: true
    createdAt?: true
    role?: true
    experienceLevel?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    hashedPassword: string
    createdAt: Date
    role: string
    experienceLevel: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    hashedPassword?: boolean
    createdAt?: boolean
    role?: boolean
    experienceLevel?: boolean
    jobs?: boolean | User$jobsArgs<ExtArgs>
    confirmedRepairs?: boolean | User$confirmedRepairsArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    resetTokens?: boolean | User$resetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    hashedPassword?: boolean
    createdAt?: boolean
    role?: boolean
    experienceLevel?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    hashedPassword?: boolean
    createdAt?: boolean
    role?: boolean
    experienceLevel?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | User$jobsArgs<ExtArgs>
    confirmedRepairs?: boolean | User$confirmedRepairsArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    resetTokens?: boolean | User$resetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      jobs: Prisma.$JobReportPayload<ExtArgs>[]
      confirmedRepairs: Prisma.$ActualRepairPayload<ExtArgs>[]
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
      resetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      hashedPassword: string
      createdAt: Date
      role: string
      experienceLevel: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends User$jobsArgs<ExtArgs> = {}>(args?: Subset<T, User$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findMany"> | Null>
    confirmedRepairs<T extends User$confirmedRepairsArgs<ExtArgs> = {}>(args?: Subset<T, User$confirmedRepairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "findMany"> | Null>
    feedbacks<T extends User$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    resetTokens<T extends User$resetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$resetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly hashedPassword: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly experienceLevel: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.jobs
   */
  export type User$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    where?: JobReportWhereInput
    orderBy?: JobReportOrderByWithRelationInput | JobReportOrderByWithRelationInput[]
    cursor?: JobReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobReportScalarFieldEnum | JobReportScalarFieldEnum[]
  }

  /**
   * User.confirmedRepairs
   */
  export type User$confirmedRepairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    where?: ActualRepairWhereInput
    orderBy?: ActualRepairOrderByWithRelationInput | ActualRepairOrderByWithRelationInput[]
    cursor?: ActualRepairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActualRepairScalarFieldEnum | ActualRepairScalarFieldEnum[]
  }

  /**
   * User.feedbacks
   */
  export type User$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.resetTokens
   */
  export type User$resetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    year: number | null
    engineCylinders: number | null
    engineDisplacementL: number | null
  }

  export type VehicleSumAggregateOutputType = {
    year: number | null
    engineCylinders: number | null
    engineDisplacementL: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    vin: string | null
    type: string | null
    make: string | null
    model: string | null
    year: number | null
    weightClass: string | null
    owner: string | null
    notes: string | null
    createdAt: Date | null
    bodyClass: string | null
    driveType: string | null
    engineModel: string | null
    engineCylinders: number | null
    engineDisplacementL: number | null
    fuelTypePrimary: string | null
    brakeSystemType: string | null
    manufacturerName: string | null
    plantCity: string | null
    plantState: string | null
    plantCountry: string | null
    trim: string | null
    series: string | null
    steeringLocation: string | null
    transmissionStyle: string | null
    vehicleType: string | null
    gvwr: string | null
    doors: string | null
    wheels: string | null
    entertainmentSystem: string | null
    abs: string | null
    airbagLocations: string | null
    electronicStabilityControl: string | null
    basePrice: string | null
    bedLength: string | null
    cabType: string | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    vin: string | null
    type: string | null
    make: string | null
    model: string | null
    year: number | null
    weightClass: string | null
    owner: string | null
    notes: string | null
    createdAt: Date | null
    bodyClass: string | null
    driveType: string | null
    engineModel: string | null
    engineCylinders: number | null
    engineDisplacementL: number | null
    fuelTypePrimary: string | null
    brakeSystemType: string | null
    manufacturerName: string | null
    plantCity: string | null
    plantState: string | null
    plantCountry: string | null
    trim: string | null
    series: string | null
    steeringLocation: string | null
    transmissionStyle: string | null
    vehicleType: string | null
    gvwr: string | null
    doors: string | null
    wheels: string | null
    entertainmentSystem: string | null
    abs: string | null
    airbagLocations: string | null
    electronicStabilityControl: string | null
    basePrice: string | null
    bedLength: string | null
    cabType: string | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    vin: number
    type: number
    make: number
    model: number
    year: number
    weightClass: number
    owner: number
    notes: number
    createdAt: number
    bodyClass: number
    driveType: number
    engineModel: number
    engineCylinders: number
    engineDisplacementL: number
    fuelTypePrimary: number
    brakeSystemType: number
    manufacturerName: number
    plantCity: number
    plantState: number
    plantCountry: number
    trim: number
    series: number
    steeringLocation: number
    transmissionStyle: number
    vehicleType: number
    gvwr: number
    doors: number
    wheels: number
    entertainmentSystem: number
    abs: number
    airbagLocations: number
    electronicStabilityControl: number
    basePrice: number
    bedLength: number
    cabType: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    year?: true
    engineCylinders?: true
    engineDisplacementL?: true
  }

  export type VehicleSumAggregateInputType = {
    year?: true
    engineCylinders?: true
    engineDisplacementL?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    vin?: true
    type?: true
    make?: true
    model?: true
    year?: true
    weightClass?: true
    owner?: true
    notes?: true
    createdAt?: true
    bodyClass?: true
    driveType?: true
    engineModel?: true
    engineCylinders?: true
    engineDisplacementL?: true
    fuelTypePrimary?: true
    brakeSystemType?: true
    manufacturerName?: true
    plantCity?: true
    plantState?: true
    plantCountry?: true
    trim?: true
    series?: true
    steeringLocation?: true
    transmissionStyle?: true
    vehicleType?: true
    gvwr?: true
    doors?: true
    wheels?: true
    entertainmentSystem?: true
    abs?: true
    airbagLocations?: true
    electronicStabilityControl?: true
    basePrice?: true
    bedLength?: true
    cabType?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    vin?: true
    type?: true
    make?: true
    model?: true
    year?: true
    weightClass?: true
    owner?: true
    notes?: true
    createdAt?: true
    bodyClass?: true
    driveType?: true
    engineModel?: true
    engineCylinders?: true
    engineDisplacementL?: true
    fuelTypePrimary?: true
    brakeSystemType?: true
    manufacturerName?: true
    plantCity?: true
    plantState?: true
    plantCountry?: true
    trim?: true
    series?: true
    steeringLocation?: true
    transmissionStyle?: true
    vehicleType?: true
    gvwr?: true
    doors?: true
    wheels?: true
    entertainmentSystem?: true
    abs?: true
    airbagLocations?: true
    electronicStabilityControl?: true
    basePrice?: true
    bedLength?: true
    cabType?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    vin?: true
    type?: true
    make?: true
    model?: true
    year?: true
    weightClass?: true
    owner?: true
    notes?: true
    createdAt?: true
    bodyClass?: true
    driveType?: true
    engineModel?: true
    engineCylinders?: true
    engineDisplacementL?: true
    fuelTypePrimary?: true
    brakeSystemType?: true
    manufacturerName?: true
    plantCity?: true
    plantState?: true
    plantCountry?: true
    trim?: true
    series?: true
    steeringLocation?: true
    transmissionStyle?: true
    vehicleType?: true
    gvwr?: true
    doors?: true
    wheels?: true
    entertainmentSystem?: true
    abs?: true
    airbagLocations?: true
    electronicStabilityControl?: true
    basePrice?: true
    bedLength?: true
    cabType?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    vin: string
    type: string | null
    make: string | null
    model: string | null
    year: number | null
    weightClass: string | null
    owner: string | null
    notes: string | null
    createdAt: Date
    bodyClass: string | null
    driveType: string | null
    engineModel: string | null
    engineCylinders: number | null
    engineDisplacementL: number | null
    fuelTypePrimary: string | null
    brakeSystemType: string | null
    manufacturerName: string | null
    plantCity: string | null
    plantState: string | null
    plantCountry: string | null
    trim: string | null
    series: string | null
    steeringLocation: string | null
    transmissionStyle: string | null
    vehicleType: string | null
    gvwr: string | null
    doors: string | null
    wheels: string | null
    entertainmentSystem: string | null
    abs: string | null
    airbagLocations: string | null
    electronicStabilityControl: string | null
    basePrice: string | null
    bedLength: string | null
    cabType: string | null
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vin?: boolean
    type?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    weightClass?: boolean
    owner?: boolean
    notes?: boolean
    createdAt?: boolean
    bodyClass?: boolean
    driveType?: boolean
    engineModel?: boolean
    engineCylinders?: boolean
    engineDisplacementL?: boolean
    fuelTypePrimary?: boolean
    brakeSystemType?: boolean
    manufacturerName?: boolean
    plantCity?: boolean
    plantState?: boolean
    plantCountry?: boolean
    trim?: boolean
    series?: boolean
    steeringLocation?: boolean
    transmissionStyle?: boolean
    vehicleType?: boolean
    gvwr?: boolean
    doors?: boolean
    wheels?: boolean
    entertainmentSystem?: boolean
    abs?: boolean
    airbagLocations?: boolean
    electronicStabilityControl?: boolean
    basePrice?: boolean
    bedLength?: boolean
    cabType?: boolean
    jobs?: boolean | Vehicle$jobsArgs<ExtArgs>
    referenceImages?: boolean | Vehicle$referenceImagesArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vin?: boolean
    type?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    weightClass?: boolean
    owner?: boolean
    notes?: boolean
    createdAt?: boolean
    bodyClass?: boolean
    driveType?: boolean
    engineModel?: boolean
    engineCylinders?: boolean
    engineDisplacementL?: boolean
    fuelTypePrimary?: boolean
    brakeSystemType?: boolean
    manufacturerName?: boolean
    plantCity?: boolean
    plantState?: boolean
    plantCountry?: boolean
    trim?: boolean
    series?: boolean
    steeringLocation?: boolean
    transmissionStyle?: boolean
    vehicleType?: boolean
    gvwr?: boolean
    doors?: boolean
    wheels?: boolean
    entertainmentSystem?: boolean
    abs?: boolean
    airbagLocations?: boolean
    electronicStabilityControl?: boolean
    basePrice?: boolean
    bedLength?: boolean
    cabType?: boolean
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    vin?: boolean
    type?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    weightClass?: boolean
    owner?: boolean
    notes?: boolean
    createdAt?: boolean
    bodyClass?: boolean
    driveType?: boolean
    engineModel?: boolean
    engineCylinders?: boolean
    engineDisplacementL?: boolean
    fuelTypePrimary?: boolean
    brakeSystemType?: boolean
    manufacturerName?: boolean
    plantCity?: boolean
    plantState?: boolean
    plantCountry?: boolean
    trim?: boolean
    series?: boolean
    steeringLocation?: boolean
    transmissionStyle?: boolean
    vehicleType?: boolean
    gvwr?: boolean
    doors?: boolean
    wheels?: boolean
    entertainmentSystem?: boolean
    abs?: boolean
    airbagLocations?: boolean
    electronicStabilityControl?: boolean
    basePrice?: boolean
    bedLength?: boolean
    cabType?: boolean
  }

  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | Vehicle$jobsArgs<ExtArgs>
    referenceImages?: boolean | Vehicle$referenceImagesArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      jobs: Prisma.$JobReportPayload<ExtArgs>[]
      referenceImages: Prisma.$VehicleReferenceImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vin: string
      type: string | null
      make: string | null
      model: string | null
      year: number | null
      weightClass: string | null
      owner: string | null
      notes: string | null
      createdAt: Date
      bodyClass: string | null
      driveType: string | null
      engineModel: string | null
      engineCylinders: number | null
      engineDisplacementL: number | null
      fuelTypePrimary: string | null
      brakeSystemType: string | null
      manufacturerName: string | null
      plantCity: string | null
      plantState: string | null
      plantCountry: string | null
      trim: string | null
      series: string | null
      steeringLocation: string | null
      transmissionStyle: string | null
      vehicleType: string | null
      gvwr: string | null
      doors: string | null
      wheels: string | null
      entertainmentSystem: string | null
      abs: string | null
      airbagLocations: string | null
      electronicStabilityControl: string | null
      basePrice: string | null
      bedLength: string | null
      cabType: string | null
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends Vehicle$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findMany"> | Null>
    referenceImages<T extends Vehicle$referenceImagesArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$referenceImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */ 
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'String'>
    readonly vin: FieldRef<"Vehicle", 'String'>
    readonly type: FieldRef<"Vehicle", 'String'>
    readonly make: FieldRef<"Vehicle", 'String'>
    readonly model: FieldRef<"Vehicle", 'String'>
    readonly year: FieldRef<"Vehicle", 'Int'>
    readonly weightClass: FieldRef<"Vehicle", 'String'>
    readonly owner: FieldRef<"Vehicle", 'String'>
    readonly notes: FieldRef<"Vehicle", 'String'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly bodyClass: FieldRef<"Vehicle", 'String'>
    readonly driveType: FieldRef<"Vehicle", 'String'>
    readonly engineModel: FieldRef<"Vehicle", 'String'>
    readonly engineCylinders: FieldRef<"Vehicle", 'Int'>
    readonly engineDisplacementL: FieldRef<"Vehicle", 'Float'>
    readonly fuelTypePrimary: FieldRef<"Vehicle", 'String'>
    readonly brakeSystemType: FieldRef<"Vehicle", 'String'>
    readonly manufacturerName: FieldRef<"Vehicle", 'String'>
    readonly plantCity: FieldRef<"Vehicle", 'String'>
    readonly plantState: FieldRef<"Vehicle", 'String'>
    readonly plantCountry: FieldRef<"Vehicle", 'String'>
    readonly trim: FieldRef<"Vehicle", 'String'>
    readonly series: FieldRef<"Vehicle", 'String'>
    readonly steeringLocation: FieldRef<"Vehicle", 'String'>
    readonly transmissionStyle: FieldRef<"Vehicle", 'String'>
    readonly vehicleType: FieldRef<"Vehicle", 'String'>
    readonly gvwr: FieldRef<"Vehicle", 'String'>
    readonly doors: FieldRef<"Vehicle", 'String'>
    readonly wheels: FieldRef<"Vehicle", 'String'>
    readonly entertainmentSystem: FieldRef<"Vehicle", 'String'>
    readonly abs: FieldRef<"Vehicle", 'String'>
    readonly airbagLocations: FieldRef<"Vehicle", 'String'>
    readonly electronicStabilityControl: FieldRef<"Vehicle", 'String'>
    readonly basePrice: FieldRef<"Vehicle", 'String'>
    readonly bedLength: FieldRef<"Vehicle", 'String'>
    readonly cabType: FieldRef<"Vehicle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle.jobs
   */
  export type Vehicle$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    where?: JobReportWhereInput
    orderBy?: JobReportOrderByWithRelationInput | JobReportOrderByWithRelationInput[]
    cursor?: JobReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobReportScalarFieldEnum | JobReportScalarFieldEnum[]
  }

  /**
   * Vehicle.referenceImages
   */
  export type Vehicle$referenceImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    where?: VehicleReferenceImageWhereInput
    orderBy?: VehicleReferenceImageOrderByWithRelationInput | VehicleReferenceImageOrderByWithRelationInput[]
    cursor?: VehicleReferenceImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleReferenceImageScalarFieldEnum | VehicleReferenceImageScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model JobReport
   */

  export type AggregateJobReport = {
    _count: JobReportCountAggregateOutputType | null
    _avg: JobReportAvgAggregateOutputType | null
    _sum: JobReportSumAggregateOutputType | null
    _min: JobReportMinAggregateOutputType | null
    _max: JobReportMaxAggregateOutputType | null
  }

  export type JobReportAvgAggregateOutputType = {
    aiEstimate: number | null
  }

  export type JobReportSumAggregateOutputType = {
    aiEstimate: number | null
  }

  export type JobReportMinAggregateOutputType = {
    id: string | null
    vin: string | null
    uploadedById: string | null
    createdAt: Date | null
    status: string | null
    aiEstimate: number | null
    aiResponse: string | null
  }

  export type JobReportMaxAggregateOutputType = {
    id: string | null
    vin: string | null
    uploadedById: string | null
    createdAt: Date | null
    status: string | null
    aiEstimate: number | null
    aiResponse: string | null
  }

  export type JobReportCountAggregateOutputType = {
    id: number
    vin: number
    uploadedById: number
    createdAt: number
    status: number
    aiEstimate: number
    aiResponse: number
    _all: number
  }


  export type JobReportAvgAggregateInputType = {
    aiEstimate?: true
  }

  export type JobReportSumAggregateInputType = {
    aiEstimate?: true
  }

  export type JobReportMinAggregateInputType = {
    id?: true
    vin?: true
    uploadedById?: true
    createdAt?: true
    status?: true
    aiEstimate?: true
    aiResponse?: true
  }

  export type JobReportMaxAggregateInputType = {
    id?: true
    vin?: true
    uploadedById?: true
    createdAt?: true
    status?: true
    aiEstimate?: true
    aiResponse?: true
  }

  export type JobReportCountAggregateInputType = {
    id?: true
    vin?: true
    uploadedById?: true
    createdAt?: true
    status?: true
    aiEstimate?: true
    aiResponse?: true
    _all?: true
  }

  export type JobReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobReport to aggregate.
     */
    where?: JobReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobReports to fetch.
     */
    orderBy?: JobReportOrderByWithRelationInput | JobReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobReports
    **/
    _count?: true | JobReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobReportMaxAggregateInputType
  }

  export type GetJobReportAggregateType<T extends JobReportAggregateArgs> = {
        [P in keyof T & keyof AggregateJobReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobReport[P]>
      : GetScalarType<T[P], AggregateJobReport[P]>
  }




  export type JobReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobReportWhereInput
    orderBy?: JobReportOrderByWithAggregationInput | JobReportOrderByWithAggregationInput[]
    by: JobReportScalarFieldEnum[] | JobReportScalarFieldEnum
    having?: JobReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobReportCountAggregateInputType | true
    _avg?: JobReportAvgAggregateInputType
    _sum?: JobReportSumAggregateInputType
    _min?: JobReportMinAggregateInputType
    _max?: JobReportMaxAggregateInputType
  }

  export type JobReportGroupByOutputType = {
    id: string
    vin: string
    uploadedById: string
    createdAt: Date
    status: string
    aiEstimate: number | null
    aiResponse: string | null
    _count: JobReportCountAggregateOutputType | null
    _avg: JobReportAvgAggregateOutputType | null
    _sum: JobReportSumAggregateOutputType | null
    _min: JobReportMinAggregateOutputType | null
    _max: JobReportMaxAggregateOutputType | null
  }

  type GetJobReportGroupByPayload<T extends JobReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobReportGroupByOutputType[P]>
            : GetScalarType<T[P], JobReportGroupByOutputType[P]>
        }
      >
    >


  export type JobReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vin?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    status?: boolean
    aiEstimate?: boolean
    aiResponse?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    images?: boolean | JobReport$imagesArgs<ExtArgs>
    detectedDamages?: boolean | JobReport$detectedDamagesArgs<ExtArgs>
    repairEstimates?: boolean | JobReport$repairEstimatesArgs<ExtArgs>
    actualRepairs?: boolean | JobReport$actualRepairsArgs<ExtArgs>
    feedbacks?: boolean | JobReport$feedbacksArgs<ExtArgs>
    vinMetadata?: boolean | JobReport$vinMetadataArgs<ExtArgs>
    _count?: boolean | JobReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobReport"]>

  export type JobReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vin?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    status?: boolean
    aiEstimate?: boolean
    aiResponse?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobReport"]>

  export type JobReportSelectScalar = {
    id?: boolean
    vin?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    status?: boolean
    aiEstimate?: boolean
    aiResponse?: boolean
  }

  export type JobReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    images?: boolean | JobReport$imagesArgs<ExtArgs>
    detectedDamages?: boolean | JobReport$detectedDamagesArgs<ExtArgs>
    repairEstimates?: boolean | JobReport$repairEstimatesArgs<ExtArgs>
    actualRepairs?: boolean | JobReport$actualRepairsArgs<ExtArgs>
    feedbacks?: boolean | JobReport$feedbacksArgs<ExtArgs>
    vinMetadata?: boolean | JobReport$vinMetadataArgs<ExtArgs>
    _count?: boolean | JobReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $JobReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      images: Prisma.$ImagePayload<ExtArgs>[]
      detectedDamages: Prisma.$DetectedDamagePayload<ExtArgs>[]
      repairEstimates: Prisma.$RepairEstimatePayload<ExtArgs>[]
      actualRepairs: Prisma.$ActualRepairPayload<ExtArgs>[]
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
      vinMetadata: Prisma.$VINMetadataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vin: string
      uploadedById: string
      createdAt: Date
      status: string
      aiEstimate: number | null
      aiResponse: string | null
    }, ExtArgs["result"]["jobReport"]>
    composites: {}
  }

  type JobReportGetPayload<S extends boolean | null | undefined | JobReportDefaultArgs> = $Result.GetResult<Prisma.$JobReportPayload, S>

  type JobReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobReportCountAggregateInputType | true
    }

  export interface JobReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobReport'], meta: { name: 'JobReport' } }
    /**
     * Find zero or one JobReport that matches the filter.
     * @param {JobReportFindUniqueArgs} args - Arguments to find a JobReport
     * @example
     * // Get one JobReport
     * const jobReport = await prisma.jobReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobReportFindUniqueArgs>(args: SelectSubset<T, JobReportFindUniqueArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobReportFindUniqueOrThrowArgs} args - Arguments to find a JobReport
     * @example
     * // Get one JobReport
     * const jobReport = await prisma.jobReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobReportFindUniqueOrThrowArgs>(args: SelectSubset<T, JobReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReportFindFirstArgs} args - Arguments to find a JobReport
     * @example
     * // Get one JobReport
     * const jobReport = await prisma.jobReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobReportFindFirstArgs>(args?: SelectSubset<T, JobReportFindFirstArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReportFindFirstOrThrowArgs} args - Arguments to find a JobReport
     * @example
     * // Get one JobReport
     * const jobReport = await prisma.jobReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobReportFindFirstOrThrowArgs>(args?: SelectSubset<T, JobReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobReports
     * const jobReports = await prisma.jobReport.findMany()
     * 
     * // Get first 10 JobReports
     * const jobReports = await prisma.jobReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobReportWithIdOnly = await prisma.jobReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobReportFindManyArgs>(args?: SelectSubset<T, JobReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobReport.
     * @param {JobReportCreateArgs} args - Arguments to create a JobReport.
     * @example
     * // Create one JobReport
     * const JobReport = await prisma.jobReport.create({
     *   data: {
     *     // ... data to create a JobReport
     *   }
     * })
     * 
     */
    create<T extends JobReportCreateArgs>(args: SelectSubset<T, JobReportCreateArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobReports.
     * @param {JobReportCreateManyArgs} args - Arguments to create many JobReports.
     * @example
     * // Create many JobReports
     * const jobReport = await prisma.jobReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobReportCreateManyArgs>(args?: SelectSubset<T, JobReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobReports and returns the data saved in the database.
     * @param {JobReportCreateManyAndReturnArgs} args - Arguments to create many JobReports.
     * @example
     * // Create many JobReports
     * const jobReport = await prisma.jobReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobReports and only return the `id`
     * const jobReportWithIdOnly = await prisma.jobReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobReportCreateManyAndReturnArgs>(args?: SelectSubset<T, JobReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JobReport.
     * @param {JobReportDeleteArgs} args - Arguments to delete one JobReport.
     * @example
     * // Delete one JobReport
     * const JobReport = await prisma.jobReport.delete({
     *   where: {
     *     // ... filter to delete one JobReport
     *   }
     * })
     * 
     */
    delete<T extends JobReportDeleteArgs>(args: SelectSubset<T, JobReportDeleteArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobReport.
     * @param {JobReportUpdateArgs} args - Arguments to update one JobReport.
     * @example
     * // Update one JobReport
     * const jobReport = await prisma.jobReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobReportUpdateArgs>(args: SelectSubset<T, JobReportUpdateArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobReports.
     * @param {JobReportDeleteManyArgs} args - Arguments to filter JobReports to delete.
     * @example
     * // Delete a few JobReports
     * const { count } = await prisma.jobReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobReportDeleteManyArgs>(args?: SelectSubset<T, JobReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobReports
     * const jobReport = await prisma.jobReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobReportUpdateManyArgs>(args: SelectSubset<T, JobReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobReport.
     * @param {JobReportUpsertArgs} args - Arguments to update or create a JobReport.
     * @example
     * // Update or create a JobReport
     * const jobReport = await prisma.jobReport.upsert({
     *   create: {
     *     // ... data to create a JobReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobReport we want to update
     *   }
     * })
     */
    upsert<T extends JobReportUpsertArgs>(args: SelectSubset<T, JobReportUpsertArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReportCountArgs} args - Arguments to filter JobReports to count.
     * @example
     * // Count the number of JobReports
     * const count = await prisma.jobReport.count({
     *   where: {
     *     // ... the filter for the JobReports we want to count
     *   }
     * })
    **/
    count<T extends JobReportCountArgs>(
      args?: Subset<T, JobReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobReportAggregateArgs>(args: Subset<T, JobReportAggregateArgs>): Prisma.PrismaPromise<GetJobReportAggregateType<T>>

    /**
     * Group by JobReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobReportGroupByArgs['orderBy'] }
        : { orderBy?: JobReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobReport model
   */
  readonly fields: JobReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    images<T extends JobReport$imagesArgs<ExtArgs> = {}>(args?: Subset<T, JobReport$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany"> | Null>
    detectedDamages<T extends JobReport$detectedDamagesArgs<ExtArgs> = {}>(args?: Subset<T, JobReport$detectedDamagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "findMany"> | Null>
    repairEstimates<T extends JobReport$repairEstimatesArgs<ExtArgs> = {}>(args?: Subset<T, JobReport$repairEstimatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "findMany"> | Null>
    actualRepairs<T extends JobReport$actualRepairsArgs<ExtArgs> = {}>(args?: Subset<T, JobReport$actualRepairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "findMany"> | Null>
    feedbacks<T extends JobReport$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, JobReport$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    vinMetadata<T extends JobReport$vinMetadataArgs<ExtArgs> = {}>(args?: Subset<T, JobReport$vinMetadataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobReport model
   */ 
  interface JobReportFieldRefs {
    readonly id: FieldRef<"JobReport", 'String'>
    readonly vin: FieldRef<"JobReport", 'String'>
    readonly uploadedById: FieldRef<"JobReport", 'String'>
    readonly createdAt: FieldRef<"JobReport", 'DateTime'>
    readonly status: FieldRef<"JobReport", 'String'>
    readonly aiEstimate: FieldRef<"JobReport", 'Float'>
    readonly aiResponse: FieldRef<"JobReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobReport findUnique
   */
  export type JobReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    /**
     * Filter, which JobReport to fetch.
     */
    where: JobReportWhereUniqueInput
  }

  /**
   * JobReport findUniqueOrThrow
   */
  export type JobReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    /**
     * Filter, which JobReport to fetch.
     */
    where: JobReportWhereUniqueInput
  }

  /**
   * JobReport findFirst
   */
  export type JobReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    /**
     * Filter, which JobReport to fetch.
     */
    where?: JobReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobReports to fetch.
     */
    orderBy?: JobReportOrderByWithRelationInput | JobReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobReports.
     */
    cursor?: JobReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobReports.
     */
    distinct?: JobReportScalarFieldEnum | JobReportScalarFieldEnum[]
  }

  /**
   * JobReport findFirstOrThrow
   */
  export type JobReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    /**
     * Filter, which JobReport to fetch.
     */
    where?: JobReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobReports to fetch.
     */
    orderBy?: JobReportOrderByWithRelationInput | JobReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobReports.
     */
    cursor?: JobReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobReports.
     */
    distinct?: JobReportScalarFieldEnum | JobReportScalarFieldEnum[]
  }

  /**
   * JobReport findMany
   */
  export type JobReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    /**
     * Filter, which JobReports to fetch.
     */
    where?: JobReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobReports to fetch.
     */
    orderBy?: JobReportOrderByWithRelationInput | JobReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobReports.
     */
    cursor?: JobReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobReports.
     */
    skip?: number
    distinct?: JobReportScalarFieldEnum | JobReportScalarFieldEnum[]
  }

  /**
   * JobReport create
   */
  export type JobReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    /**
     * The data needed to create a JobReport.
     */
    data: XOR<JobReportCreateInput, JobReportUncheckedCreateInput>
  }

  /**
   * JobReport createMany
   */
  export type JobReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobReports.
     */
    data: JobReportCreateManyInput | JobReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobReport createManyAndReturn
   */
  export type JobReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JobReports.
     */
    data: JobReportCreateManyInput | JobReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobReport update
   */
  export type JobReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    /**
     * The data needed to update a JobReport.
     */
    data: XOR<JobReportUpdateInput, JobReportUncheckedUpdateInput>
    /**
     * Choose, which JobReport to update.
     */
    where: JobReportWhereUniqueInput
  }

  /**
   * JobReport updateMany
   */
  export type JobReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobReports.
     */
    data: XOR<JobReportUpdateManyMutationInput, JobReportUncheckedUpdateManyInput>
    /**
     * Filter which JobReports to update
     */
    where?: JobReportWhereInput
  }

  /**
   * JobReport upsert
   */
  export type JobReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    /**
     * The filter to search for the JobReport to update in case it exists.
     */
    where: JobReportWhereUniqueInput
    /**
     * In case the JobReport found by the `where` argument doesn't exist, create a new JobReport with this data.
     */
    create: XOR<JobReportCreateInput, JobReportUncheckedCreateInput>
    /**
     * In case the JobReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobReportUpdateInput, JobReportUncheckedUpdateInput>
  }

  /**
   * JobReport delete
   */
  export type JobReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    /**
     * Filter which JobReport to delete.
     */
    where: JobReportWhereUniqueInput
  }

  /**
   * JobReport deleteMany
   */
  export type JobReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobReports to delete
     */
    where?: JobReportWhereInput
  }

  /**
   * JobReport.images
   */
  export type JobReport$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * JobReport.detectedDamages
   */
  export type JobReport$detectedDamagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    where?: DetectedDamageWhereInput
    orderBy?: DetectedDamageOrderByWithRelationInput | DetectedDamageOrderByWithRelationInput[]
    cursor?: DetectedDamageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetectedDamageScalarFieldEnum | DetectedDamageScalarFieldEnum[]
  }

  /**
   * JobReport.repairEstimates
   */
  export type JobReport$repairEstimatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    where?: RepairEstimateWhereInput
    orderBy?: RepairEstimateOrderByWithRelationInput | RepairEstimateOrderByWithRelationInput[]
    cursor?: RepairEstimateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepairEstimateScalarFieldEnum | RepairEstimateScalarFieldEnum[]
  }

  /**
   * JobReport.actualRepairs
   */
  export type JobReport$actualRepairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    where?: ActualRepairWhereInput
    orderBy?: ActualRepairOrderByWithRelationInput | ActualRepairOrderByWithRelationInput[]
    cursor?: ActualRepairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActualRepairScalarFieldEnum | ActualRepairScalarFieldEnum[]
  }

  /**
   * JobReport.feedbacks
   */
  export type JobReport$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * JobReport.vinMetadata
   */
  export type JobReport$vinMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    where?: VINMetadataWhereInput
    orderBy?: VINMetadataOrderByWithRelationInput | VINMetadataOrderByWithRelationInput[]
    cursor?: VINMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VINMetadataScalarFieldEnum | VINMetadataScalarFieldEnum[]
  }

  /**
   * JobReport without action
   */
  export type JobReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
  }


  /**
   * Model RepairEstimate
   */

  export type AggregateRepairEstimate = {
    _count: RepairEstimateCountAggregateOutputType | null
    _avg: RepairEstimateAvgAggregateOutputType | null
    _sum: RepairEstimateSumAggregateOutputType | null
    _min: RepairEstimateMinAggregateOutputType | null
    _max: RepairEstimateMaxAggregateOutputType | null
  }

  export type RepairEstimateAvgAggregateOutputType = {
    timeEstimate: number | null
    costEstimate: number | null
  }

  export type RepairEstimateSumAggregateOutputType = {
    timeEstimate: number | null
    costEstimate: number | null
  }

  export type RepairEstimateMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    timeEstimate: number | null
    costEstimate: number | null
    createdAt: Date | null
  }

  export type RepairEstimateMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    timeEstimate: number | null
    costEstimate: number | null
    createdAt: Date | null
  }

  export type RepairEstimateCountAggregateOutputType = {
    id: number
    jobId: number
    timeEstimate: number
    costEstimate: number
    createdAt: number
    _all: number
  }


  export type RepairEstimateAvgAggregateInputType = {
    timeEstimate?: true
    costEstimate?: true
  }

  export type RepairEstimateSumAggregateInputType = {
    timeEstimate?: true
    costEstimate?: true
  }

  export type RepairEstimateMinAggregateInputType = {
    id?: true
    jobId?: true
    timeEstimate?: true
    costEstimate?: true
    createdAt?: true
  }

  export type RepairEstimateMaxAggregateInputType = {
    id?: true
    jobId?: true
    timeEstimate?: true
    costEstimate?: true
    createdAt?: true
  }

  export type RepairEstimateCountAggregateInputType = {
    id?: true
    jobId?: true
    timeEstimate?: true
    costEstimate?: true
    createdAt?: true
    _all?: true
  }

  export type RepairEstimateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepairEstimate to aggregate.
     */
    where?: RepairEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairEstimates to fetch.
     */
    orderBy?: RepairEstimateOrderByWithRelationInput | RepairEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairEstimates
    **/
    _count?: true | RepairEstimateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairEstimateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairEstimateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairEstimateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairEstimateMaxAggregateInputType
  }

  export type GetRepairEstimateAggregateType<T extends RepairEstimateAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairEstimate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairEstimate[P]>
      : GetScalarType<T[P], AggregateRepairEstimate[P]>
  }




  export type RepairEstimateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairEstimateWhereInput
    orderBy?: RepairEstimateOrderByWithAggregationInput | RepairEstimateOrderByWithAggregationInput[]
    by: RepairEstimateScalarFieldEnum[] | RepairEstimateScalarFieldEnum
    having?: RepairEstimateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairEstimateCountAggregateInputType | true
    _avg?: RepairEstimateAvgAggregateInputType
    _sum?: RepairEstimateSumAggregateInputType
    _min?: RepairEstimateMinAggregateInputType
    _max?: RepairEstimateMaxAggregateInputType
  }

  export type RepairEstimateGroupByOutputType = {
    id: string
    jobId: string
    timeEstimate: number
    costEstimate: number
    createdAt: Date
    _count: RepairEstimateCountAggregateOutputType | null
    _avg: RepairEstimateAvgAggregateOutputType | null
    _sum: RepairEstimateSumAggregateOutputType | null
    _min: RepairEstimateMinAggregateOutputType | null
    _max: RepairEstimateMaxAggregateOutputType | null
  }

  type GetRepairEstimateGroupByPayload<T extends RepairEstimateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepairEstimateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairEstimateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairEstimateGroupByOutputType[P]>
            : GetScalarType<T[P], RepairEstimateGroupByOutputType[P]>
        }
      >
    >


  export type RepairEstimateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    timeEstimate?: boolean
    costEstimate?: boolean
    createdAt?: boolean
    job?: boolean | JobReportDefaultArgs<ExtArgs>
    feedback?: boolean | RepairEstimate$feedbackArgs<ExtArgs>
  }, ExtArgs["result"]["repairEstimate"]>

  export type RepairEstimateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    timeEstimate?: boolean
    costEstimate?: boolean
    createdAt?: boolean
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repairEstimate"]>

  export type RepairEstimateSelectScalar = {
    id?: boolean
    jobId?: boolean
    timeEstimate?: boolean
    costEstimate?: boolean
    createdAt?: boolean
  }

  export type RepairEstimateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobReportDefaultArgs<ExtArgs>
    feedback?: boolean | RepairEstimate$feedbackArgs<ExtArgs>
  }
  export type RepairEstimateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }

  export type $RepairEstimatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RepairEstimate"
    objects: {
      job: Prisma.$JobReportPayload<ExtArgs>
      feedback: Prisma.$FeedbackPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      timeEstimate: number
      costEstimate: number
      createdAt: Date
    }, ExtArgs["result"]["repairEstimate"]>
    composites: {}
  }

  type RepairEstimateGetPayload<S extends boolean | null | undefined | RepairEstimateDefaultArgs> = $Result.GetResult<Prisma.$RepairEstimatePayload, S>

  type RepairEstimateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RepairEstimateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RepairEstimateCountAggregateInputType | true
    }

  export interface RepairEstimateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RepairEstimate'], meta: { name: 'RepairEstimate' } }
    /**
     * Find zero or one RepairEstimate that matches the filter.
     * @param {RepairEstimateFindUniqueArgs} args - Arguments to find a RepairEstimate
     * @example
     * // Get one RepairEstimate
     * const repairEstimate = await prisma.repairEstimate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepairEstimateFindUniqueArgs>(args: SelectSubset<T, RepairEstimateFindUniqueArgs<ExtArgs>>): Prisma__RepairEstimateClient<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RepairEstimate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RepairEstimateFindUniqueOrThrowArgs} args - Arguments to find a RepairEstimate
     * @example
     * // Get one RepairEstimate
     * const repairEstimate = await prisma.repairEstimate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepairEstimateFindUniqueOrThrowArgs>(args: SelectSubset<T, RepairEstimateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepairEstimateClient<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RepairEstimate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEstimateFindFirstArgs} args - Arguments to find a RepairEstimate
     * @example
     * // Get one RepairEstimate
     * const repairEstimate = await prisma.repairEstimate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepairEstimateFindFirstArgs>(args?: SelectSubset<T, RepairEstimateFindFirstArgs<ExtArgs>>): Prisma__RepairEstimateClient<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RepairEstimate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEstimateFindFirstOrThrowArgs} args - Arguments to find a RepairEstimate
     * @example
     * // Get one RepairEstimate
     * const repairEstimate = await prisma.repairEstimate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepairEstimateFindFirstOrThrowArgs>(args?: SelectSubset<T, RepairEstimateFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepairEstimateClient<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RepairEstimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEstimateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairEstimates
     * const repairEstimates = await prisma.repairEstimate.findMany()
     * 
     * // Get first 10 RepairEstimates
     * const repairEstimates = await prisma.repairEstimate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairEstimateWithIdOnly = await prisma.repairEstimate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepairEstimateFindManyArgs>(args?: SelectSubset<T, RepairEstimateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RepairEstimate.
     * @param {RepairEstimateCreateArgs} args - Arguments to create a RepairEstimate.
     * @example
     * // Create one RepairEstimate
     * const RepairEstimate = await prisma.repairEstimate.create({
     *   data: {
     *     // ... data to create a RepairEstimate
     *   }
     * })
     * 
     */
    create<T extends RepairEstimateCreateArgs>(args: SelectSubset<T, RepairEstimateCreateArgs<ExtArgs>>): Prisma__RepairEstimateClient<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RepairEstimates.
     * @param {RepairEstimateCreateManyArgs} args - Arguments to create many RepairEstimates.
     * @example
     * // Create many RepairEstimates
     * const repairEstimate = await prisma.repairEstimate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepairEstimateCreateManyArgs>(args?: SelectSubset<T, RepairEstimateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RepairEstimates and returns the data saved in the database.
     * @param {RepairEstimateCreateManyAndReturnArgs} args - Arguments to create many RepairEstimates.
     * @example
     * // Create many RepairEstimates
     * const repairEstimate = await prisma.repairEstimate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RepairEstimates and only return the `id`
     * const repairEstimateWithIdOnly = await prisma.repairEstimate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RepairEstimateCreateManyAndReturnArgs>(args?: SelectSubset<T, RepairEstimateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RepairEstimate.
     * @param {RepairEstimateDeleteArgs} args - Arguments to delete one RepairEstimate.
     * @example
     * // Delete one RepairEstimate
     * const RepairEstimate = await prisma.repairEstimate.delete({
     *   where: {
     *     // ... filter to delete one RepairEstimate
     *   }
     * })
     * 
     */
    delete<T extends RepairEstimateDeleteArgs>(args: SelectSubset<T, RepairEstimateDeleteArgs<ExtArgs>>): Prisma__RepairEstimateClient<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RepairEstimate.
     * @param {RepairEstimateUpdateArgs} args - Arguments to update one RepairEstimate.
     * @example
     * // Update one RepairEstimate
     * const repairEstimate = await prisma.repairEstimate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepairEstimateUpdateArgs>(args: SelectSubset<T, RepairEstimateUpdateArgs<ExtArgs>>): Prisma__RepairEstimateClient<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RepairEstimates.
     * @param {RepairEstimateDeleteManyArgs} args - Arguments to filter RepairEstimates to delete.
     * @example
     * // Delete a few RepairEstimates
     * const { count } = await prisma.repairEstimate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepairEstimateDeleteManyArgs>(args?: SelectSubset<T, RepairEstimateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairEstimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEstimateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairEstimates
     * const repairEstimate = await prisma.repairEstimate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepairEstimateUpdateManyArgs>(args: SelectSubset<T, RepairEstimateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairEstimate.
     * @param {RepairEstimateUpsertArgs} args - Arguments to update or create a RepairEstimate.
     * @example
     * // Update or create a RepairEstimate
     * const repairEstimate = await prisma.repairEstimate.upsert({
     *   create: {
     *     // ... data to create a RepairEstimate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairEstimate we want to update
     *   }
     * })
     */
    upsert<T extends RepairEstimateUpsertArgs>(args: SelectSubset<T, RepairEstimateUpsertArgs<ExtArgs>>): Prisma__RepairEstimateClient<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RepairEstimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEstimateCountArgs} args - Arguments to filter RepairEstimates to count.
     * @example
     * // Count the number of RepairEstimates
     * const count = await prisma.repairEstimate.count({
     *   where: {
     *     // ... the filter for the RepairEstimates we want to count
     *   }
     * })
    **/
    count<T extends RepairEstimateCountArgs>(
      args?: Subset<T, RepairEstimateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairEstimateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairEstimate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEstimateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairEstimateAggregateArgs>(args: Subset<T, RepairEstimateAggregateArgs>): Prisma.PrismaPromise<GetRepairEstimateAggregateType<T>>

    /**
     * Group by RepairEstimate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairEstimateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairEstimateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairEstimateGroupByArgs['orderBy'] }
        : { orderBy?: RepairEstimateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairEstimateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairEstimateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RepairEstimate model
   */
  readonly fields: RepairEstimateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairEstimate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepairEstimateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobReportDefaultArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    feedback<T extends RepairEstimate$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, RepairEstimate$feedbackArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RepairEstimate model
   */ 
  interface RepairEstimateFieldRefs {
    readonly id: FieldRef<"RepairEstimate", 'String'>
    readonly jobId: FieldRef<"RepairEstimate", 'String'>
    readonly timeEstimate: FieldRef<"RepairEstimate", 'Float'>
    readonly costEstimate: FieldRef<"RepairEstimate", 'Float'>
    readonly createdAt: FieldRef<"RepairEstimate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RepairEstimate findUnique
   */
  export type RepairEstimateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    /**
     * Filter, which RepairEstimate to fetch.
     */
    where: RepairEstimateWhereUniqueInput
  }

  /**
   * RepairEstimate findUniqueOrThrow
   */
  export type RepairEstimateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    /**
     * Filter, which RepairEstimate to fetch.
     */
    where: RepairEstimateWhereUniqueInput
  }

  /**
   * RepairEstimate findFirst
   */
  export type RepairEstimateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    /**
     * Filter, which RepairEstimate to fetch.
     */
    where?: RepairEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairEstimates to fetch.
     */
    orderBy?: RepairEstimateOrderByWithRelationInput | RepairEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairEstimates.
     */
    cursor?: RepairEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairEstimates.
     */
    distinct?: RepairEstimateScalarFieldEnum | RepairEstimateScalarFieldEnum[]
  }

  /**
   * RepairEstimate findFirstOrThrow
   */
  export type RepairEstimateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    /**
     * Filter, which RepairEstimate to fetch.
     */
    where?: RepairEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairEstimates to fetch.
     */
    orderBy?: RepairEstimateOrderByWithRelationInput | RepairEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairEstimates.
     */
    cursor?: RepairEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairEstimates.
     */
    distinct?: RepairEstimateScalarFieldEnum | RepairEstimateScalarFieldEnum[]
  }

  /**
   * RepairEstimate findMany
   */
  export type RepairEstimateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    /**
     * Filter, which RepairEstimates to fetch.
     */
    where?: RepairEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairEstimates to fetch.
     */
    orderBy?: RepairEstimateOrderByWithRelationInput | RepairEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairEstimates.
     */
    cursor?: RepairEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairEstimates.
     */
    skip?: number
    distinct?: RepairEstimateScalarFieldEnum | RepairEstimateScalarFieldEnum[]
  }

  /**
   * RepairEstimate create
   */
  export type RepairEstimateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    /**
     * The data needed to create a RepairEstimate.
     */
    data: XOR<RepairEstimateCreateInput, RepairEstimateUncheckedCreateInput>
  }

  /**
   * RepairEstimate createMany
   */
  export type RepairEstimateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RepairEstimates.
     */
    data: RepairEstimateCreateManyInput | RepairEstimateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RepairEstimate createManyAndReturn
   */
  export type RepairEstimateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RepairEstimates.
     */
    data: RepairEstimateCreateManyInput | RepairEstimateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RepairEstimate update
   */
  export type RepairEstimateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    /**
     * The data needed to update a RepairEstimate.
     */
    data: XOR<RepairEstimateUpdateInput, RepairEstimateUncheckedUpdateInput>
    /**
     * Choose, which RepairEstimate to update.
     */
    where: RepairEstimateWhereUniqueInput
  }

  /**
   * RepairEstimate updateMany
   */
  export type RepairEstimateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RepairEstimates.
     */
    data: XOR<RepairEstimateUpdateManyMutationInput, RepairEstimateUncheckedUpdateManyInput>
    /**
     * Filter which RepairEstimates to update
     */
    where?: RepairEstimateWhereInput
  }

  /**
   * RepairEstimate upsert
   */
  export type RepairEstimateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    /**
     * The filter to search for the RepairEstimate to update in case it exists.
     */
    where: RepairEstimateWhereUniqueInput
    /**
     * In case the RepairEstimate found by the `where` argument doesn't exist, create a new RepairEstimate with this data.
     */
    create: XOR<RepairEstimateCreateInput, RepairEstimateUncheckedCreateInput>
    /**
     * In case the RepairEstimate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairEstimateUpdateInput, RepairEstimateUncheckedUpdateInput>
  }

  /**
   * RepairEstimate delete
   */
  export type RepairEstimateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    /**
     * Filter which RepairEstimate to delete.
     */
    where: RepairEstimateWhereUniqueInput
  }

  /**
   * RepairEstimate deleteMany
   */
  export type RepairEstimateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepairEstimates to delete
     */
    where?: RepairEstimateWhereInput
  }

  /**
   * RepairEstimate.feedback
   */
  export type RepairEstimate$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
  }

  /**
   * RepairEstimate without action
   */
  export type RepairEstimateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    id: number | null
    actualHours: number | null
    experienceScoreSnapshot: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    id: number | null
    actualHours: number | null
    experienceScoreSnapshot: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: number | null
    userId: string | null
    jobId: string | null
    estimateId: string | null
    feedbackType: string | null
    message: string | null
    actualHours: number | null
    experienceScoreSnapshot: number | null
    createdAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    jobId: string | null
    estimateId: string | null
    feedbackType: string | null
    message: string | null
    actualHours: number | null
    experienceScoreSnapshot: number | null
    createdAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    userId: number
    jobId: number
    estimateId: number
    feedbackType: number
    message: number
    actualHours: number
    experienceScoreSnapshot: number
    createdAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    id?: true
    actualHours?: true
    experienceScoreSnapshot?: true
  }

  export type FeedbackSumAggregateInputType = {
    id?: true
    actualHours?: true
    experienceScoreSnapshot?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    jobId?: true
    estimateId?: true
    feedbackType?: true
    message?: true
    actualHours?: true
    experienceScoreSnapshot?: true
    createdAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    jobId?: true
    estimateId?: true
    feedbackType?: true
    message?: true
    actualHours?: true
    experienceScoreSnapshot?: true
    createdAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    jobId?: true
    estimateId?: true
    feedbackType?: true
    message?: true
    actualHours?: true
    experienceScoreSnapshot?: true
    createdAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: number
    userId: string
    jobId: string | null
    estimateId: string | null
    feedbackType: string
    message: string
    actualHours: number | null
    experienceScoreSnapshot: number | null
    createdAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobId?: boolean
    estimateId?: boolean
    feedbackType?: boolean
    message?: boolean
    actualHours?: boolean
    experienceScoreSnapshot?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | Feedback$jobArgs<ExtArgs>
    estimate?: boolean | Feedback$estimateArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobId?: boolean
    estimateId?: boolean
    feedbackType?: boolean
    message?: boolean
    actualHours?: boolean
    experienceScoreSnapshot?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | Feedback$jobArgs<ExtArgs>
    estimate?: boolean | Feedback$estimateArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    jobId?: boolean
    estimateId?: boolean
    feedbackType?: boolean
    message?: boolean
    actualHours?: boolean
    experienceScoreSnapshot?: boolean
    createdAt?: boolean
  }

  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | Feedback$jobArgs<ExtArgs>
    estimate?: boolean | Feedback$estimateArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | Feedback$jobArgs<ExtArgs>
    estimate?: boolean | Feedback$estimateArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      job: Prisma.$JobReportPayload<ExtArgs> | null
      estimate: Prisma.$RepairEstimatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      jobId: string | null
      estimateId: string | null
      feedbackType: string
      message: string
      actualHours: number | null
      experienceScoreSnapshot: number | null
      createdAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    job<T extends Feedback$jobArgs<ExtArgs> = {}>(args?: Subset<T, Feedback$jobArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    estimate<T extends Feedback$estimateArgs<ExtArgs> = {}>(args?: Subset<T, Feedback$estimateArgs<ExtArgs>>): Prisma__RepairEstimateClient<$Result.GetResult<Prisma.$RepairEstimatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'Int'>
    readonly userId: FieldRef<"Feedback", 'String'>
    readonly jobId: FieldRef<"Feedback", 'String'>
    readonly estimateId: FieldRef<"Feedback", 'String'>
    readonly feedbackType: FieldRef<"Feedback", 'String'>
    readonly message: FieldRef<"Feedback", 'String'>
    readonly actualHours: FieldRef<"Feedback", 'Float'>
    readonly experienceScoreSnapshot: FieldRef<"Feedback", 'Float'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback.job
   */
  export type Feedback$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobReport
     */
    select?: JobReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobReportInclude<ExtArgs> | null
    where?: JobReportWhereInput
  }

  /**
   * Feedback.estimate
   */
  export type Feedback$estimateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepairEstimate
     */
    select?: RepairEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairEstimateInclude<ExtArgs> | null
    where?: RepairEstimateWhereInput
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    imagePath: string | null
    truckSectionId: string | null
    severityId: string | null
    notes: string | null
    uploadedAt: Date | null
  }

  export type ImageMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    imagePath: string | null
    truckSectionId: string | null
    severityId: string | null
    notes: string | null
    uploadedAt: Date | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    jobId: number
    imagePath: number
    truckSectionId: number
    severityId: number
    notes: number
    uploadedAt: number
    _all: number
  }


  export type ImageMinAggregateInputType = {
    id?: true
    jobId?: true
    imagePath?: true
    truckSectionId?: true
    severityId?: true
    notes?: true
    uploadedAt?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    jobId?: true
    imagePath?: true
    truckSectionId?: true
    severityId?: true
    notes?: true
    uploadedAt?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    jobId?: true
    imagePath?: true
    truckSectionId?: true
    severityId?: true
    notes?: true
    uploadedAt?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: string
    jobId: string
    imagePath: string
    truckSectionId: string | null
    severityId: string | null
    notes: string | null
    uploadedAt: Date
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    imagePath?: boolean
    truckSectionId?: boolean
    severityId?: boolean
    notes?: boolean
    uploadedAt?: boolean
    truckSection?: boolean | Image$truckSectionArgs<ExtArgs>
    vehicleParts?: boolean | Image$vehiclePartsArgs<ExtArgs>
    damageTypes?: boolean | Image$damageTypesArgs<ExtArgs>
    severity?: boolean | Image$severityArgs<ExtArgs>
    job?: boolean | JobReportDefaultArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    imagePath?: boolean
    truckSectionId?: boolean
    severityId?: boolean
    notes?: boolean
    uploadedAt?: boolean
    truckSection?: boolean | Image$truckSectionArgs<ExtArgs>
    severity?: boolean | Image$severityArgs<ExtArgs>
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    id?: boolean
    jobId?: boolean
    imagePath?: boolean
    truckSectionId?: boolean
    severityId?: boolean
    notes?: boolean
    uploadedAt?: boolean
  }

  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truckSection?: boolean | Image$truckSectionArgs<ExtArgs>
    vehicleParts?: boolean | Image$vehiclePartsArgs<ExtArgs>
    damageTypes?: boolean | Image$damageTypesArgs<ExtArgs>
    severity?: boolean | Image$severityArgs<ExtArgs>
    job?: boolean | JobReportDefaultArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truckSection?: boolean | Image$truckSectionArgs<ExtArgs>
    severity?: boolean | Image$severityArgs<ExtArgs>
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      truckSection: Prisma.$TruckSectionPayload<ExtArgs> | null
      vehicleParts: Prisma.$ImageVehiclePartPayload<ExtArgs>[]
      damageTypes: Prisma.$ImageDamageTypePayload<ExtArgs>[]
      severity: Prisma.$SeverityLevelPayload<ExtArgs> | null
      job: Prisma.$JobReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      imagePath: string
      truckSectionId: string | null
      severityId: string | null
      notes: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truckSection<T extends Image$truckSectionArgs<ExtArgs> = {}>(args?: Subset<T, Image$truckSectionArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vehicleParts<T extends Image$vehiclePartsArgs<ExtArgs> = {}>(args?: Subset<T, Image$vehiclePartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "findMany"> | Null>
    damageTypes<T extends Image$damageTypesArgs<ExtArgs> = {}>(args?: Subset<T, Image$damageTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "findMany"> | Null>
    severity<T extends Image$severityArgs<ExtArgs> = {}>(args?: Subset<T, Image$severityArgs<ExtArgs>>): Prisma__SeverityLevelClient<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    job<T extends JobReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobReportDefaultArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */ 
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'String'>
    readonly jobId: FieldRef<"Image", 'String'>
    readonly imagePath: FieldRef<"Image", 'String'>
    readonly truckSectionId: FieldRef<"Image", 'String'>
    readonly severityId: FieldRef<"Image", 'String'>
    readonly notes: FieldRef<"Image", 'String'>
    readonly uploadedAt: FieldRef<"Image", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image createManyAndReturn
   */
  export type ImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
  }

  /**
   * Image.truckSection
   */
  export type Image$truckSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    where?: TruckSectionWhereInput
  }

  /**
   * Image.vehicleParts
   */
  export type Image$vehiclePartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    where?: ImageVehiclePartWhereInput
    orderBy?: ImageVehiclePartOrderByWithRelationInput | ImageVehiclePartOrderByWithRelationInput[]
    cursor?: ImageVehiclePartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageVehiclePartScalarFieldEnum | ImageVehiclePartScalarFieldEnum[]
  }

  /**
   * Image.damageTypes
   */
  export type Image$damageTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    where?: ImageDamageTypeWhereInput
    orderBy?: ImageDamageTypeOrderByWithRelationInput | ImageDamageTypeOrderByWithRelationInput[]
    cursor?: ImageDamageTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageDamageTypeScalarFieldEnum | ImageDamageTypeScalarFieldEnum[]
  }

  /**
   * Image.severity
   */
  export type Image$severityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    where?: SeverityLevelWhereInput
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model DetectedDamage
   */

  export type AggregateDetectedDamage = {
    _count: DetectedDamageCountAggregateOutputType | null
    _min: DetectedDamageMinAggregateOutputType | null
    _max: DetectedDamageMaxAggregateOutputType | null
  }

  export type DetectedDamageMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    aiOutputJson: string | null
    generatedAt: Date | null
  }

  export type DetectedDamageMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    aiOutputJson: string | null
    generatedAt: Date | null
  }

  export type DetectedDamageCountAggregateOutputType = {
    id: number
    jobId: number
    aiOutputJson: number
    generatedAt: number
    _all: number
  }


  export type DetectedDamageMinAggregateInputType = {
    id?: true
    jobId?: true
    aiOutputJson?: true
    generatedAt?: true
  }

  export type DetectedDamageMaxAggregateInputType = {
    id?: true
    jobId?: true
    aiOutputJson?: true
    generatedAt?: true
  }

  export type DetectedDamageCountAggregateInputType = {
    id?: true
    jobId?: true
    aiOutputJson?: true
    generatedAt?: true
    _all?: true
  }

  export type DetectedDamageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetectedDamage to aggregate.
     */
    where?: DetectedDamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedDamages to fetch.
     */
    orderBy?: DetectedDamageOrderByWithRelationInput | DetectedDamageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetectedDamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedDamages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedDamages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetectedDamages
    **/
    _count?: true | DetectedDamageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetectedDamageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetectedDamageMaxAggregateInputType
  }

  export type GetDetectedDamageAggregateType<T extends DetectedDamageAggregateArgs> = {
        [P in keyof T & keyof AggregateDetectedDamage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetectedDamage[P]>
      : GetScalarType<T[P], AggregateDetectedDamage[P]>
  }




  export type DetectedDamageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetectedDamageWhereInput
    orderBy?: DetectedDamageOrderByWithAggregationInput | DetectedDamageOrderByWithAggregationInput[]
    by: DetectedDamageScalarFieldEnum[] | DetectedDamageScalarFieldEnum
    having?: DetectedDamageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetectedDamageCountAggregateInputType | true
    _min?: DetectedDamageMinAggregateInputType
    _max?: DetectedDamageMaxAggregateInputType
  }

  export type DetectedDamageGroupByOutputType = {
    id: string
    jobId: string
    aiOutputJson: string
    generatedAt: Date
    _count: DetectedDamageCountAggregateOutputType | null
    _min: DetectedDamageMinAggregateOutputType | null
    _max: DetectedDamageMaxAggregateOutputType | null
  }

  type GetDetectedDamageGroupByPayload<T extends DetectedDamageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetectedDamageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetectedDamageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetectedDamageGroupByOutputType[P]>
            : GetScalarType<T[P], DetectedDamageGroupByOutputType[P]>
        }
      >
    >


  export type DetectedDamageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    aiOutputJson?: boolean
    generatedAt?: boolean
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detectedDamage"]>

  export type DetectedDamageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    aiOutputJson?: boolean
    generatedAt?: boolean
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detectedDamage"]>

  export type DetectedDamageSelectScalar = {
    id?: boolean
    jobId?: boolean
    aiOutputJson?: boolean
    generatedAt?: boolean
  }

  export type DetectedDamageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }
  export type DetectedDamageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }

  export type $DetectedDamagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetectedDamage"
    objects: {
      job: Prisma.$JobReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      aiOutputJson: string
      generatedAt: Date
    }, ExtArgs["result"]["detectedDamage"]>
    composites: {}
  }

  type DetectedDamageGetPayload<S extends boolean | null | undefined | DetectedDamageDefaultArgs> = $Result.GetResult<Prisma.$DetectedDamagePayload, S>

  type DetectedDamageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DetectedDamageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DetectedDamageCountAggregateInputType | true
    }

  export interface DetectedDamageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetectedDamage'], meta: { name: 'DetectedDamage' } }
    /**
     * Find zero or one DetectedDamage that matches the filter.
     * @param {DetectedDamageFindUniqueArgs} args - Arguments to find a DetectedDamage
     * @example
     * // Get one DetectedDamage
     * const detectedDamage = await prisma.detectedDamage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetectedDamageFindUniqueArgs>(args: SelectSubset<T, DetectedDamageFindUniqueArgs<ExtArgs>>): Prisma__DetectedDamageClient<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DetectedDamage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DetectedDamageFindUniqueOrThrowArgs} args - Arguments to find a DetectedDamage
     * @example
     * // Get one DetectedDamage
     * const detectedDamage = await prisma.detectedDamage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetectedDamageFindUniqueOrThrowArgs>(args: SelectSubset<T, DetectedDamageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetectedDamageClient<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DetectedDamage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedDamageFindFirstArgs} args - Arguments to find a DetectedDamage
     * @example
     * // Get one DetectedDamage
     * const detectedDamage = await prisma.detectedDamage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetectedDamageFindFirstArgs>(args?: SelectSubset<T, DetectedDamageFindFirstArgs<ExtArgs>>): Prisma__DetectedDamageClient<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DetectedDamage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedDamageFindFirstOrThrowArgs} args - Arguments to find a DetectedDamage
     * @example
     * // Get one DetectedDamage
     * const detectedDamage = await prisma.detectedDamage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetectedDamageFindFirstOrThrowArgs>(args?: SelectSubset<T, DetectedDamageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetectedDamageClient<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DetectedDamages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedDamageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetectedDamages
     * const detectedDamages = await prisma.detectedDamage.findMany()
     * 
     * // Get first 10 DetectedDamages
     * const detectedDamages = await prisma.detectedDamage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detectedDamageWithIdOnly = await prisma.detectedDamage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetectedDamageFindManyArgs>(args?: SelectSubset<T, DetectedDamageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DetectedDamage.
     * @param {DetectedDamageCreateArgs} args - Arguments to create a DetectedDamage.
     * @example
     * // Create one DetectedDamage
     * const DetectedDamage = await prisma.detectedDamage.create({
     *   data: {
     *     // ... data to create a DetectedDamage
     *   }
     * })
     * 
     */
    create<T extends DetectedDamageCreateArgs>(args: SelectSubset<T, DetectedDamageCreateArgs<ExtArgs>>): Prisma__DetectedDamageClient<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DetectedDamages.
     * @param {DetectedDamageCreateManyArgs} args - Arguments to create many DetectedDamages.
     * @example
     * // Create many DetectedDamages
     * const detectedDamage = await prisma.detectedDamage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetectedDamageCreateManyArgs>(args?: SelectSubset<T, DetectedDamageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DetectedDamages and returns the data saved in the database.
     * @param {DetectedDamageCreateManyAndReturnArgs} args - Arguments to create many DetectedDamages.
     * @example
     * // Create many DetectedDamages
     * const detectedDamage = await prisma.detectedDamage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DetectedDamages and only return the `id`
     * const detectedDamageWithIdOnly = await prisma.detectedDamage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetectedDamageCreateManyAndReturnArgs>(args?: SelectSubset<T, DetectedDamageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DetectedDamage.
     * @param {DetectedDamageDeleteArgs} args - Arguments to delete one DetectedDamage.
     * @example
     * // Delete one DetectedDamage
     * const DetectedDamage = await prisma.detectedDamage.delete({
     *   where: {
     *     // ... filter to delete one DetectedDamage
     *   }
     * })
     * 
     */
    delete<T extends DetectedDamageDeleteArgs>(args: SelectSubset<T, DetectedDamageDeleteArgs<ExtArgs>>): Prisma__DetectedDamageClient<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DetectedDamage.
     * @param {DetectedDamageUpdateArgs} args - Arguments to update one DetectedDamage.
     * @example
     * // Update one DetectedDamage
     * const detectedDamage = await prisma.detectedDamage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetectedDamageUpdateArgs>(args: SelectSubset<T, DetectedDamageUpdateArgs<ExtArgs>>): Prisma__DetectedDamageClient<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DetectedDamages.
     * @param {DetectedDamageDeleteManyArgs} args - Arguments to filter DetectedDamages to delete.
     * @example
     * // Delete a few DetectedDamages
     * const { count } = await prisma.detectedDamage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetectedDamageDeleteManyArgs>(args?: SelectSubset<T, DetectedDamageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetectedDamages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedDamageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetectedDamages
     * const detectedDamage = await prisma.detectedDamage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetectedDamageUpdateManyArgs>(args: SelectSubset<T, DetectedDamageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetectedDamage.
     * @param {DetectedDamageUpsertArgs} args - Arguments to update or create a DetectedDamage.
     * @example
     * // Update or create a DetectedDamage
     * const detectedDamage = await prisma.detectedDamage.upsert({
     *   create: {
     *     // ... data to create a DetectedDamage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetectedDamage we want to update
     *   }
     * })
     */
    upsert<T extends DetectedDamageUpsertArgs>(args: SelectSubset<T, DetectedDamageUpsertArgs<ExtArgs>>): Prisma__DetectedDamageClient<$Result.GetResult<Prisma.$DetectedDamagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DetectedDamages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedDamageCountArgs} args - Arguments to filter DetectedDamages to count.
     * @example
     * // Count the number of DetectedDamages
     * const count = await prisma.detectedDamage.count({
     *   where: {
     *     // ... the filter for the DetectedDamages we want to count
     *   }
     * })
    **/
    count<T extends DetectedDamageCountArgs>(
      args?: Subset<T, DetectedDamageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetectedDamageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetectedDamage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedDamageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetectedDamageAggregateArgs>(args: Subset<T, DetectedDamageAggregateArgs>): Prisma.PrismaPromise<GetDetectedDamageAggregateType<T>>

    /**
     * Group by DetectedDamage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedDamageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetectedDamageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetectedDamageGroupByArgs['orderBy'] }
        : { orderBy?: DetectedDamageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetectedDamageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetectedDamageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetectedDamage model
   */
  readonly fields: DetectedDamageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetectedDamage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetectedDamageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobReportDefaultArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetectedDamage model
   */ 
  interface DetectedDamageFieldRefs {
    readonly id: FieldRef<"DetectedDamage", 'String'>
    readonly jobId: FieldRef<"DetectedDamage", 'String'>
    readonly aiOutputJson: FieldRef<"DetectedDamage", 'String'>
    readonly generatedAt: FieldRef<"DetectedDamage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DetectedDamage findUnique
   */
  export type DetectedDamageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    /**
     * Filter, which DetectedDamage to fetch.
     */
    where: DetectedDamageWhereUniqueInput
  }

  /**
   * DetectedDamage findUniqueOrThrow
   */
  export type DetectedDamageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    /**
     * Filter, which DetectedDamage to fetch.
     */
    where: DetectedDamageWhereUniqueInput
  }

  /**
   * DetectedDamage findFirst
   */
  export type DetectedDamageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    /**
     * Filter, which DetectedDamage to fetch.
     */
    where?: DetectedDamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedDamages to fetch.
     */
    orderBy?: DetectedDamageOrderByWithRelationInput | DetectedDamageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetectedDamages.
     */
    cursor?: DetectedDamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedDamages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedDamages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetectedDamages.
     */
    distinct?: DetectedDamageScalarFieldEnum | DetectedDamageScalarFieldEnum[]
  }

  /**
   * DetectedDamage findFirstOrThrow
   */
  export type DetectedDamageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    /**
     * Filter, which DetectedDamage to fetch.
     */
    where?: DetectedDamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedDamages to fetch.
     */
    orderBy?: DetectedDamageOrderByWithRelationInput | DetectedDamageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetectedDamages.
     */
    cursor?: DetectedDamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedDamages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedDamages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetectedDamages.
     */
    distinct?: DetectedDamageScalarFieldEnum | DetectedDamageScalarFieldEnum[]
  }

  /**
   * DetectedDamage findMany
   */
  export type DetectedDamageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    /**
     * Filter, which DetectedDamages to fetch.
     */
    where?: DetectedDamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedDamages to fetch.
     */
    orderBy?: DetectedDamageOrderByWithRelationInput | DetectedDamageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetectedDamages.
     */
    cursor?: DetectedDamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedDamages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedDamages.
     */
    skip?: number
    distinct?: DetectedDamageScalarFieldEnum | DetectedDamageScalarFieldEnum[]
  }

  /**
   * DetectedDamage create
   */
  export type DetectedDamageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    /**
     * The data needed to create a DetectedDamage.
     */
    data: XOR<DetectedDamageCreateInput, DetectedDamageUncheckedCreateInput>
  }

  /**
   * DetectedDamage createMany
   */
  export type DetectedDamageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetectedDamages.
     */
    data: DetectedDamageCreateManyInput | DetectedDamageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DetectedDamage createManyAndReturn
   */
  export type DetectedDamageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DetectedDamages.
     */
    data: DetectedDamageCreateManyInput | DetectedDamageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetectedDamage update
   */
  export type DetectedDamageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    /**
     * The data needed to update a DetectedDamage.
     */
    data: XOR<DetectedDamageUpdateInput, DetectedDamageUncheckedUpdateInput>
    /**
     * Choose, which DetectedDamage to update.
     */
    where: DetectedDamageWhereUniqueInput
  }

  /**
   * DetectedDamage updateMany
   */
  export type DetectedDamageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetectedDamages.
     */
    data: XOR<DetectedDamageUpdateManyMutationInput, DetectedDamageUncheckedUpdateManyInput>
    /**
     * Filter which DetectedDamages to update
     */
    where?: DetectedDamageWhereInput
  }

  /**
   * DetectedDamage upsert
   */
  export type DetectedDamageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    /**
     * The filter to search for the DetectedDamage to update in case it exists.
     */
    where: DetectedDamageWhereUniqueInput
    /**
     * In case the DetectedDamage found by the `where` argument doesn't exist, create a new DetectedDamage with this data.
     */
    create: XOR<DetectedDamageCreateInput, DetectedDamageUncheckedCreateInput>
    /**
     * In case the DetectedDamage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetectedDamageUpdateInput, DetectedDamageUncheckedUpdateInput>
  }

  /**
   * DetectedDamage delete
   */
  export type DetectedDamageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
    /**
     * Filter which DetectedDamage to delete.
     */
    where: DetectedDamageWhereUniqueInput
  }

  /**
   * DetectedDamage deleteMany
   */
  export type DetectedDamageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetectedDamages to delete
     */
    where?: DetectedDamageWhereInput
  }

  /**
   * DetectedDamage without action
   */
  export type DetectedDamageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedDamage
     */
    select?: DetectedDamageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedDamageInclude<ExtArgs> | null
  }


  /**
   * Model ActualRepair
   */

  export type AggregateActualRepair = {
    _count: ActualRepairCountAggregateOutputType | null
    _avg: ActualRepairAvgAggregateOutputType | null
    _sum: ActualRepairSumAggregateOutputType | null
    _min: ActualRepairMinAggregateOutputType | null
    _max: ActualRepairMaxAggregateOutputType | null
  }

  export type ActualRepairAvgAggregateOutputType = {
    actualHours: number | null
  }

  export type ActualRepairSumAggregateOutputType = {
    actualHours: number | null
  }

  export type ActualRepairMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    actualHours: number | null
    notes: string | null
    confirmedById: string | null
    confirmedAt: Date | null
  }

  export type ActualRepairMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    actualHours: number | null
    notes: string | null
    confirmedById: string | null
    confirmedAt: Date | null
  }

  export type ActualRepairCountAggregateOutputType = {
    id: number
    jobId: number
    actualHours: number
    notes: number
    confirmedById: number
    confirmedAt: number
    _all: number
  }


  export type ActualRepairAvgAggregateInputType = {
    actualHours?: true
  }

  export type ActualRepairSumAggregateInputType = {
    actualHours?: true
  }

  export type ActualRepairMinAggregateInputType = {
    id?: true
    jobId?: true
    actualHours?: true
    notes?: true
    confirmedById?: true
    confirmedAt?: true
  }

  export type ActualRepairMaxAggregateInputType = {
    id?: true
    jobId?: true
    actualHours?: true
    notes?: true
    confirmedById?: true
    confirmedAt?: true
  }

  export type ActualRepairCountAggregateInputType = {
    id?: true
    jobId?: true
    actualHours?: true
    notes?: true
    confirmedById?: true
    confirmedAt?: true
    _all?: true
  }

  export type ActualRepairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActualRepair to aggregate.
     */
    where?: ActualRepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualRepairs to fetch.
     */
    orderBy?: ActualRepairOrderByWithRelationInput | ActualRepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActualRepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualRepairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualRepairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActualRepairs
    **/
    _count?: true | ActualRepairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActualRepairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActualRepairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActualRepairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActualRepairMaxAggregateInputType
  }

  export type GetActualRepairAggregateType<T extends ActualRepairAggregateArgs> = {
        [P in keyof T & keyof AggregateActualRepair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActualRepair[P]>
      : GetScalarType<T[P], AggregateActualRepair[P]>
  }




  export type ActualRepairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActualRepairWhereInput
    orderBy?: ActualRepairOrderByWithAggregationInput | ActualRepairOrderByWithAggregationInput[]
    by: ActualRepairScalarFieldEnum[] | ActualRepairScalarFieldEnum
    having?: ActualRepairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActualRepairCountAggregateInputType | true
    _avg?: ActualRepairAvgAggregateInputType
    _sum?: ActualRepairSumAggregateInputType
    _min?: ActualRepairMinAggregateInputType
    _max?: ActualRepairMaxAggregateInputType
  }

  export type ActualRepairGroupByOutputType = {
    id: string
    jobId: string
    actualHours: number
    notes: string | null
    confirmedById: string | null
    confirmedAt: Date
    _count: ActualRepairCountAggregateOutputType | null
    _avg: ActualRepairAvgAggregateOutputType | null
    _sum: ActualRepairSumAggregateOutputType | null
    _min: ActualRepairMinAggregateOutputType | null
    _max: ActualRepairMaxAggregateOutputType | null
  }

  type GetActualRepairGroupByPayload<T extends ActualRepairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActualRepairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActualRepairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActualRepairGroupByOutputType[P]>
            : GetScalarType<T[P], ActualRepairGroupByOutputType[P]>
        }
      >
    >


  export type ActualRepairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    actualHours?: boolean
    notes?: boolean
    confirmedById?: boolean
    confirmedAt?: boolean
    job?: boolean | JobReportDefaultArgs<ExtArgs>
    user?: boolean | ActualRepair$userArgs<ExtArgs>
  }, ExtArgs["result"]["actualRepair"]>

  export type ActualRepairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    actualHours?: boolean
    notes?: boolean
    confirmedById?: boolean
    confirmedAt?: boolean
    job?: boolean | JobReportDefaultArgs<ExtArgs>
    user?: boolean | ActualRepair$userArgs<ExtArgs>
  }, ExtArgs["result"]["actualRepair"]>

  export type ActualRepairSelectScalar = {
    id?: boolean
    jobId?: boolean
    actualHours?: boolean
    notes?: boolean
    confirmedById?: boolean
    confirmedAt?: boolean
  }

  export type ActualRepairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobReportDefaultArgs<ExtArgs>
    user?: boolean | ActualRepair$userArgs<ExtArgs>
  }
  export type ActualRepairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobReportDefaultArgs<ExtArgs>
    user?: boolean | ActualRepair$userArgs<ExtArgs>
  }

  export type $ActualRepairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActualRepair"
    objects: {
      job: Prisma.$JobReportPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      actualHours: number
      notes: string | null
      confirmedById: string | null
      confirmedAt: Date
    }, ExtArgs["result"]["actualRepair"]>
    composites: {}
  }

  type ActualRepairGetPayload<S extends boolean | null | undefined | ActualRepairDefaultArgs> = $Result.GetResult<Prisma.$ActualRepairPayload, S>

  type ActualRepairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActualRepairFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActualRepairCountAggregateInputType | true
    }

  export interface ActualRepairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActualRepair'], meta: { name: 'ActualRepair' } }
    /**
     * Find zero or one ActualRepair that matches the filter.
     * @param {ActualRepairFindUniqueArgs} args - Arguments to find a ActualRepair
     * @example
     * // Get one ActualRepair
     * const actualRepair = await prisma.actualRepair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActualRepairFindUniqueArgs>(args: SelectSubset<T, ActualRepairFindUniqueArgs<ExtArgs>>): Prisma__ActualRepairClient<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActualRepair that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActualRepairFindUniqueOrThrowArgs} args - Arguments to find a ActualRepair
     * @example
     * // Get one ActualRepair
     * const actualRepair = await prisma.actualRepair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActualRepairFindUniqueOrThrowArgs>(args: SelectSubset<T, ActualRepairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActualRepairClient<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActualRepair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualRepairFindFirstArgs} args - Arguments to find a ActualRepair
     * @example
     * // Get one ActualRepair
     * const actualRepair = await prisma.actualRepair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActualRepairFindFirstArgs>(args?: SelectSubset<T, ActualRepairFindFirstArgs<ExtArgs>>): Prisma__ActualRepairClient<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActualRepair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualRepairFindFirstOrThrowArgs} args - Arguments to find a ActualRepair
     * @example
     * // Get one ActualRepair
     * const actualRepair = await prisma.actualRepair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActualRepairFindFirstOrThrowArgs>(args?: SelectSubset<T, ActualRepairFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActualRepairClient<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActualRepairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualRepairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActualRepairs
     * const actualRepairs = await prisma.actualRepair.findMany()
     * 
     * // Get first 10 ActualRepairs
     * const actualRepairs = await prisma.actualRepair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actualRepairWithIdOnly = await prisma.actualRepair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActualRepairFindManyArgs>(args?: SelectSubset<T, ActualRepairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActualRepair.
     * @param {ActualRepairCreateArgs} args - Arguments to create a ActualRepair.
     * @example
     * // Create one ActualRepair
     * const ActualRepair = await prisma.actualRepair.create({
     *   data: {
     *     // ... data to create a ActualRepair
     *   }
     * })
     * 
     */
    create<T extends ActualRepairCreateArgs>(args: SelectSubset<T, ActualRepairCreateArgs<ExtArgs>>): Prisma__ActualRepairClient<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActualRepairs.
     * @param {ActualRepairCreateManyArgs} args - Arguments to create many ActualRepairs.
     * @example
     * // Create many ActualRepairs
     * const actualRepair = await prisma.actualRepair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActualRepairCreateManyArgs>(args?: SelectSubset<T, ActualRepairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActualRepairs and returns the data saved in the database.
     * @param {ActualRepairCreateManyAndReturnArgs} args - Arguments to create many ActualRepairs.
     * @example
     * // Create many ActualRepairs
     * const actualRepair = await prisma.actualRepair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActualRepairs and only return the `id`
     * const actualRepairWithIdOnly = await prisma.actualRepair.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActualRepairCreateManyAndReturnArgs>(args?: SelectSubset<T, ActualRepairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActualRepair.
     * @param {ActualRepairDeleteArgs} args - Arguments to delete one ActualRepair.
     * @example
     * // Delete one ActualRepair
     * const ActualRepair = await prisma.actualRepair.delete({
     *   where: {
     *     // ... filter to delete one ActualRepair
     *   }
     * })
     * 
     */
    delete<T extends ActualRepairDeleteArgs>(args: SelectSubset<T, ActualRepairDeleteArgs<ExtArgs>>): Prisma__ActualRepairClient<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActualRepair.
     * @param {ActualRepairUpdateArgs} args - Arguments to update one ActualRepair.
     * @example
     * // Update one ActualRepair
     * const actualRepair = await prisma.actualRepair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActualRepairUpdateArgs>(args: SelectSubset<T, ActualRepairUpdateArgs<ExtArgs>>): Prisma__ActualRepairClient<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActualRepairs.
     * @param {ActualRepairDeleteManyArgs} args - Arguments to filter ActualRepairs to delete.
     * @example
     * // Delete a few ActualRepairs
     * const { count } = await prisma.actualRepair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActualRepairDeleteManyArgs>(args?: SelectSubset<T, ActualRepairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActualRepairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualRepairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActualRepairs
     * const actualRepair = await prisma.actualRepair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActualRepairUpdateManyArgs>(args: SelectSubset<T, ActualRepairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActualRepair.
     * @param {ActualRepairUpsertArgs} args - Arguments to update or create a ActualRepair.
     * @example
     * // Update or create a ActualRepair
     * const actualRepair = await prisma.actualRepair.upsert({
     *   create: {
     *     // ... data to create a ActualRepair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActualRepair we want to update
     *   }
     * })
     */
    upsert<T extends ActualRepairUpsertArgs>(args: SelectSubset<T, ActualRepairUpsertArgs<ExtArgs>>): Prisma__ActualRepairClient<$Result.GetResult<Prisma.$ActualRepairPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActualRepairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualRepairCountArgs} args - Arguments to filter ActualRepairs to count.
     * @example
     * // Count the number of ActualRepairs
     * const count = await prisma.actualRepair.count({
     *   where: {
     *     // ... the filter for the ActualRepairs we want to count
     *   }
     * })
    **/
    count<T extends ActualRepairCountArgs>(
      args?: Subset<T, ActualRepairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActualRepairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActualRepair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualRepairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActualRepairAggregateArgs>(args: Subset<T, ActualRepairAggregateArgs>): Prisma.PrismaPromise<GetActualRepairAggregateType<T>>

    /**
     * Group by ActualRepair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualRepairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActualRepairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActualRepairGroupByArgs['orderBy'] }
        : { orderBy?: ActualRepairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActualRepairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActualRepairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActualRepair model
   */
  readonly fields: ActualRepairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActualRepair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActualRepairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobReportDefaultArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends ActualRepair$userArgs<ExtArgs> = {}>(args?: Subset<T, ActualRepair$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActualRepair model
   */ 
  interface ActualRepairFieldRefs {
    readonly id: FieldRef<"ActualRepair", 'String'>
    readonly jobId: FieldRef<"ActualRepair", 'String'>
    readonly actualHours: FieldRef<"ActualRepair", 'Float'>
    readonly notes: FieldRef<"ActualRepair", 'String'>
    readonly confirmedById: FieldRef<"ActualRepair", 'String'>
    readonly confirmedAt: FieldRef<"ActualRepair", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActualRepair findUnique
   */
  export type ActualRepairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    /**
     * Filter, which ActualRepair to fetch.
     */
    where: ActualRepairWhereUniqueInput
  }

  /**
   * ActualRepair findUniqueOrThrow
   */
  export type ActualRepairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    /**
     * Filter, which ActualRepair to fetch.
     */
    where: ActualRepairWhereUniqueInput
  }

  /**
   * ActualRepair findFirst
   */
  export type ActualRepairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    /**
     * Filter, which ActualRepair to fetch.
     */
    where?: ActualRepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualRepairs to fetch.
     */
    orderBy?: ActualRepairOrderByWithRelationInput | ActualRepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActualRepairs.
     */
    cursor?: ActualRepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualRepairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualRepairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActualRepairs.
     */
    distinct?: ActualRepairScalarFieldEnum | ActualRepairScalarFieldEnum[]
  }

  /**
   * ActualRepair findFirstOrThrow
   */
  export type ActualRepairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    /**
     * Filter, which ActualRepair to fetch.
     */
    where?: ActualRepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualRepairs to fetch.
     */
    orderBy?: ActualRepairOrderByWithRelationInput | ActualRepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActualRepairs.
     */
    cursor?: ActualRepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualRepairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualRepairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActualRepairs.
     */
    distinct?: ActualRepairScalarFieldEnum | ActualRepairScalarFieldEnum[]
  }

  /**
   * ActualRepair findMany
   */
  export type ActualRepairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    /**
     * Filter, which ActualRepairs to fetch.
     */
    where?: ActualRepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActualRepairs to fetch.
     */
    orderBy?: ActualRepairOrderByWithRelationInput | ActualRepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActualRepairs.
     */
    cursor?: ActualRepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActualRepairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActualRepairs.
     */
    skip?: number
    distinct?: ActualRepairScalarFieldEnum | ActualRepairScalarFieldEnum[]
  }

  /**
   * ActualRepair create
   */
  export type ActualRepairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    /**
     * The data needed to create a ActualRepair.
     */
    data: XOR<ActualRepairCreateInput, ActualRepairUncheckedCreateInput>
  }

  /**
   * ActualRepair createMany
   */
  export type ActualRepairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActualRepairs.
     */
    data: ActualRepairCreateManyInput | ActualRepairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActualRepair createManyAndReturn
   */
  export type ActualRepairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActualRepairs.
     */
    data: ActualRepairCreateManyInput | ActualRepairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActualRepair update
   */
  export type ActualRepairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    /**
     * The data needed to update a ActualRepair.
     */
    data: XOR<ActualRepairUpdateInput, ActualRepairUncheckedUpdateInput>
    /**
     * Choose, which ActualRepair to update.
     */
    where: ActualRepairWhereUniqueInput
  }

  /**
   * ActualRepair updateMany
   */
  export type ActualRepairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActualRepairs.
     */
    data: XOR<ActualRepairUpdateManyMutationInput, ActualRepairUncheckedUpdateManyInput>
    /**
     * Filter which ActualRepairs to update
     */
    where?: ActualRepairWhereInput
  }

  /**
   * ActualRepair upsert
   */
  export type ActualRepairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    /**
     * The filter to search for the ActualRepair to update in case it exists.
     */
    where: ActualRepairWhereUniqueInput
    /**
     * In case the ActualRepair found by the `where` argument doesn't exist, create a new ActualRepair with this data.
     */
    create: XOR<ActualRepairCreateInput, ActualRepairUncheckedCreateInput>
    /**
     * In case the ActualRepair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActualRepairUpdateInput, ActualRepairUncheckedUpdateInput>
  }

  /**
   * ActualRepair delete
   */
  export type ActualRepairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
    /**
     * Filter which ActualRepair to delete.
     */
    where: ActualRepairWhereUniqueInput
  }

  /**
   * ActualRepair deleteMany
   */
  export type ActualRepairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActualRepairs to delete
     */
    where?: ActualRepairWhereInput
  }

  /**
   * ActualRepair.user
   */
  export type ActualRepair$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActualRepair without action
   */
  export type ActualRepairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualRepair
     */
    select?: ActualRepairSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActualRepairInclude<ExtArgs> | null
  }


  /**
   * Model TrainingImage
   */

  export type AggregateTrainingImage = {
    _count: TrainingImageCountAggregateOutputType | null
    _min: TrainingImageMinAggregateOutputType | null
    _max: TrainingImageMaxAggregateOutputType | null
  }

  export type TrainingImageMinAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    label: string | null
    uploadedAt: Date | null
  }

  export type TrainingImageMaxAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    label: string | null
    uploadedAt: Date | null
  }

  export type TrainingImageCountAggregateOutputType = {
    id: number
    imageUrl: number
    label: number
    uploadedAt: number
    _all: number
  }


  export type TrainingImageMinAggregateInputType = {
    id?: true
    imageUrl?: true
    label?: true
    uploadedAt?: true
  }

  export type TrainingImageMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    label?: true
    uploadedAt?: true
  }

  export type TrainingImageCountAggregateInputType = {
    id?: true
    imageUrl?: true
    label?: true
    uploadedAt?: true
    _all?: true
  }

  export type TrainingImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingImage to aggregate.
     */
    where?: TrainingImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingImages to fetch.
     */
    orderBy?: TrainingImageOrderByWithRelationInput | TrainingImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingImages
    **/
    _count?: true | TrainingImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingImageMaxAggregateInputType
  }

  export type GetTrainingImageAggregateType<T extends TrainingImageAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingImage[P]>
      : GetScalarType<T[P], AggregateTrainingImage[P]>
  }




  export type TrainingImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingImageWhereInput
    orderBy?: TrainingImageOrderByWithAggregationInput | TrainingImageOrderByWithAggregationInput[]
    by: TrainingImageScalarFieldEnum[] | TrainingImageScalarFieldEnum
    having?: TrainingImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingImageCountAggregateInputType | true
    _min?: TrainingImageMinAggregateInputType
    _max?: TrainingImageMaxAggregateInputType
  }

  export type TrainingImageGroupByOutputType = {
    id: string
    imageUrl: string
    label: string | null
    uploadedAt: Date
    _count: TrainingImageCountAggregateOutputType | null
    _min: TrainingImageMinAggregateOutputType | null
    _max: TrainingImageMaxAggregateOutputType | null
  }

  type GetTrainingImageGroupByPayload<T extends TrainingImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingImageGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingImageGroupByOutputType[P]>
        }
      >
    >


  export type TrainingImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    label?: boolean
    uploadedAt?: boolean
  }, ExtArgs["result"]["trainingImage"]>

  export type TrainingImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    label?: boolean
    uploadedAt?: boolean
  }, ExtArgs["result"]["trainingImage"]>

  export type TrainingImageSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    label?: boolean
    uploadedAt?: boolean
  }


  export type $TrainingImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingImage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imageUrl: string
      label: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["trainingImage"]>
    composites: {}
  }

  type TrainingImageGetPayload<S extends boolean | null | undefined | TrainingImageDefaultArgs> = $Result.GetResult<Prisma.$TrainingImagePayload, S>

  type TrainingImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingImageCountAggregateInputType | true
    }

  export interface TrainingImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingImage'], meta: { name: 'TrainingImage' } }
    /**
     * Find zero or one TrainingImage that matches the filter.
     * @param {TrainingImageFindUniqueArgs} args - Arguments to find a TrainingImage
     * @example
     * // Get one TrainingImage
     * const trainingImage = await prisma.trainingImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingImageFindUniqueArgs>(args: SelectSubset<T, TrainingImageFindUniqueArgs<ExtArgs>>): Prisma__TrainingImageClient<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingImageFindUniqueOrThrowArgs} args - Arguments to find a TrainingImage
     * @example
     * // Get one TrainingImage
     * const trainingImage = await prisma.trainingImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingImageFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingImageClient<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingImageFindFirstArgs} args - Arguments to find a TrainingImage
     * @example
     * // Get one TrainingImage
     * const trainingImage = await prisma.trainingImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingImageFindFirstArgs>(args?: SelectSubset<T, TrainingImageFindFirstArgs<ExtArgs>>): Prisma__TrainingImageClient<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingImageFindFirstOrThrowArgs} args - Arguments to find a TrainingImage
     * @example
     * // Get one TrainingImage
     * const trainingImage = await prisma.trainingImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingImageFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingImageClient<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingImages
     * const trainingImages = await prisma.trainingImage.findMany()
     * 
     * // Get first 10 TrainingImages
     * const trainingImages = await prisma.trainingImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingImageWithIdOnly = await prisma.trainingImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingImageFindManyArgs>(args?: SelectSubset<T, TrainingImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingImage.
     * @param {TrainingImageCreateArgs} args - Arguments to create a TrainingImage.
     * @example
     * // Create one TrainingImage
     * const TrainingImage = await prisma.trainingImage.create({
     *   data: {
     *     // ... data to create a TrainingImage
     *   }
     * })
     * 
     */
    create<T extends TrainingImageCreateArgs>(args: SelectSubset<T, TrainingImageCreateArgs<ExtArgs>>): Prisma__TrainingImageClient<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingImages.
     * @param {TrainingImageCreateManyArgs} args - Arguments to create many TrainingImages.
     * @example
     * // Create many TrainingImages
     * const trainingImage = await prisma.trainingImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingImageCreateManyArgs>(args?: SelectSubset<T, TrainingImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingImages and returns the data saved in the database.
     * @param {TrainingImageCreateManyAndReturnArgs} args - Arguments to create many TrainingImages.
     * @example
     * // Create many TrainingImages
     * const trainingImage = await prisma.trainingImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingImages and only return the `id`
     * const trainingImageWithIdOnly = await prisma.trainingImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingImageCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainingImage.
     * @param {TrainingImageDeleteArgs} args - Arguments to delete one TrainingImage.
     * @example
     * // Delete one TrainingImage
     * const TrainingImage = await prisma.trainingImage.delete({
     *   where: {
     *     // ... filter to delete one TrainingImage
     *   }
     * })
     * 
     */
    delete<T extends TrainingImageDeleteArgs>(args: SelectSubset<T, TrainingImageDeleteArgs<ExtArgs>>): Prisma__TrainingImageClient<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingImage.
     * @param {TrainingImageUpdateArgs} args - Arguments to update one TrainingImage.
     * @example
     * // Update one TrainingImage
     * const trainingImage = await prisma.trainingImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingImageUpdateArgs>(args: SelectSubset<T, TrainingImageUpdateArgs<ExtArgs>>): Prisma__TrainingImageClient<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingImages.
     * @param {TrainingImageDeleteManyArgs} args - Arguments to filter TrainingImages to delete.
     * @example
     * // Delete a few TrainingImages
     * const { count } = await prisma.trainingImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingImageDeleteManyArgs>(args?: SelectSubset<T, TrainingImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingImages
     * const trainingImage = await prisma.trainingImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingImageUpdateManyArgs>(args: SelectSubset<T, TrainingImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingImage.
     * @param {TrainingImageUpsertArgs} args - Arguments to update or create a TrainingImage.
     * @example
     * // Update or create a TrainingImage
     * const trainingImage = await prisma.trainingImage.upsert({
     *   create: {
     *     // ... data to create a TrainingImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingImage we want to update
     *   }
     * })
     */
    upsert<T extends TrainingImageUpsertArgs>(args: SelectSubset<T, TrainingImageUpsertArgs<ExtArgs>>): Prisma__TrainingImageClient<$Result.GetResult<Prisma.$TrainingImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainingImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingImageCountArgs} args - Arguments to filter TrainingImages to count.
     * @example
     * // Count the number of TrainingImages
     * const count = await prisma.trainingImage.count({
     *   where: {
     *     // ... the filter for the TrainingImages we want to count
     *   }
     * })
    **/
    count<T extends TrainingImageCountArgs>(
      args?: Subset<T, TrainingImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingImageAggregateArgs>(args: Subset<T, TrainingImageAggregateArgs>): Prisma.PrismaPromise<GetTrainingImageAggregateType<T>>

    /**
     * Group by TrainingImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingImageGroupByArgs['orderBy'] }
        : { orderBy?: TrainingImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingImage model
   */
  readonly fields: TrainingImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingImage model
   */ 
  interface TrainingImageFieldRefs {
    readonly id: FieldRef<"TrainingImage", 'String'>
    readonly imageUrl: FieldRef<"TrainingImage", 'String'>
    readonly label: FieldRef<"TrainingImage", 'String'>
    readonly uploadedAt: FieldRef<"TrainingImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingImage findUnique
   */
  export type TrainingImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
    /**
     * Filter, which TrainingImage to fetch.
     */
    where: TrainingImageWhereUniqueInput
  }

  /**
   * TrainingImage findUniqueOrThrow
   */
  export type TrainingImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
    /**
     * Filter, which TrainingImage to fetch.
     */
    where: TrainingImageWhereUniqueInput
  }

  /**
   * TrainingImage findFirst
   */
  export type TrainingImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
    /**
     * Filter, which TrainingImage to fetch.
     */
    where?: TrainingImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingImages to fetch.
     */
    orderBy?: TrainingImageOrderByWithRelationInput | TrainingImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingImages.
     */
    cursor?: TrainingImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingImages.
     */
    distinct?: TrainingImageScalarFieldEnum | TrainingImageScalarFieldEnum[]
  }

  /**
   * TrainingImage findFirstOrThrow
   */
  export type TrainingImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
    /**
     * Filter, which TrainingImage to fetch.
     */
    where?: TrainingImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingImages to fetch.
     */
    orderBy?: TrainingImageOrderByWithRelationInput | TrainingImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingImages.
     */
    cursor?: TrainingImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingImages.
     */
    distinct?: TrainingImageScalarFieldEnum | TrainingImageScalarFieldEnum[]
  }

  /**
   * TrainingImage findMany
   */
  export type TrainingImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
    /**
     * Filter, which TrainingImages to fetch.
     */
    where?: TrainingImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingImages to fetch.
     */
    orderBy?: TrainingImageOrderByWithRelationInput | TrainingImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingImages.
     */
    cursor?: TrainingImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingImages.
     */
    skip?: number
    distinct?: TrainingImageScalarFieldEnum | TrainingImageScalarFieldEnum[]
  }

  /**
   * TrainingImage create
   */
  export type TrainingImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
    /**
     * The data needed to create a TrainingImage.
     */
    data: XOR<TrainingImageCreateInput, TrainingImageUncheckedCreateInput>
  }

  /**
   * TrainingImage createMany
   */
  export type TrainingImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingImages.
     */
    data: TrainingImageCreateManyInput | TrainingImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingImage createManyAndReturn
   */
  export type TrainingImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainingImages.
     */
    data: TrainingImageCreateManyInput | TrainingImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingImage update
   */
  export type TrainingImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
    /**
     * The data needed to update a TrainingImage.
     */
    data: XOR<TrainingImageUpdateInput, TrainingImageUncheckedUpdateInput>
    /**
     * Choose, which TrainingImage to update.
     */
    where: TrainingImageWhereUniqueInput
  }

  /**
   * TrainingImage updateMany
   */
  export type TrainingImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingImages.
     */
    data: XOR<TrainingImageUpdateManyMutationInput, TrainingImageUncheckedUpdateManyInput>
    /**
     * Filter which TrainingImages to update
     */
    where?: TrainingImageWhereInput
  }

  /**
   * TrainingImage upsert
   */
  export type TrainingImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
    /**
     * The filter to search for the TrainingImage to update in case it exists.
     */
    where: TrainingImageWhereUniqueInput
    /**
     * In case the TrainingImage found by the `where` argument doesn't exist, create a new TrainingImage with this data.
     */
    create: XOR<TrainingImageCreateInput, TrainingImageUncheckedCreateInput>
    /**
     * In case the TrainingImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingImageUpdateInput, TrainingImageUncheckedUpdateInput>
  }

  /**
   * TrainingImage delete
   */
  export type TrainingImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
    /**
     * Filter which TrainingImage to delete.
     */
    where: TrainingImageWhereUniqueInput
  }

  /**
   * TrainingImage deleteMany
   */
  export type TrainingImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingImages to delete
     */
    where?: TrainingImageWhereInput
  }

  /**
   * TrainingImage without action
   */
  export type TrainingImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingImage
     */
    select?: TrainingImageSelect<ExtArgs> | null
  }


  /**
   * Model VINMetadata
   */

  export type AggregateVINMetadata = {
    _count: VINMetadataCountAggregateOutputType | null
    _avg: VINMetadataAvgAggregateOutputType | null
    _sum: VINMetadataSumAggregateOutputType | null
    _min: VINMetadataMinAggregateOutputType | null
    _max: VINMetadataMaxAggregateOutputType | null
  }

  export type VINMetadataAvgAggregateOutputType = {
    year: number | null
  }

  export type VINMetadataSumAggregateOutputType = {
    year: number | null
  }

  export type VINMetadataMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    vin: string | null
    make: string | null
    model: string | null
    year: number | null
    engine: string | null
    misc: string | null
    decodedAt: Date | null
  }

  export type VINMetadataMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    vin: string | null
    make: string | null
    model: string | null
    year: number | null
    engine: string | null
    misc: string | null
    decodedAt: Date | null
  }

  export type VINMetadataCountAggregateOutputType = {
    id: number
    jobId: number
    vin: number
    make: number
    model: number
    year: number
    engine: number
    misc: number
    decodedAt: number
    _all: number
  }


  export type VINMetadataAvgAggregateInputType = {
    year?: true
  }

  export type VINMetadataSumAggregateInputType = {
    year?: true
  }

  export type VINMetadataMinAggregateInputType = {
    id?: true
    jobId?: true
    vin?: true
    make?: true
    model?: true
    year?: true
    engine?: true
    misc?: true
    decodedAt?: true
  }

  export type VINMetadataMaxAggregateInputType = {
    id?: true
    jobId?: true
    vin?: true
    make?: true
    model?: true
    year?: true
    engine?: true
    misc?: true
    decodedAt?: true
  }

  export type VINMetadataCountAggregateInputType = {
    id?: true
    jobId?: true
    vin?: true
    make?: true
    model?: true
    year?: true
    engine?: true
    misc?: true
    decodedAt?: true
    _all?: true
  }

  export type VINMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VINMetadata to aggregate.
     */
    where?: VINMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VINMetadata to fetch.
     */
    orderBy?: VINMetadataOrderByWithRelationInput | VINMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VINMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VINMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VINMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VINMetadata
    **/
    _count?: true | VINMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VINMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VINMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VINMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VINMetadataMaxAggregateInputType
  }

  export type GetVINMetadataAggregateType<T extends VINMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateVINMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVINMetadata[P]>
      : GetScalarType<T[P], AggregateVINMetadata[P]>
  }




  export type VINMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VINMetadataWhereInput
    orderBy?: VINMetadataOrderByWithAggregationInput | VINMetadataOrderByWithAggregationInput[]
    by: VINMetadataScalarFieldEnum[] | VINMetadataScalarFieldEnum
    having?: VINMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VINMetadataCountAggregateInputType | true
    _avg?: VINMetadataAvgAggregateInputType
    _sum?: VINMetadataSumAggregateInputType
    _min?: VINMetadataMinAggregateInputType
    _max?: VINMetadataMaxAggregateInputType
  }

  export type VINMetadataGroupByOutputType = {
    id: string
    jobId: string
    vin: string
    make: string | null
    model: string | null
    year: number | null
    engine: string | null
    misc: string | null
    decodedAt: Date
    _count: VINMetadataCountAggregateOutputType | null
    _avg: VINMetadataAvgAggregateOutputType | null
    _sum: VINMetadataSumAggregateOutputType | null
    _min: VINMetadataMinAggregateOutputType | null
    _max: VINMetadataMaxAggregateOutputType | null
  }

  type GetVINMetadataGroupByPayload<T extends VINMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VINMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VINMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VINMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], VINMetadataGroupByOutputType[P]>
        }
      >
    >


  export type VINMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    vin?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    engine?: boolean
    misc?: boolean
    decodedAt?: boolean
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vINMetadata"]>

  export type VINMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    vin?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    engine?: boolean
    misc?: boolean
    decodedAt?: boolean
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vINMetadata"]>

  export type VINMetadataSelectScalar = {
    id?: boolean
    jobId?: boolean
    vin?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    engine?: boolean
    misc?: boolean
    decodedAt?: boolean
  }

  export type VINMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }
  export type VINMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobReportDefaultArgs<ExtArgs>
  }

  export type $VINMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VINMetadata"
    objects: {
      job: Prisma.$JobReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      vin: string
      make: string | null
      model: string | null
      year: number | null
      engine: string | null
      misc: string | null
      decodedAt: Date
    }, ExtArgs["result"]["vINMetadata"]>
    composites: {}
  }

  type VINMetadataGetPayload<S extends boolean | null | undefined | VINMetadataDefaultArgs> = $Result.GetResult<Prisma.$VINMetadataPayload, S>

  type VINMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VINMetadataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VINMetadataCountAggregateInputType | true
    }

  export interface VINMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VINMetadata'], meta: { name: 'VINMetadata' } }
    /**
     * Find zero or one VINMetadata that matches the filter.
     * @param {VINMetadataFindUniqueArgs} args - Arguments to find a VINMetadata
     * @example
     * // Get one VINMetadata
     * const vINMetadata = await prisma.vINMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VINMetadataFindUniqueArgs>(args: SelectSubset<T, VINMetadataFindUniqueArgs<ExtArgs>>): Prisma__VINMetadataClient<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VINMetadata that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VINMetadataFindUniqueOrThrowArgs} args - Arguments to find a VINMetadata
     * @example
     * // Get one VINMetadata
     * const vINMetadata = await prisma.vINMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VINMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, VINMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VINMetadataClient<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VINMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VINMetadataFindFirstArgs} args - Arguments to find a VINMetadata
     * @example
     * // Get one VINMetadata
     * const vINMetadata = await prisma.vINMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VINMetadataFindFirstArgs>(args?: SelectSubset<T, VINMetadataFindFirstArgs<ExtArgs>>): Prisma__VINMetadataClient<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VINMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VINMetadataFindFirstOrThrowArgs} args - Arguments to find a VINMetadata
     * @example
     * // Get one VINMetadata
     * const vINMetadata = await prisma.vINMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VINMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, VINMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__VINMetadataClient<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VINMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VINMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VINMetadata
     * const vINMetadata = await prisma.vINMetadata.findMany()
     * 
     * // Get first 10 VINMetadata
     * const vINMetadata = await prisma.vINMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vINMetadataWithIdOnly = await prisma.vINMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VINMetadataFindManyArgs>(args?: SelectSubset<T, VINMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VINMetadata.
     * @param {VINMetadataCreateArgs} args - Arguments to create a VINMetadata.
     * @example
     * // Create one VINMetadata
     * const VINMetadata = await prisma.vINMetadata.create({
     *   data: {
     *     // ... data to create a VINMetadata
     *   }
     * })
     * 
     */
    create<T extends VINMetadataCreateArgs>(args: SelectSubset<T, VINMetadataCreateArgs<ExtArgs>>): Prisma__VINMetadataClient<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VINMetadata.
     * @param {VINMetadataCreateManyArgs} args - Arguments to create many VINMetadata.
     * @example
     * // Create many VINMetadata
     * const vINMetadata = await prisma.vINMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VINMetadataCreateManyArgs>(args?: SelectSubset<T, VINMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VINMetadata and returns the data saved in the database.
     * @param {VINMetadataCreateManyAndReturnArgs} args - Arguments to create many VINMetadata.
     * @example
     * // Create many VINMetadata
     * const vINMetadata = await prisma.vINMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VINMetadata and only return the `id`
     * const vINMetadataWithIdOnly = await prisma.vINMetadata.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VINMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, VINMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VINMetadata.
     * @param {VINMetadataDeleteArgs} args - Arguments to delete one VINMetadata.
     * @example
     * // Delete one VINMetadata
     * const VINMetadata = await prisma.vINMetadata.delete({
     *   where: {
     *     // ... filter to delete one VINMetadata
     *   }
     * })
     * 
     */
    delete<T extends VINMetadataDeleteArgs>(args: SelectSubset<T, VINMetadataDeleteArgs<ExtArgs>>): Prisma__VINMetadataClient<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VINMetadata.
     * @param {VINMetadataUpdateArgs} args - Arguments to update one VINMetadata.
     * @example
     * // Update one VINMetadata
     * const vINMetadata = await prisma.vINMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VINMetadataUpdateArgs>(args: SelectSubset<T, VINMetadataUpdateArgs<ExtArgs>>): Prisma__VINMetadataClient<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VINMetadata.
     * @param {VINMetadataDeleteManyArgs} args - Arguments to filter VINMetadata to delete.
     * @example
     * // Delete a few VINMetadata
     * const { count } = await prisma.vINMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VINMetadataDeleteManyArgs>(args?: SelectSubset<T, VINMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VINMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VINMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VINMetadata
     * const vINMetadata = await prisma.vINMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VINMetadataUpdateManyArgs>(args: SelectSubset<T, VINMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VINMetadata.
     * @param {VINMetadataUpsertArgs} args - Arguments to update or create a VINMetadata.
     * @example
     * // Update or create a VINMetadata
     * const vINMetadata = await prisma.vINMetadata.upsert({
     *   create: {
     *     // ... data to create a VINMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VINMetadata we want to update
     *   }
     * })
     */
    upsert<T extends VINMetadataUpsertArgs>(args: SelectSubset<T, VINMetadataUpsertArgs<ExtArgs>>): Prisma__VINMetadataClient<$Result.GetResult<Prisma.$VINMetadataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VINMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VINMetadataCountArgs} args - Arguments to filter VINMetadata to count.
     * @example
     * // Count the number of VINMetadata
     * const count = await prisma.vINMetadata.count({
     *   where: {
     *     // ... the filter for the VINMetadata we want to count
     *   }
     * })
    **/
    count<T extends VINMetadataCountArgs>(
      args?: Subset<T, VINMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VINMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VINMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VINMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VINMetadataAggregateArgs>(args: Subset<T, VINMetadataAggregateArgs>): Prisma.PrismaPromise<GetVINMetadataAggregateType<T>>

    /**
     * Group by VINMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VINMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VINMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VINMetadataGroupByArgs['orderBy'] }
        : { orderBy?: VINMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VINMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVINMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VINMetadata model
   */
  readonly fields: VINMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VINMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VINMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobReportDefaultArgs<ExtArgs>>): Prisma__JobReportClient<$Result.GetResult<Prisma.$JobReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VINMetadata model
   */ 
  interface VINMetadataFieldRefs {
    readonly id: FieldRef<"VINMetadata", 'String'>
    readonly jobId: FieldRef<"VINMetadata", 'String'>
    readonly vin: FieldRef<"VINMetadata", 'String'>
    readonly make: FieldRef<"VINMetadata", 'String'>
    readonly model: FieldRef<"VINMetadata", 'String'>
    readonly year: FieldRef<"VINMetadata", 'Int'>
    readonly engine: FieldRef<"VINMetadata", 'String'>
    readonly misc: FieldRef<"VINMetadata", 'String'>
    readonly decodedAt: FieldRef<"VINMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VINMetadata findUnique
   */
  export type VINMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VINMetadata to fetch.
     */
    where: VINMetadataWhereUniqueInput
  }

  /**
   * VINMetadata findUniqueOrThrow
   */
  export type VINMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VINMetadata to fetch.
     */
    where: VINMetadataWhereUniqueInput
  }

  /**
   * VINMetadata findFirst
   */
  export type VINMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VINMetadata to fetch.
     */
    where?: VINMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VINMetadata to fetch.
     */
    orderBy?: VINMetadataOrderByWithRelationInput | VINMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VINMetadata.
     */
    cursor?: VINMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VINMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VINMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VINMetadata.
     */
    distinct?: VINMetadataScalarFieldEnum | VINMetadataScalarFieldEnum[]
  }

  /**
   * VINMetadata findFirstOrThrow
   */
  export type VINMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VINMetadata to fetch.
     */
    where?: VINMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VINMetadata to fetch.
     */
    orderBy?: VINMetadataOrderByWithRelationInput | VINMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VINMetadata.
     */
    cursor?: VINMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VINMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VINMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VINMetadata.
     */
    distinct?: VINMetadataScalarFieldEnum | VINMetadataScalarFieldEnum[]
  }

  /**
   * VINMetadata findMany
   */
  export type VINMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    /**
     * Filter, which VINMetadata to fetch.
     */
    where?: VINMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VINMetadata to fetch.
     */
    orderBy?: VINMetadataOrderByWithRelationInput | VINMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VINMetadata.
     */
    cursor?: VINMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VINMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VINMetadata.
     */
    skip?: number
    distinct?: VINMetadataScalarFieldEnum | VINMetadataScalarFieldEnum[]
  }

  /**
   * VINMetadata create
   */
  export type VINMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a VINMetadata.
     */
    data: XOR<VINMetadataCreateInput, VINMetadataUncheckedCreateInput>
  }

  /**
   * VINMetadata createMany
   */
  export type VINMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VINMetadata.
     */
    data: VINMetadataCreateManyInput | VINMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VINMetadata createManyAndReturn
   */
  export type VINMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VINMetadata.
     */
    data: VINMetadataCreateManyInput | VINMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VINMetadata update
   */
  export type VINMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a VINMetadata.
     */
    data: XOR<VINMetadataUpdateInput, VINMetadataUncheckedUpdateInput>
    /**
     * Choose, which VINMetadata to update.
     */
    where: VINMetadataWhereUniqueInput
  }

  /**
   * VINMetadata updateMany
   */
  export type VINMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VINMetadata.
     */
    data: XOR<VINMetadataUpdateManyMutationInput, VINMetadataUncheckedUpdateManyInput>
    /**
     * Filter which VINMetadata to update
     */
    where?: VINMetadataWhereInput
  }

  /**
   * VINMetadata upsert
   */
  export type VINMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the VINMetadata to update in case it exists.
     */
    where: VINMetadataWhereUniqueInput
    /**
     * In case the VINMetadata found by the `where` argument doesn't exist, create a new VINMetadata with this data.
     */
    create: XOR<VINMetadataCreateInput, VINMetadataUncheckedCreateInput>
    /**
     * In case the VINMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VINMetadataUpdateInput, VINMetadataUncheckedUpdateInput>
  }

  /**
   * VINMetadata delete
   */
  export type VINMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
    /**
     * Filter which VINMetadata to delete.
     */
    where: VINMetadataWhereUniqueInput
  }

  /**
   * VINMetadata deleteMany
   */
  export type VINMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VINMetadata to delete
     */
    where?: VINMetadataWhereInput
  }

  /**
   * VINMetadata without action
   */
  export type VINMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VINMetadata
     */
    select?: VINMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VINMetadataInclude<ExtArgs> | null
  }


  /**
   * Model TruckSection
   */

  export type AggregateTruckSection = {
    _count: TruckSectionCountAggregateOutputType | null
    _min: TruckSectionMinAggregateOutputType | null
    _max: TruckSectionMaxAggregateOutputType | null
  }

  export type TruckSectionMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TruckSectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TruckSectionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TruckSectionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TruckSectionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TruckSectionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TruckSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TruckSection to aggregate.
     */
    where?: TruckSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckSections to fetch.
     */
    orderBy?: TruckSectionOrderByWithRelationInput | TruckSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TruckSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TruckSections
    **/
    _count?: true | TruckSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TruckSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TruckSectionMaxAggregateInputType
  }

  export type GetTruckSectionAggregateType<T extends TruckSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateTruckSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTruckSection[P]>
      : GetScalarType<T[P], AggregateTruckSection[P]>
  }




  export type TruckSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckSectionWhereInput
    orderBy?: TruckSectionOrderByWithAggregationInput | TruckSectionOrderByWithAggregationInput[]
    by: TruckSectionScalarFieldEnum[] | TruckSectionScalarFieldEnum
    having?: TruckSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TruckSectionCountAggregateInputType | true
    _min?: TruckSectionMinAggregateInputType
    _max?: TruckSectionMaxAggregateInputType
  }

  export type TruckSectionGroupByOutputType = {
    id: string
    name: string
    _count: TruckSectionCountAggregateOutputType | null
    _min: TruckSectionMinAggregateOutputType | null
    _max: TruckSectionMaxAggregateOutputType | null
  }

  type GetTruckSectionGroupByPayload<T extends TruckSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TruckSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TruckSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TruckSectionGroupByOutputType[P]>
            : GetScalarType<T[P], TruckSectionGroupByOutputType[P]>
        }
      >
    >


  export type TruckSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vehicleParts?: boolean | TruckSection$vehiclePartsArgs<ExtArgs>
    images?: boolean | TruckSection$imagesArgs<ExtArgs>
    _count?: boolean | TruckSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["truckSection"]>

  export type TruckSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["truckSection"]>

  export type TruckSectionSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TruckSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleParts?: boolean | TruckSection$vehiclePartsArgs<ExtArgs>
    images?: boolean | TruckSection$imagesArgs<ExtArgs>
    _count?: boolean | TruckSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TruckSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TruckSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TruckSection"
    objects: {
      vehicleParts: Prisma.$VehiclePartPayload<ExtArgs>[]
      images: Prisma.$ImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["truckSection"]>
    composites: {}
  }

  type TruckSectionGetPayload<S extends boolean | null | undefined | TruckSectionDefaultArgs> = $Result.GetResult<Prisma.$TruckSectionPayload, S>

  type TruckSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TruckSectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TruckSectionCountAggregateInputType | true
    }

  export interface TruckSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TruckSection'], meta: { name: 'TruckSection' } }
    /**
     * Find zero or one TruckSection that matches the filter.
     * @param {TruckSectionFindUniqueArgs} args - Arguments to find a TruckSection
     * @example
     * // Get one TruckSection
     * const truckSection = await prisma.truckSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TruckSectionFindUniqueArgs>(args: SelectSubset<T, TruckSectionFindUniqueArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TruckSection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TruckSectionFindUniqueOrThrowArgs} args - Arguments to find a TruckSection
     * @example
     * // Get one TruckSection
     * const truckSection = await prisma.truckSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TruckSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, TruckSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TruckSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckSectionFindFirstArgs} args - Arguments to find a TruckSection
     * @example
     * // Get one TruckSection
     * const truckSection = await prisma.truckSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TruckSectionFindFirstArgs>(args?: SelectSubset<T, TruckSectionFindFirstArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TruckSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckSectionFindFirstOrThrowArgs} args - Arguments to find a TruckSection
     * @example
     * // Get one TruckSection
     * const truckSection = await prisma.truckSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TruckSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, TruckSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TruckSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TruckSections
     * const truckSections = await prisma.truckSection.findMany()
     * 
     * // Get first 10 TruckSections
     * const truckSections = await prisma.truckSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const truckSectionWithIdOnly = await prisma.truckSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TruckSectionFindManyArgs>(args?: SelectSubset<T, TruckSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TruckSection.
     * @param {TruckSectionCreateArgs} args - Arguments to create a TruckSection.
     * @example
     * // Create one TruckSection
     * const TruckSection = await prisma.truckSection.create({
     *   data: {
     *     // ... data to create a TruckSection
     *   }
     * })
     * 
     */
    create<T extends TruckSectionCreateArgs>(args: SelectSubset<T, TruckSectionCreateArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TruckSections.
     * @param {TruckSectionCreateManyArgs} args - Arguments to create many TruckSections.
     * @example
     * // Create many TruckSections
     * const truckSection = await prisma.truckSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TruckSectionCreateManyArgs>(args?: SelectSubset<T, TruckSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TruckSections and returns the data saved in the database.
     * @param {TruckSectionCreateManyAndReturnArgs} args - Arguments to create many TruckSections.
     * @example
     * // Create many TruckSections
     * const truckSection = await prisma.truckSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TruckSections and only return the `id`
     * const truckSectionWithIdOnly = await prisma.truckSection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TruckSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, TruckSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TruckSection.
     * @param {TruckSectionDeleteArgs} args - Arguments to delete one TruckSection.
     * @example
     * // Delete one TruckSection
     * const TruckSection = await prisma.truckSection.delete({
     *   where: {
     *     // ... filter to delete one TruckSection
     *   }
     * })
     * 
     */
    delete<T extends TruckSectionDeleteArgs>(args: SelectSubset<T, TruckSectionDeleteArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TruckSection.
     * @param {TruckSectionUpdateArgs} args - Arguments to update one TruckSection.
     * @example
     * // Update one TruckSection
     * const truckSection = await prisma.truckSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TruckSectionUpdateArgs>(args: SelectSubset<T, TruckSectionUpdateArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TruckSections.
     * @param {TruckSectionDeleteManyArgs} args - Arguments to filter TruckSections to delete.
     * @example
     * // Delete a few TruckSections
     * const { count } = await prisma.truckSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TruckSectionDeleteManyArgs>(args?: SelectSubset<T, TruckSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TruckSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TruckSections
     * const truckSection = await prisma.truckSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TruckSectionUpdateManyArgs>(args: SelectSubset<T, TruckSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TruckSection.
     * @param {TruckSectionUpsertArgs} args - Arguments to update or create a TruckSection.
     * @example
     * // Update or create a TruckSection
     * const truckSection = await prisma.truckSection.upsert({
     *   create: {
     *     // ... data to create a TruckSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TruckSection we want to update
     *   }
     * })
     */
    upsert<T extends TruckSectionUpsertArgs>(args: SelectSubset<T, TruckSectionUpsertArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TruckSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckSectionCountArgs} args - Arguments to filter TruckSections to count.
     * @example
     * // Count the number of TruckSections
     * const count = await prisma.truckSection.count({
     *   where: {
     *     // ... the filter for the TruckSections we want to count
     *   }
     * })
    **/
    count<T extends TruckSectionCountArgs>(
      args?: Subset<T, TruckSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TruckSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TruckSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TruckSectionAggregateArgs>(args: Subset<T, TruckSectionAggregateArgs>): Prisma.PrismaPromise<GetTruckSectionAggregateType<T>>

    /**
     * Group by TruckSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TruckSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TruckSectionGroupByArgs['orderBy'] }
        : { orderBy?: TruckSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TruckSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTruckSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TruckSection model
   */
  readonly fields: TruckSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TruckSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TruckSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicleParts<T extends TruckSection$vehiclePartsArgs<ExtArgs> = {}>(args?: Subset<T, TruckSection$vehiclePartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "findMany"> | Null>
    images<T extends TruckSection$imagesArgs<ExtArgs> = {}>(args?: Subset<T, TruckSection$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TruckSection model
   */ 
  interface TruckSectionFieldRefs {
    readonly id: FieldRef<"TruckSection", 'String'>
    readonly name: FieldRef<"TruckSection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TruckSection findUnique
   */
  export type TruckSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    /**
     * Filter, which TruckSection to fetch.
     */
    where: TruckSectionWhereUniqueInput
  }

  /**
   * TruckSection findUniqueOrThrow
   */
  export type TruckSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    /**
     * Filter, which TruckSection to fetch.
     */
    where: TruckSectionWhereUniqueInput
  }

  /**
   * TruckSection findFirst
   */
  export type TruckSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    /**
     * Filter, which TruckSection to fetch.
     */
    where?: TruckSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckSections to fetch.
     */
    orderBy?: TruckSectionOrderByWithRelationInput | TruckSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TruckSections.
     */
    cursor?: TruckSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TruckSections.
     */
    distinct?: TruckSectionScalarFieldEnum | TruckSectionScalarFieldEnum[]
  }

  /**
   * TruckSection findFirstOrThrow
   */
  export type TruckSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    /**
     * Filter, which TruckSection to fetch.
     */
    where?: TruckSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckSections to fetch.
     */
    orderBy?: TruckSectionOrderByWithRelationInput | TruckSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TruckSections.
     */
    cursor?: TruckSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TruckSections.
     */
    distinct?: TruckSectionScalarFieldEnum | TruckSectionScalarFieldEnum[]
  }

  /**
   * TruckSection findMany
   */
  export type TruckSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    /**
     * Filter, which TruckSections to fetch.
     */
    where?: TruckSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckSections to fetch.
     */
    orderBy?: TruckSectionOrderByWithRelationInput | TruckSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TruckSections.
     */
    cursor?: TruckSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckSections.
     */
    skip?: number
    distinct?: TruckSectionScalarFieldEnum | TruckSectionScalarFieldEnum[]
  }

  /**
   * TruckSection create
   */
  export type TruckSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a TruckSection.
     */
    data: XOR<TruckSectionCreateInput, TruckSectionUncheckedCreateInput>
  }

  /**
   * TruckSection createMany
   */
  export type TruckSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TruckSections.
     */
    data: TruckSectionCreateManyInput | TruckSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TruckSection createManyAndReturn
   */
  export type TruckSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TruckSections.
     */
    data: TruckSectionCreateManyInput | TruckSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TruckSection update
   */
  export type TruckSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a TruckSection.
     */
    data: XOR<TruckSectionUpdateInput, TruckSectionUncheckedUpdateInput>
    /**
     * Choose, which TruckSection to update.
     */
    where: TruckSectionWhereUniqueInput
  }

  /**
   * TruckSection updateMany
   */
  export type TruckSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TruckSections.
     */
    data: XOR<TruckSectionUpdateManyMutationInput, TruckSectionUncheckedUpdateManyInput>
    /**
     * Filter which TruckSections to update
     */
    where?: TruckSectionWhereInput
  }

  /**
   * TruckSection upsert
   */
  export type TruckSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the TruckSection to update in case it exists.
     */
    where: TruckSectionWhereUniqueInput
    /**
     * In case the TruckSection found by the `where` argument doesn't exist, create a new TruckSection with this data.
     */
    create: XOR<TruckSectionCreateInput, TruckSectionUncheckedCreateInput>
    /**
     * In case the TruckSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TruckSectionUpdateInput, TruckSectionUncheckedUpdateInput>
  }

  /**
   * TruckSection delete
   */
  export type TruckSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
    /**
     * Filter which TruckSection to delete.
     */
    where: TruckSectionWhereUniqueInput
  }

  /**
   * TruckSection deleteMany
   */
  export type TruckSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TruckSections to delete
     */
    where?: TruckSectionWhereInput
  }

  /**
   * TruckSection.vehicleParts
   */
  export type TruckSection$vehiclePartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    where?: VehiclePartWhereInput
    orderBy?: VehiclePartOrderByWithRelationInput | VehiclePartOrderByWithRelationInput[]
    cursor?: VehiclePartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehiclePartScalarFieldEnum | VehiclePartScalarFieldEnum[]
  }

  /**
   * TruckSection.images
   */
  export type TruckSection$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * TruckSection without action
   */
  export type TruckSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckSection
     */
    select?: TruckSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckSectionInclude<ExtArgs> | null
  }


  /**
   * Model VehiclePart
   */

  export type AggregateVehiclePart = {
    _count: VehiclePartCountAggregateOutputType | null
    _min: VehiclePartMinAggregateOutputType | null
    _max: VehiclePartMaxAggregateOutputType | null
  }

  export type VehiclePartMinAggregateOutputType = {
    id: string | null
    name: string | null
    truckSectionId: string | null
  }

  export type VehiclePartMaxAggregateOutputType = {
    id: string | null
    name: string | null
    truckSectionId: string | null
  }

  export type VehiclePartCountAggregateOutputType = {
    id: number
    name: number
    truckSectionId: number
    _all: number
  }


  export type VehiclePartMinAggregateInputType = {
    id?: true
    name?: true
    truckSectionId?: true
  }

  export type VehiclePartMaxAggregateInputType = {
    id?: true
    name?: true
    truckSectionId?: true
  }

  export type VehiclePartCountAggregateInputType = {
    id?: true
    name?: true
    truckSectionId?: true
    _all?: true
  }

  export type VehiclePartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehiclePart to aggregate.
     */
    where?: VehiclePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleParts to fetch.
     */
    orderBy?: VehiclePartOrderByWithRelationInput | VehiclePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehiclePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleParts
    **/
    _count?: true | VehiclePartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehiclePartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehiclePartMaxAggregateInputType
  }

  export type GetVehiclePartAggregateType<T extends VehiclePartAggregateArgs> = {
        [P in keyof T & keyof AggregateVehiclePart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehiclePart[P]>
      : GetScalarType<T[P], AggregateVehiclePart[P]>
  }




  export type VehiclePartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehiclePartWhereInput
    orderBy?: VehiclePartOrderByWithAggregationInput | VehiclePartOrderByWithAggregationInput[]
    by: VehiclePartScalarFieldEnum[] | VehiclePartScalarFieldEnum
    having?: VehiclePartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehiclePartCountAggregateInputType | true
    _min?: VehiclePartMinAggregateInputType
    _max?: VehiclePartMaxAggregateInputType
  }

  export type VehiclePartGroupByOutputType = {
    id: string
    name: string
    truckSectionId: string
    _count: VehiclePartCountAggregateOutputType | null
    _min: VehiclePartMinAggregateOutputType | null
    _max: VehiclePartMaxAggregateOutputType | null
  }

  type GetVehiclePartGroupByPayload<T extends VehiclePartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehiclePartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehiclePartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehiclePartGroupByOutputType[P]>
            : GetScalarType<T[P], VehiclePartGroupByOutputType[P]>
        }
      >
    >


  export type VehiclePartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    truckSectionId?: boolean
    truckSection?: boolean | TruckSectionDefaultArgs<ExtArgs>
    images?: boolean | VehiclePart$imagesArgs<ExtArgs>
    _count?: boolean | VehiclePartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehiclePart"]>

  export type VehiclePartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    truckSectionId?: boolean
    truckSection?: boolean | TruckSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehiclePart"]>

  export type VehiclePartSelectScalar = {
    id?: boolean
    name?: boolean
    truckSectionId?: boolean
  }

  export type VehiclePartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truckSection?: boolean | TruckSectionDefaultArgs<ExtArgs>
    images?: boolean | VehiclePart$imagesArgs<ExtArgs>
    _count?: boolean | VehiclePartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehiclePartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truckSection?: boolean | TruckSectionDefaultArgs<ExtArgs>
  }

  export type $VehiclePartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehiclePart"
    objects: {
      truckSection: Prisma.$TruckSectionPayload<ExtArgs>
      images: Prisma.$ImageVehiclePartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      truckSectionId: string
    }, ExtArgs["result"]["vehiclePart"]>
    composites: {}
  }

  type VehiclePartGetPayload<S extends boolean | null | undefined | VehiclePartDefaultArgs> = $Result.GetResult<Prisma.$VehiclePartPayload, S>

  type VehiclePartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehiclePartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehiclePartCountAggregateInputType | true
    }

  export interface VehiclePartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehiclePart'], meta: { name: 'VehiclePart' } }
    /**
     * Find zero or one VehiclePart that matches the filter.
     * @param {VehiclePartFindUniqueArgs} args - Arguments to find a VehiclePart
     * @example
     * // Get one VehiclePart
     * const vehiclePart = await prisma.vehiclePart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehiclePartFindUniqueArgs>(args: SelectSubset<T, VehiclePartFindUniqueArgs<ExtArgs>>): Prisma__VehiclePartClient<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VehiclePart that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehiclePartFindUniqueOrThrowArgs} args - Arguments to find a VehiclePart
     * @example
     * // Get one VehiclePart
     * const vehiclePart = await prisma.vehiclePart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehiclePartFindUniqueOrThrowArgs>(args: SelectSubset<T, VehiclePartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehiclePartClient<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VehiclePart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclePartFindFirstArgs} args - Arguments to find a VehiclePart
     * @example
     * // Get one VehiclePart
     * const vehiclePart = await prisma.vehiclePart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehiclePartFindFirstArgs>(args?: SelectSubset<T, VehiclePartFindFirstArgs<ExtArgs>>): Prisma__VehiclePartClient<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VehiclePart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclePartFindFirstOrThrowArgs} args - Arguments to find a VehiclePart
     * @example
     * // Get one VehiclePart
     * const vehiclePart = await prisma.vehiclePart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehiclePartFindFirstOrThrowArgs>(args?: SelectSubset<T, VehiclePartFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehiclePartClient<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VehicleParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclePartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleParts
     * const vehicleParts = await prisma.vehiclePart.findMany()
     * 
     * // Get first 10 VehicleParts
     * const vehicleParts = await prisma.vehiclePart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehiclePartWithIdOnly = await prisma.vehiclePart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehiclePartFindManyArgs>(args?: SelectSubset<T, VehiclePartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VehiclePart.
     * @param {VehiclePartCreateArgs} args - Arguments to create a VehiclePart.
     * @example
     * // Create one VehiclePart
     * const VehiclePart = await prisma.vehiclePart.create({
     *   data: {
     *     // ... data to create a VehiclePart
     *   }
     * })
     * 
     */
    create<T extends VehiclePartCreateArgs>(args: SelectSubset<T, VehiclePartCreateArgs<ExtArgs>>): Prisma__VehiclePartClient<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VehicleParts.
     * @param {VehiclePartCreateManyArgs} args - Arguments to create many VehicleParts.
     * @example
     * // Create many VehicleParts
     * const vehiclePart = await prisma.vehiclePart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehiclePartCreateManyArgs>(args?: SelectSubset<T, VehiclePartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleParts and returns the data saved in the database.
     * @param {VehiclePartCreateManyAndReturnArgs} args - Arguments to create many VehicleParts.
     * @example
     * // Create many VehicleParts
     * const vehiclePart = await prisma.vehiclePart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleParts and only return the `id`
     * const vehiclePartWithIdOnly = await prisma.vehiclePart.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehiclePartCreateManyAndReturnArgs>(args?: SelectSubset<T, VehiclePartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VehiclePart.
     * @param {VehiclePartDeleteArgs} args - Arguments to delete one VehiclePart.
     * @example
     * // Delete one VehiclePart
     * const VehiclePart = await prisma.vehiclePart.delete({
     *   where: {
     *     // ... filter to delete one VehiclePart
     *   }
     * })
     * 
     */
    delete<T extends VehiclePartDeleteArgs>(args: SelectSubset<T, VehiclePartDeleteArgs<ExtArgs>>): Prisma__VehiclePartClient<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VehiclePart.
     * @param {VehiclePartUpdateArgs} args - Arguments to update one VehiclePart.
     * @example
     * // Update one VehiclePart
     * const vehiclePart = await prisma.vehiclePart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehiclePartUpdateArgs>(args: SelectSubset<T, VehiclePartUpdateArgs<ExtArgs>>): Prisma__VehiclePartClient<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VehicleParts.
     * @param {VehiclePartDeleteManyArgs} args - Arguments to filter VehicleParts to delete.
     * @example
     * // Delete a few VehicleParts
     * const { count } = await prisma.vehiclePart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehiclePartDeleteManyArgs>(args?: SelectSubset<T, VehiclePartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclePartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleParts
     * const vehiclePart = await prisma.vehiclePart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehiclePartUpdateManyArgs>(args: SelectSubset<T, VehiclePartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VehiclePart.
     * @param {VehiclePartUpsertArgs} args - Arguments to update or create a VehiclePart.
     * @example
     * // Update or create a VehiclePart
     * const vehiclePart = await prisma.vehiclePart.upsert({
     *   create: {
     *     // ... data to create a VehiclePart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehiclePart we want to update
     *   }
     * })
     */
    upsert<T extends VehiclePartUpsertArgs>(args: SelectSubset<T, VehiclePartUpsertArgs<ExtArgs>>): Prisma__VehiclePartClient<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VehicleParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclePartCountArgs} args - Arguments to filter VehicleParts to count.
     * @example
     * // Count the number of VehicleParts
     * const count = await prisma.vehiclePart.count({
     *   where: {
     *     // ... the filter for the VehicleParts we want to count
     *   }
     * })
    **/
    count<T extends VehiclePartCountArgs>(
      args?: Subset<T, VehiclePartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehiclePartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehiclePart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclePartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehiclePartAggregateArgs>(args: Subset<T, VehiclePartAggregateArgs>): Prisma.PrismaPromise<GetVehiclePartAggregateType<T>>

    /**
     * Group by VehiclePart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclePartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehiclePartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehiclePartGroupByArgs['orderBy'] }
        : { orderBy?: VehiclePartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehiclePartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehiclePartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehiclePart model
   */
  readonly fields: VehiclePartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehiclePart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehiclePartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truckSection<T extends TruckSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckSectionDefaultArgs<ExtArgs>>): Prisma__TruckSectionClient<$Result.GetResult<Prisma.$TruckSectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    images<T extends VehiclePart$imagesArgs<ExtArgs> = {}>(args?: Subset<T, VehiclePart$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehiclePart model
   */ 
  interface VehiclePartFieldRefs {
    readonly id: FieldRef<"VehiclePart", 'String'>
    readonly name: FieldRef<"VehiclePart", 'String'>
    readonly truckSectionId: FieldRef<"VehiclePart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehiclePart findUnique
   */
  export type VehiclePartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which VehiclePart to fetch.
     */
    where: VehiclePartWhereUniqueInput
  }

  /**
   * VehiclePart findUniqueOrThrow
   */
  export type VehiclePartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which VehiclePart to fetch.
     */
    where: VehiclePartWhereUniqueInput
  }

  /**
   * VehiclePart findFirst
   */
  export type VehiclePartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which VehiclePart to fetch.
     */
    where?: VehiclePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleParts to fetch.
     */
    orderBy?: VehiclePartOrderByWithRelationInput | VehiclePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleParts.
     */
    cursor?: VehiclePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleParts.
     */
    distinct?: VehiclePartScalarFieldEnum | VehiclePartScalarFieldEnum[]
  }

  /**
   * VehiclePart findFirstOrThrow
   */
  export type VehiclePartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which VehiclePart to fetch.
     */
    where?: VehiclePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleParts to fetch.
     */
    orderBy?: VehiclePartOrderByWithRelationInput | VehiclePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleParts.
     */
    cursor?: VehiclePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleParts.
     */
    distinct?: VehiclePartScalarFieldEnum | VehiclePartScalarFieldEnum[]
  }

  /**
   * VehiclePart findMany
   */
  export type VehiclePartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which VehicleParts to fetch.
     */
    where?: VehiclePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleParts to fetch.
     */
    orderBy?: VehiclePartOrderByWithRelationInput | VehiclePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleParts.
     */
    cursor?: VehiclePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleParts.
     */
    skip?: number
    distinct?: VehiclePartScalarFieldEnum | VehiclePartScalarFieldEnum[]
  }

  /**
   * VehiclePart create
   */
  export type VehiclePartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    /**
     * The data needed to create a VehiclePart.
     */
    data: XOR<VehiclePartCreateInput, VehiclePartUncheckedCreateInput>
  }

  /**
   * VehiclePart createMany
   */
  export type VehiclePartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleParts.
     */
    data: VehiclePartCreateManyInput | VehiclePartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehiclePart createManyAndReturn
   */
  export type VehiclePartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VehicleParts.
     */
    data: VehiclePartCreateManyInput | VehiclePartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehiclePart update
   */
  export type VehiclePartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    /**
     * The data needed to update a VehiclePart.
     */
    data: XOR<VehiclePartUpdateInput, VehiclePartUncheckedUpdateInput>
    /**
     * Choose, which VehiclePart to update.
     */
    where: VehiclePartWhereUniqueInput
  }

  /**
   * VehiclePart updateMany
   */
  export type VehiclePartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleParts.
     */
    data: XOR<VehiclePartUpdateManyMutationInput, VehiclePartUncheckedUpdateManyInput>
    /**
     * Filter which VehicleParts to update
     */
    where?: VehiclePartWhereInput
  }

  /**
   * VehiclePart upsert
   */
  export type VehiclePartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    /**
     * The filter to search for the VehiclePart to update in case it exists.
     */
    where: VehiclePartWhereUniqueInput
    /**
     * In case the VehiclePart found by the `where` argument doesn't exist, create a new VehiclePart with this data.
     */
    create: XOR<VehiclePartCreateInput, VehiclePartUncheckedCreateInput>
    /**
     * In case the VehiclePart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehiclePartUpdateInput, VehiclePartUncheckedUpdateInput>
  }

  /**
   * VehiclePart delete
   */
  export type VehiclePartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
    /**
     * Filter which VehiclePart to delete.
     */
    where: VehiclePartWhereUniqueInput
  }

  /**
   * VehiclePart deleteMany
   */
  export type VehiclePartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleParts to delete
     */
    where?: VehiclePartWhereInput
  }

  /**
   * VehiclePart.images
   */
  export type VehiclePart$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    where?: ImageVehiclePartWhereInput
    orderBy?: ImageVehiclePartOrderByWithRelationInput | ImageVehiclePartOrderByWithRelationInput[]
    cursor?: ImageVehiclePartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageVehiclePartScalarFieldEnum | ImageVehiclePartScalarFieldEnum[]
  }

  /**
   * VehiclePart without action
   */
  export type VehiclePartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclePart
     */
    select?: VehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiclePartInclude<ExtArgs> | null
  }


  /**
   * Model DamageType
   */

  export type AggregateDamageType = {
    _count: DamageTypeCountAggregateOutputType | null
    _min: DamageTypeMinAggregateOutputType | null
    _max: DamageTypeMaxAggregateOutputType | null
  }

  export type DamageTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DamageTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DamageTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DamageTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DamageTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DamageTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DamageTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DamageType to aggregate.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DamageTypes
    **/
    _count?: true | DamageTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DamageTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DamageTypeMaxAggregateInputType
  }

  export type GetDamageTypeAggregateType<T extends DamageTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDamageType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDamageType[P]>
      : GetScalarType<T[P], AggregateDamageType[P]>
  }




  export type DamageTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageTypeWhereInput
    orderBy?: DamageTypeOrderByWithAggregationInput | DamageTypeOrderByWithAggregationInput[]
    by: DamageTypeScalarFieldEnum[] | DamageTypeScalarFieldEnum
    having?: DamageTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DamageTypeCountAggregateInputType | true
    _min?: DamageTypeMinAggregateInputType
    _max?: DamageTypeMaxAggregateInputType
  }

  export type DamageTypeGroupByOutputType = {
    id: string
    name: string
    _count: DamageTypeCountAggregateOutputType | null
    _min: DamageTypeMinAggregateOutputType | null
    _max: DamageTypeMaxAggregateOutputType | null
  }

  type GetDamageTypeGroupByPayload<T extends DamageTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DamageTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DamageTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DamageTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DamageTypeGroupByOutputType[P]>
        }
      >
    >


  export type DamageTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    images?: boolean | DamageType$imagesArgs<ExtArgs>
    _count?: boolean | DamageTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["damageType"]>

  export type DamageTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["damageType"]>

  export type DamageTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DamageTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | DamageType$imagesArgs<ExtArgs>
    _count?: boolean | DamageTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DamageTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DamageTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DamageType"
    objects: {
      images: Prisma.$ImageDamageTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["damageType"]>
    composites: {}
  }

  type DamageTypeGetPayload<S extends boolean | null | undefined | DamageTypeDefaultArgs> = $Result.GetResult<Prisma.$DamageTypePayload, S>

  type DamageTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DamageTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DamageTypeCountAggregateInputType | true
    }

  export interface DamageTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DamageType'], meta: { name: 'DamageType' } }
    /**
     * Find zero or one DamageType that matches the filter.
     * @param {DamageTypeFindUniqueArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DamageTypeFindUniqueArgs>(args: SelectSubset<T, DamageTypeFindUniqueArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DamageType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DamageTypeFindUniqueOrThrowArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DamageTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DamageTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DamageType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeFindFirstArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DamageTypeFindFirstArgs>(args?: SelectSubset<T, DamageTypeFindFirstArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DamageType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeFindFirstOrThrowArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DamageTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DamageTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DamageTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DamageTypes
     * const damageTypes = await prisma.damageType.findMany()
     * 
     * // Get first 10 DamageTypes
     * const damageTypes = await prisma.damageType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const damageTypeWithIdOnly = await prisma.damageType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DamageTypeFindManyArgs>(args?: SelectSubset<T, DamageTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DamageType.
     * @param {DamageTypeCreateArgs} args - Arguments to create a DamageType.
     * @example
     * // Create one DamageType
     * const DamageType = await prisma.damageType.create({
     *   data: {
     *     // ... data to create a DamageType
     *   }
     * })
     * 
     */
    create<T extends DamageTypeCreateArgs>(args: SelectSubset<T, DamageTypeCreateArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DamageTypes.
     * @param {DamageTypeCreateManyArgs} args - Arguments to create many DamageTypes.
     * @example
     * // Create many DamageTypes
     * const damageType = await prisma.damageType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DamageTypeCreateManyArgs>(args?: SelectSubset<T, DamageTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DamageTypes and returns the data saved in the database.
     * @param {DamageTypeCreateManyAndReturnArgs} args - Arguments to create many DamageTypes.
     * @example
     * // Create many DamageTypes
     * const damageType = await prisma.damageType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DamageTypes and only return the `id`
     * const damageTypeWithIdOnly = await prisma.damageType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DamageTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, DamageTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DamageType.
     * @param {DamageTypeDeleteArgs} args - Arguments to delete one DamageType.
     * @example
     * // Delete one DamageType
     * const DamageType = await prisma.damageType.delete({
     *   where: {
     *     // ... filter to delete one DamageType
     *   }
     * })
     * 
     */
    delete<T extends DamageTypeDeleteArgs>(args: SelectSubset<T, DamageTypeDeleteArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DamageType.
     * @param {DamageTypeUpdateArgs} args - Arguments to update one DamageType.
     * @example
     * // Update one DamageType
     * const damageType = await prisma.damageType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DamageTypeUpdateArgs>(args: SelectSubset<T, DamageTypeUpdateArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DamageTypes.
     * @param {DamageTypeDeleteManyArgs} args - Arguments to filter DamageTypes to delete.
     * @example
     * // Delete a few DamageTypes
     * const { count } = await prisma.damageType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DamageTypeDeleteManyArgs>(args?: SelectSubset<T, DamageTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DamageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DamageTypes
     * const damageType = await prisma.damageType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DamageTypeUpdateManyArgs>(args: SelectSubset<T, DamageTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DamageType.
     * @param {DamageTypeUpsertArgs} args - Arguments to update or create a DamageType.
     * @example
     * // Update or create a DamageType
     * const damageType = await prisma.damageType.upsert({
     *   create: {
     *     // ... data to create a DamageType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DamageType we want to update
     *   }
     * })
     */
    upsert<T extends DamageTypeUpsertArgs>(args: SelectSubset<T, DamageTypeUpsertArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DamageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeCountArgs} args - Arguments to filter DamageTypes to count.
     * @example
     * // Count the number of DamageTypes
     * const count = await prisma.damageType.count({
     *   where: {
     *     // ... the filter for the DamageTypes we want to count
     *   }
     * })
    **/
    count<T extends DamageTypeCountArgs>(
      args?: Subset<T, DamageTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DamageTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DamageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DamageTypeAggregateArgs>(args: Subset<T, DamageTypeAggregateArgs>): Prisma.PrismaPromise<GetDamageTypeAggregateType<T>>

    /**
     * Group by DamageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DamageTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DamageTypeGroupByArgs['orderBy'] }
        : { orderBy?: DamageTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DamageTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDamageTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DamageType model
   */
  readonly fields: DamageTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DamageType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DamageTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends DamageType$imagesArgs<ExtArgs> = {}>(args?: Subset<T, DamageType$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DamageType model
   */ 
  interface DamageTypeFieldRefs {
    readonly id: FieldRef<"DamageType", 'String'>
    readonly name: FieldRef<"DamageType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DamageType findUnique
   */
  export type DamageTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType findUniqueOrThrow
   */
  export type DamageTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType findFirst
   */
  export type DamageTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageTypes.
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageTypes.
     */
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType findFirstOrThrow
   */
  export type DamageTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageTypes.
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageTypes.
     */
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType findMany
   */
  export type DamageTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageTypes to fetch.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DamageTypes.
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType create
   */
  export type DamageTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DamageType.
     */
    data: XOR<DamageTypeCreateInput, DamageTypeUncheckedCreateInput>
  }

  /**
   * DamageType createMany
   */
  export type DamageTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DamageTypes.
     */
    data: DamageTypeCreateManyInput | DamageTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DamageType createManyAndReturn
   */
  export type DamageTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DamageTypes.
     */
    data: DamageTypeCreateManyInput | DamageTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DamageType update
   */
  export type DamageTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DamageType.
     */
    data: XOR<DamageTypeUpdateInput, DamageTypeUncheckedUpdateInput>
    /**
     * Choose, which DamageType to update.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType updateMany
   */
  export type DamageTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DamageTypes.
     */
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyInput>
    /**
     * Filter which DamageTypes to update
     */
    where?: DamageTypeWhereInput
  }

  /**
   * DamageType upsert
   */
  export type DamageTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DamageType to update in case it exists.
     */
    where: DamageTypeWhereUniqueInput
    /**
     * In case the DamageType found by the `where` argument doesn't exist, create a new DamageType with this data.
     */
    create: XOR<DamageTypeCreateInput, DamageTypeUncheckedCreateInput>
    /**
     * In case the DamageType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DamageTypeUpdateInput, DamageTypeUncheckedUpdateInput>
  }

  /**
   * DamageType delete
   */
  export type DamageTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter which DamageType to delete.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType deleteMany
   */
  export type DamageTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DamageTypes to delete
     */
    where?: DamageTypeWhereInput
  }

  /**
   * DamageType.images
   */
  export type DamageType$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    where?: ImageDamageTypeWhereInput
    orderBy?: ImageDamageTypeOrderByWithRelationInput | ImageDamageTypeOrderByWithRelationInput[]
    cursor?: ImageDamageTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageDamageTypeScalarFieldEnum | ImageDamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType without action
   */
  export type DamageTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
  }


  /**
   * Model SeverityLevel
   */

  export type AggregateSeverityLevel = {
    _count: SeverityLevelCountAggregateOutputType | null
    _min: SeverityLevelMinAggregateOutputType | null
    _max: SeverityLevelMaxAggregateOutputType | null
  }

  export type SeverityLevelMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SeverityLevelMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SeverityLevelCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type SeverityLevelMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SeverityLevelMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SeverityLevelCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SeverityLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeverityLevel to aggregate.
     */
    where?: SeverityLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeverityLevels to fetch.
     */
    orderBy?: SeverityLevelOrderByWithRelationInput | SeverityLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeverityLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeverityLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeverityLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeverityLevels
    **/
    _count?: true | SeverityLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeverityLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeverityLevelMaxAggregateInputType
  }

  export type GetSeverityLevelAggregateType<T extends SeverityLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateSeverityLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeverityLevel[P]>
      : GetScalarType<T[P], AggregateSeverityLevel[P]>
  }




  export type SeverityLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeverityLevelWhereInput
    orderBy?: SeverityLevelOrderByWithAggregationInput | SeverityLevelOrderByWithAggregationInput[]
    by: SeverityLevelScalarFieldEnum[] | SeverityLevelScalarFieldEnum
    having?: SeverityLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeverityLevelCountAggregateInputType | true
    _min?: SeverityLevelMinAggregateInputType
    _max?: SeverityLevelMaxAggregateInputType
  }

  export type SeverityLevelGroupByOutputType = {
    id: string
    name: string
    _count: SeverityLevelCountAggregateOutputType | null
    _min: SeverityLevelMinAggregateOutputType | null
    _max: SeverityLevelMaxAggregateOutputType | null
  }

  type GetSeverityLevelGroupByPayload<T extends SeverityLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeverityLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeverityLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeverityLevelGroupByOutputType[P]>
            : GetScalarType<T[P], SeverityLevelGroupByOutputType[P]>
        }
      >
    >


  export type SeverityLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    images?: boolean | SeverityLevel$imagesArgs<ExtArgs>
    _count?: boolean | SeverityLevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["severityLevel"]>

  export type SeverityLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["severityLevel"]>

  export type SeverityLevelSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type SeverityLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | SeverityLevel$imagesArgs<ExtArgs>
    _count?: boolean | SeverityLevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeverityLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SeverityLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeverityLevel"
    objects: {
      images: Prisma.$ImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["severityLevel"]>
    composites: {}
  }

  type SeverityLevelGetPayload<S extends boolean | null | undefined | SeverityLevelDefaultArgs> = $Result.GetResult<Prisma.$SeverityLevelPayload, S>

  type SeverityLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeverityLevelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeverityLevelCountAggregateInputType | true
    }

  export interface SeverityLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeverityLevel'], meta: { name: 'SeverityLevel' } }
    /**
     * Find zero or one SeverityLevel that matches the filter.
     * @param {SeverityLevelFindUniqueArgs} args - Arguments to find a SeverityLevel
     * @example
     * // Get one SeverityLevel
     * const severityLevel = await prisma.severityLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeverityLevelFindUniqueArgs>(args: SelectSubset<T, SeverityLevelFindUniqueArgs<ExtArgs>>): Prisma__SeverityLevelClient<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeverityLevel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeverityLevelFindUniqueOrThrowArgs} args - Arguments to find a SeverityLevel
     * @example
     * // Get one SeverityLevel
     * const severityLevel = await prisma.severityLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeverityLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, SeverityLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeverityLevelClient<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeverityLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelFindFirstArgs} args - Arguments to find a SeverityLevel
     * @example
     * // Get one SeverityLevel
     * const severityLevel = await prisma.severityLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeverityLevelFindFirstArgs>(args?: SelectSubset<T, SeverityLevelFindFirstArgs<ExtArgs>>): Prisma__SeverityLevelClient<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeverityLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelFindFirstOrThrowArgs} args - Arguments to find a SeverityLevel
     * @example
     * // Get one SeverityLevel
     * const severityLevel = await prisma.severityLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeverityLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, SeverityLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeverityLevelClient<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeverityLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeverityLevels
     * const severityLevels = await prisma.severityLevel.findMany()
     * 
     * // Get first 10 SeverityLevels
     * const severityLevels = await prisma.severityLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const severityLevelWithIdOnly = await prisma.severityLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeverityLevelFindManyArgs>(args?: SelectSubset<T, SeverityLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeverityLevel.
     * @param {SeverityLevelCreateArgs} args - Arguments to create a SeverityLevel.
     * @example
     * // Create one SeverityLevel
     * const SeverityLevel = await prisma.severityLevel.create({
     *   data: {
     *     // ... data to create a SeverityLevel
     *   }
     * })
     * 
     */
    create<T extends SeverityLevelCreateArgs>(args: SelectSubset<T, SeverityLevelCreateArgs<ExtArgs>>): Prisma__SeverityLevelClient<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeverityLevels.
     * @param {SeverityLevelCreateManyArgs} args - Arguments to create many SeverityLevels.
     * @example
     * // Create many SeverityLevels
     * const severityLevel = await prisma.severityLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeverityLevelCreateManyArgs>(args?: SelectSubset<T, SeverityLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeverityLevels and returns the data saved in the database.
     * @param {SeverityLevelCreateManyAndReturnArgs} args - Arguments to create many SeverityLevels.
     * @example
     * // Create many SeverityLevels
     * const severityLevel = await prisma.severityLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeverityLevels and only return the `id`
     * const severityLevelWithIdOnly = await prisma.severityLevel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeverityLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, SeverityLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeverityLevel.
     * @param {SeverityLevelDeleteArgs} args - Arguments to delete one SeverityLevel.
     * @example
     * // Delete one SeverityLevel
     * const SeverityLevel = await prisma.severityLevel.delete({
     *   where: {
     *     // ... filter to delete one SeverityLevel
     *   }
     * })
     * 
     */
    delete<T extends SeverityLevelDeleteArgs>(args: SelectSubset<T, SeverityLevelDeleteArgs<ExtArgs>>): Prisma__SeverityLevelClient<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeverityLevel.
     * @param {SeverityLevelUpdateArgs} args - Arguments to update one SeverityLevel.
     * @example
     * // Update one SeverityLevel
     * const severityLevel = await prisma.severityLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeverityLevelUpdateArgs>(args: SelectSubset<T, SeverityLevelUpdateArgs<ExtArgs>>): Prisma__SeverityLevelClient<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeverityLevels.
     * @param {SeverityLevelDeleteManyArgs} args - Arguments to filter SeverityLevels to delete.
     * @example
     * // Delete a few SeverityLevels
     * const { count } = await prisma.severityLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeverityLevelDeleteManyArgs>(args?: SelectSubset<T, SeverityLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeverityLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeverityLevels
     * const severityLevel = await prisma.severityLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeverityLevelUpdateManyArgs>(args: SelectSubset<T, SeverityLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeverityLevel.
     * @param {SeverityLevelUpsertArgs} args - Arguments to update or create a SeverityLevel.
     * @example
     * // Update or create a SeverityLevel
     * const severityLevel = await prisma.severityLevel.upsert({
     *   create: {
     *     // ... data to create a SeverityLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeverityLevel we want to update
     *   }
     * })
     */
    upsert<T extends SeverityLevelUpsertArgs>(args: SelectSubset<T, SeverityLevelUpsertArgs<ExtArgs>>): Prisma__SeverityLevelClient<$Result.GetResult<Prisma.$SeverityLevelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeverityLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelCountArgs} args - Arguments to filter SeverityLevels to count.
     * @example
     * // Count the number of SeverityLevels
     * const count = await prisma.severityLevel.count({
     *   where: {
     *     // ... the filter for the SeverityLevels we want to count
     *   }
     * })
    **/
    count<T extends SeverityLevelCountArgs>(
      args?: Subset<T, SeverityLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeverityLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeverityLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeverityLevelAggregateArgs>(args: Subset<T, SeverityLevelAggregateArgs>): Prisma.PrismaPromise<GetSeverityLevelAggregateType<T>>

    /**
     * Group by SeverityLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeverityLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeverityLevelGroupByArgs['orderBy'] }
        : { orderBy?: SeverityLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeverityLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeverityLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeverityLevel model
   */
  readonly fields: SeverityLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeverityLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeverityLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends SeverityLevel$imagesArgs<ExtArgs> = {}>(args?: Subset<T, SeverityLevel$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeverityLevel model
   */ 
  interface SeverityLevelFieldRefs {
    readonly id: FieldRef<"SeverityLevel", 'String'>
    readonly name: FieldRef<"SeverityLevel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SeverityLevel findUnique
   */
  export type SeverityLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    /**
     * Filter, which SeverityLevel to fetch.
     */
    where: SeverityLevelWhereUniqueInput
  }

  /**
   * SeverityLevel findUniqueOrThrow
   */
  export type SeverityLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    /**
     * Filter, which SeverityLevel to fetch.
     */
    where: SeverityLevelWhereUniqueInput
  }

  /**
   * SeverityLevel findFirst
   */
  export type SeverityLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    /**
     * Filter, which SeverityLevel to fetch.
     */
    where?: SeverityLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeverityLevels to fetch.
     */
    orderBy?: SeverityLevelOrderByWithRelationInput | SeverityLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeverityLevels.
     */
    cursor?: SeverityLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeverityLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeverityLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeverityLevels.
     */
    distinct?: SeverityLevelScalarFieldEnum | SeverityLevelScalarFieldEnum[]
  }

  /**
   * SeverityLevel findFirstOrThrow
   */
  export type SeverityLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    /**
     * Filter, which SeverityLevel to fetch.
     */
    where?: SeverityLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeverityLevels to fetch.
     */
    orderBy?: SeverityLevelOrderByWithRelationInput | SeverityLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeverityLevels.
     */
    cursor?: SeverityLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeverityLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeverityLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeverityLevels.
     */
    distinct?: SeverityLevelScalarFieldEnum | SeverityLevelScalarFieldEnum[]
  }

  /**
   * SeverityLevel findMany
   */
  export type SeverityLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    /**
     * Filter, which SeverityLevels to fetch.
     */
    where?: SeverityLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeverityLevels to fetch.
     */
    orderBy?: SeverityLevelOrderByWithRelationInput | SeverityLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeverityLevels.
     */
    cursor?: SeverityLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeverityLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeverityLevels.
     */
    skip?: number
    distinct?: SeverityLevelScalarFieldEnum | SeverityLevelScalarFieldEnum[]
  }

  /**
   * SeverityLevel create
   */
  export type SeverityLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a SeverityLevel.
     */
    data: XOR<SeverityLevelCreateInput, SeverityLevelUncheckedCreateInput>
  }

  /**
   * SeverityLevel createMany
   */
  export type SeverityLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeverityLevels.
     */
    data: SeverityLevelCreateManyInput | SeverityLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeverityLevel createManyAndReturn
   */
  export type SeverityLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeverityLevels.
     */
    data: SeverityLevelCreateManyInput | SeverityLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeverityLevel update
   */
  export type SeverityLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a SeverityLevel.
     */
    data: XOR<SeverityLevelUpdateInput, SeverityLevelUncheckedUpdateInput>
    /**
     * Choose, which SeverityLevel to update.
     */
    where: SeverityLevelWhereUniqueInput
  }

  /**
   * SeverityLevel updateMany
   */
  export type SeverityLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeverityLevels.
     */
    data: XOR<SeverityLevelUpdateManyMutationInput, SeverityLevelUncheckedUpdateManyInput>
    /**
     * Filter which SeverityLevels to update
     */
    where?: SeverityLevelWhereInput
  }

  /**
   * SeverityLevel upsert
   */
  export type SeverityLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the SeverityLevel to update in case it exists.
     */
    where: SeverityLevelWhereUniqueInput
    /**
     * In case the SeverityLevel found by the `where` argument doesn't exist, create a new SeverityLevel with this data.
     */
    create: XOR<SeverityLevelCreateInput, SeverityLevelUncheckedCreateInput>
    /**
     * In case the SeverityLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeverityLevelUpdateInput, SeverityLevelUncheckedUpdateInput>
  }

  /**
   * SeverityLevel delete
   */
  export type SeverityLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
    /**
     * Filter which SeverityLevel to delete.
     */
    where: SeverityLevelWhereUniqueInput
  }

  /**
   * SeverityLevel deleteMany
   */
  export type SeverityLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeverityLevels to delete
     */
    where?: SeverityLevelWhereInput
  }

  /**
   * SeverityLevel.images
   */
  export type SeverityLevel$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * SeverityLevel without action
   */
  export type SeverityLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityLevelInclude<ExtArgs> | null
  }


  /**
   * Model ImageVehiclePart
   */

  export type AggregateImageVehiclePart = {
    _count: ImageVehiclePartCountAggregateOutputType | null
    _min: ImageVehiclePartMinAggregateOutputType | null
    _max: ImageVehiclePartMaxAggregateOutputType | null
  }

  export type ImageVehiclePartMinAggregateOutputType = {
    imageId: string | null
    vehiclePartId: string | null
  }

  export type ImageVehiclePartMaxAggregateOutputType = {
    imageId: string | null
    vehiclePartId: string | null
  }

  export type ImageVehiclePartCountAggregateOutputType = {
    imageId: number
    vehiclePartId: number
    _all: number
  }


  export type ImageVehiclePartMinAggregateInputType = {
    imageId?: true
    vehiclePartId?: true
  }

  export type ImageVehiclePartMaxAggregateInputType = {
    imageId?: true
    vehiclePartId?: true
  }

  export type ImageVehiclePartCountAggregateInputType = {
    imageId?: true
    vehiclePartId?: true
    _all?: true
  }

  export type ImageVehiclePartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageVehiclePart to aggregate.
     */
    where?: ImageVehiclePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageVehicleParts to fetch.
     */
    orderBy?: ImageVehiclePartOrderByWithRelationInput | ImageVehiclePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageVehiclePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageVehicleParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageVehicleParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageVehicleParts
    **/
    _count?: true | ImageVehiclePartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageVehiclePartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageVehiclePartMaxAggregateInputType
  }

  export type GetImageVehiclePartAggregateType<T extends ImageVehiclePartAggregateArgs> = {
        [P in keyof T & keyof AggregateImageVehiclePart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageVehiclePart[P]>
      : GetScalarType<T[P], AggregateImageVehiclePart[P]>
  }




  export type ImageVehiclePartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageVehiclePartWhereInput
    orderBy?: ImageVehiclePartOrderByWithAggregationInput | ImageVehiclePartOrderByWithAggregationInput[]
    by: ImageVehiclePartScalarFieldEnum[] | ImageVehiclePartScalarFieldEnum
    having?: ImageVehiclePartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageVehiclePartCountAggregateInputType | true
    _min?: ImageVehiclePartMinAggregateInputType
    _max?: ImageVehiclePartMaxAggregateInputType
  }

  export type ImageVehiclePartGroupByOutputType = {
    imageId: string
    vehiclePartId: string
    _count: ImageVehiclePartCountAggregateOutputType | null
    _min: ImageVehiclePartMinAggregateOutputType | null
    _max: ImageVehiclePartMaxAggregateOutputType | null
  }

  type GetImageVehiclePartGroupByPayload<T extends ImageVehiclePartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageVehiclePartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageVehiclePartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageVehiclePartGroupByOutputType[P]>
            : GetScalarType<T[P], ImageVehiclePartGroupByOutputType[P]>
        }
      >
    >


  export type ImageVehiclePartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    imageId?: boolean
    vehiclePartId?: boolean
    image?: boolean | ImageDefaultArgs<ExtArgs>
    vehiclePart?: boolean | VehiclePartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageVehiclePart"]>

  export type ImageVehiclePartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    imageId?: boolean
    vehiclePartId?: boolean
    image?: boolean | ImageDefaultArgs<ExtArgs>
    vehiclePart?: boolean | VehiclePartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageVehiclePart"]>

  export type ImageVehiclePartSelectScalar = {
    imageId?: boolean
    vehiclePartId?: boolean
  }

  export type ImageVehiclePartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | ImageDefaultArgs<ExtArgs>
    vehiclePart?: boolean | VehiclePartDefaultArgs<ExtArgs>
  }
  export type ImageVehiclePartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | ImageDefaultArgs<ExtArgs>
    vehiclePart?: boolean | VehiclePartDefaultArgs<ExtArgs>
  }

  export type $ImageVehiclePartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImageVehiclePart"
    objects: {
      image: Prisma.$ImagePayload<ExtArgs>
      vehiclePart: Prisma.$VehiclePartPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      imageId: string
      vehiclePartId: string
    }, ExtArgs["result"]["imageVehiclePart"]>
    composites: {}
  }

  type ImageVehiclePartGetPayload<S extends boolean | null | undefined | ImageVehiclePartDefaultArgs> = $Result.GetResult<Prisma.$ImageVehiclePartPayload, S>

  type ImageVehiclePartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImageVehiclePartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImageVehiclePartCountAggregateInputType | true
    }

  export interface ImageVehiclePartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImageVehiclePart'], meta: { name: 'ImageVehiclePart' } }
    /**
     * Find zero or one ImageVehiclePart that matches the filter.
     * @param {ImageVehiclePartFindUniqueArgs} args - Arguments to find a ImageVehiclePart
     * @example
     * // Get one ImageVehiclePart
     * const imageVehiclePart = await prisma.imageVehiclePart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageVehiclePartFindUniqueArgs>(args: SelectSubset<T, ImageVehiclePartFindUniqueArgs<ExtArgs>>): Prisma__ImageVehiclePartClient<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImageVehiclePart that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImageVehiclePartFindUniqueOrThrowArgs} args - Arguments to find a ImageVehiclePart
     * @example
     * // Get one ImageVehiclePart
     * const imageVehiclePart = await prisma.imageVehiclePart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageVehiclePartFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageVehiclePartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageVehiclePartClient<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImageVehiclePart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVehiclePartFindFirstArgs} args - Arguments to find a ImageVehiclePart
     * @example
     * // Get one ImageVehiclePart
     * const imageVehiclePart = await prisma.imageVehiclePart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageVehiclePartFindFirstArgs>(args?: SelectSubset<T, ImageVehiclePartFindFirstArgs<ExtArgs>>): Prisma__ImageVehiclePartClient<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImageVehiclePart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVehiclePartFindFirstOrThrowArgs} args - Arguments to find a ImageVehiclePart
     * @example
     * // Get one ImageVehiclePart
     * const imageVehiclePart = await prisma.imageVehiclePart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageVehiclePartFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageVehiclePartFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageVehiclePartClient<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImageVehicleParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVehiclePartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageVehicleParts
     * const imageVehicleParts = await prisma.imageVehiclePart.findMany()
     * 
     * // Get first 10 ImageVehicleParts
     * const imageVehicleParts = await prisma.imageVehiclePart.findMany({ take: 10 })
     * 
     * // Only select the `imageId`
     * const imageVehiclePartWithImageIdOnly = await prisma.imageVehiclePart.findMany({ select: { imageId: true } })
     * 
     */
    findMany<T extends ImageVehiclePartFindManyArgs>(args?: SelectSubset<T, ImageVehiclePartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImageVehiclePart.
     * @param {ImageVehiclePartCreateArgs} args - Arguments to create a ImageVehiclePart.
     * @example
     * // Create one ImageVehiclePart
     * const ImageVehiclePart = await prisma.imageVehiclePart.create({
     *   data: {
     *     // ... data to create a ImageVehiclePart
     *   }
     * })
     * 
     */
    create<T extends ImageVehiclePartCreateArgs>(args: SelectSubset<T, ImageVehiclePartCreateArgs<ExtArgs>>): Prisma__ImageVehiclePartClient<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImageVehicleParts.
     * @param {ImageVehiclePartCreateManyArgs} args - Arguments to create many ImageVehicleParts.
     * @example
     * // Create many ImageVehicleParts
     * const imageVehiclePart = await prisma.imageVehiclePart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageVehiclePartCreateManyArgs>(args?: SelectSubset<T, ImageVehiclePartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImageVehicleParts and returns the data saved in the database.
     * @param {ImageVehiclePartCreateManyAndReturnArgs} args - Arguments to create many ImageVehicleParts.
     * @example
     * // Create many ImageVehicleParts
     * const imageVehiclePart = await prisma.imageVehiclePart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImageVehicleParts and only return the `imageId`
     * const imageVehiclePartWithImageIdOnly = await prisma.imageVehiclePart.createManyAndReturn({ 
     *   select: { imageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageVehiclePartCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageVehiclePartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImageVehiclePart.
     * @param {ImageVehiclePartDeleteArgs} args - Arguments to delete one ImageVehiclePart.
     * @example
     * // Delete one ImageVehiclePart
     * const ImageVehiclePart = await prisma.imageVehiclePart.delete({
     *   where: {
     *     // ... filter to delete one ImageVehiclePart
     *   }
     * })
     * 
     */
    delete<T extends ImageVehiclePartDeleteArgs>(args: SelectSubset<T, ImageVehiclePartDeleteArgs<ExtArgs>>): Prisma__ImageVehiclePartClient<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImageVehiclePart.
     * @param {ImageVehiclePartUpdateArgs} args - Arguments to update one ImageVehiclePart.
     * @example
     * // Update one ImageVehiclePart
     * const imageVehiclePart = await prisma.imageVehiclePart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageVehiclePartUpdateArgs>(args: SelectSubset<T, ImageVehiclePartUpdateArgs<ExtArgs>>): Prisma__ImageVehiclePartClient<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImageVehicleParts.
     * @param {ImageVehiclePartDeleteManyArgs} args - Arguments to filter ImageVehicleParts to delete.
     * @example
     * // Delete a few ImageVehicleParts
     * const { count } = await prisma.imageVehiclePart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageVehiclePartDeleteManyArgs>(args?: SelectSubset<T, ImageVehiclePartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageVehicleParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVehiclePartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageVehicleParts
     * const imageVehiclePart = await prisma.imageVehiclePart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageVehiclePartUpdateManyArgs>(args: SelectSubset<T, ImageVehiclePartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageVehiclePart.
     * @param {ImageVehiclePartUpsertArgs} args - Arguments to update or create a ImageVehiclePart.
     * @example
     * // Update or create a ImageVehiclePart
     * const imageVehiclePart = await prisma.imageVehiclePart.upsert({
     *   create: {
     *     // ... data to create a ImageVehiclePart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageVehiclePart we want to update
     *   }
     * })
     */
    upsert<T extends ImageVehiclePartUpsertArgs>(args: SelectSubset<T, ImageVehiclePartUpsertArgs<ExtArgs>>): Prisma__ImageVehiclePartClient<$Result.GetResult<Prisma.$ImageVehiclePartPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImageVehicleParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVehiclePartCountArgs} args - Arguments to filter ImageVehicleParts to count.
     * @example
     * // Count the number of ImageVehicleParts
     * const count = await prisma.imageVehiclePart.count({
     *   where: {
     *     // ... the filter for the ImageVehicleParts we want to count
     *   }
     * })
    **/
    count<T extends ImageVehiclePartCountArgs>(
      args?: Subset<T, ImageVehiclePartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageVehiclePartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageVehiclePart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVehiclePartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageVehiclePartAggregateArgs>(args: Subset<T, ImageVehiclePartAggregateArgs>): Prisma.PrismaPromise<GetImageVehiclePartAggregateType<T>>

    /**
     * Group by ImageVehiclePart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageVehiclePartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageVehiclePartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageVehiclePartGroupByArgs['orderBy'] }
        : { orderBy?: ImageVehiclePartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageVehiclePartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageVehiclePartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImageVehiclePart model
   */
  readonly fields: ImageVehiclePartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageVehiclePart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageVehiclePartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    image<T extends ImageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImageDefaultArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehiclePart<T extends VehiclePartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehiclePartDefaultArgs<ExtArgs>>): Prisma__VehiclePartClient<$Result.GetResult<Prisma.$VehiclePartPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImageVehiclePart model
   */ 
  interface ImageVehiclePartFieldRefs {
    readonly imageId: FieldRef<"ImageVehiclePart", 'String'>
    readonly vehiclePartId: FieldRef<"ImageVehiclePart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImageVehiclePart findUnique
   */
  export type ImageVehiclePartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which ImageVehiclePart to fetch.
     */
    where: ImageVehiclePartWhereUniqueInput
  }

  /**
   * ImageVehiclePart findUniqueOrThrow
   */
  export type ImageVehiclePartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which ImageVehiclePart to fetch.
     */
    where: ImageVehiclePartWhereUniqueInput
  }

  /**
   * ImageVehiclePart findFirst
   */
  export type ImageVehiclePartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which ImageVehiclePart to fetch.
     */
    where?: ImageVehiclePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageVehicleParts to fetch.
     */
    orderBy?: ImageVehiclePartOrderByWithRelationInput | ImageVehiclePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageVehicleParts.
     */
    cursor?: ImageVehiclePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageVehicleParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageVehicleParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageVehicleParts.
     */
    distinct?: ImageVehiclePartScalarFieldEnum | ImageVehiclePartScalarFieldEnum[]
  }

  /**
   * ImageVehiclePart findFirstOrThrow
   */
  export type ImageVehiclePartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which ImageVehiclePart to fetch.
     */
    where?: ImageVehiclePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageVehicleParts to fetch.
     */
    orderBy?: ImageVehiclePartOrderByWithRelationInput | ImageVehiclePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageVehicleParts.
     */
    cursor?: ImageVehiclePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageVehicleParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageVehicleParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageVehicleParts.
     */
    distinct?: ImageVehiclePartScalarFieldEnum | ImageVehiclePartScalarFieldEnum[]
  }

  /**
   * ImageVehiclePart findMany
   */
  export type ImageVehiclePartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    /**
     * Filter, which ImageVehicleParts to fetch.
     */
    where?: ImageVehiclePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageVehicleParts to fetch.
     */
    orderBy?: ImageVehiclePartOrderByWithRelationInput | ImageVehiclePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageVehicleParts.
     */
    cursor?: ImageVehiclePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageVehicleParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageVehicleParts.
     */
    skip?: number
    distinct?: ImageVehiclePartScalarFieldEnum | ImageVehiclePartScalarFieldEnum[]
  }

  /**
   * ImageVehiclePart create
   */
  export type ImageVehiclePartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    /**
     * The data needed to create a ImageVehiclePart.
     */
    data: XOR<ImageVehiclePartCreateInput, ImageVehiclePartUncheckedCreateInput>
  }

  /**
   * ImageVehiclePart createMany
   */
  export type ImageVehiclePartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImageVehicleParts.
     */
    data: ImageVehiclePartCreateManyInput | ImageVehiclePartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImageVehiclePart createManyAndReturn
   */
  export type ImageVehiclePartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImageVehicleParts.
     */
    data: ImageVehiclePartCreateManyInput | ImageVehiclePartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImageVehiclePart update
   */
  export type ImageVehiclePartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    /**
     * The data needed to update a ImageVehiclePart.
     */
    data: XOR<ImageVehiclePartUpdateInput, ImageVehiclePartUncheckedUpdateInput>
    /**
     * Choose, which ImageVehiclePart to update.
     */
    where: ImageVehiclePartWhereUniqueInput
  }

  /**
   * ImageVehiclePart updateMany
   */
  export type ImageVehiclePartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImageVehicleParts.
     */
    data: XOR<ImageVehiclePartUpdateManyMutationInput, ImageVehiclePartUncheckedUpdateManyInput>
    /**
     * Filter which ImageVehicleParts to update
     */
    where?: ImageVehiclePartWhereInput
  }

  /**
   * ImageVehiclePart upsert
   */
  export type ImageVehiclePartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    /**
     * The filter to search for the ImageVehiclePart to update in case it exists.
     */
    where: ImageVehiclePartWhereUniqueInput
    /**
     * In case the ImageVehiclePart found by the `where` argument doesn't exist, create a new ImageVehiclePart with this data.
     */
    create: XOR<ImageVehiclePartCreateInput, ImageVehiclePartUncheckedCreateInput>
    /**
     * In case the ImageVehiclePart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageVehiclePartUpdateInput, ImageVehiclePartUncheckedUpdateInput>
  }

  /**
   * ImageVehiclePart delete
   */
  export type ImageVehiclePartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
    /**
     * Filter which ImageVehiclePart to delete.
     */
    where: ImageVehiclePartWhereUniqueInput
  }

  /**
   * ImageVehiclePart deleteMany
   */
  export type ImageVehiclePartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageVehicleParts to delete
     */
    where?: ImageVehiclePartWhereInput
  }

  /**
   * ImageVehiclePart without action
   */
  export type ImageVehiclePartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageVehiclePart
     */
    select?: ImageVehiclePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageVehiclePartInclude<ExtArgs> | null
  }


  /**
   * Model ImageDamageType
   */

  export type AggregateImageDamageType = {
    _count: ImageDamageTypeCountAggregateOutputType | null
    _min: ImageDamageTypeMinAggregateOutputType | null
    _max: ImageDamageTypeMaxAggregateOutputType | null
  }

  export type ImageDamageTypeMinAggregateOutputType = {
    imageId: string | null
    damageTypeId: string | null
  }

  export type ImageDamageTypeMaxAggregateOutputType = {
    imageId: string | null
    damageTypeId: string | null
  }

  export type ImageDamageTypeCountAggregateOutputType = {
    imageId: number
    damageTypeId: number
    _all: number
  }


  export type ImageDamageTypeMinAggregateInputType = {
    imageId?: true
    damageTypeId?: true
  }

  export type ImageDamageTypeMaxAggregateInputType = {
    imageId?: true
    damageTypeId?: true
  }

  export type ImageDamageTypeCountAggregateInputType = {
    imageId?: true
    damageTypeId?: true
    _all?: true
  }

  export type ImageDamageTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageDamageType to aggregate.
     */
    where?: ImageDamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageDamageTypes to fetch.
     */
    orderBy?: ImageDamageTypeOrderByWithRelationInput | ImageDamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageDamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageDamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageDamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageDamageTypes
    **/
    _count?: true | ImageDamageTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageDamageTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageDamageTypeMaxAggregateInputType
  }

  export type GetImageDamageTypeAggregateType<T extends ImageDamageTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateImageDamageType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageDamageType[P]>
      : GetScalarType<T[P], AggregateImageDamageType[P]>
  }




  export type ImageDamageTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageDamageTypeWhereInput
    orderBy?: ImageDamageTypeOrderByWithAggregationInput | ImageDamageTypeOrderByWithAggregationInput[]
    by: ImageDamageTypeScalarFieldEnum[] | ImageDamageTypeScalarFieldEnum
    having?: ImageDamageTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageDamageTypeCountAggregateInputType | true
    _min?: ImageDamageTypeMinAggregateInputType
    _max?: ImageDamageTypeMaxAggregateInputType
  }

  export type ImageDamageTypeGroupByOutputType = {
    imageId: string
    damageTypeId: string
    _count: ImageDamageTypeCountAggregateOutputType | null
    _min: ImageDamageTypeMinAggregateOutputType | null
    _max: ImageDamageTypeMaxAggregateOutputType | null
  }

  type GetImageDamageTypeGroupByPayload<T extends ImageDamageTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageDamageTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageDamageTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageDamageTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ImageDamageTypeGroupByOutputType[P]>
        }
      >
    >


  export type ImageDamageTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    imageId?: boolean
    damageTypeId?: boolean
    image?: boolean | ImageDefaultArgs<ExtArgs>
    damageType?: boolean | DamageTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageDamageType"]>

  export type ImageDamageTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    imageId?: boolean
    damageTypeId?: boolean
    image?: boolean | ImageDefaultArgs<ExtArgs>
    damageType?: boolean | DamageTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageDamageType"]>

  export type ImageDamageTypeSelectScalar = {
    imageId?: boolean
    damageTypeId?: boolean
  }

  export type ImageDamageTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | ImageDefaultArgs<ExtArgs>
    damageType?: boolean | DamageTypeDefaultArgs<ExtArgs>
  }
  export type ImageDamageTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | ImageDefaultArgs<ExtArgs>
    damageType?: boolean | DamageTypeDefaultArgs<ExtArgs>
  }

  export type $ImageDamageTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImageDamageType"
    objects: {
      image: Prisma.$ImagePayload<ExtArgs>
      damageType: Prisma.$DamageTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      imageId: string
      damageTypeId: string
    }, ExtArgs["result"]["imageDamageType"]>
    composites: {}
  }

  type ImageDamageTypeGetPayload<S extends boolean | null | undefined | ImageDamageTypeDefaultArgs> = $Result.GetResult<Prisma.$ImageDamageTypePayload, S>

  type ImageDamageTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImageDamageTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImageDamageTypeCountAggregateInputType | true
    }

  export interface ImageDamageTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImageDamageType'], meta: { name: 'ImageDamageType' } }
    /**
     * Find zero or one ImageDamageType that matches the filter.
     * @param {ImageDamageTypeFindUniqueArgs} args - Arguments to find a ImageDamageType
     * @example
     * // Get one ImageDamageType
     * const imageDamageType = await prisma.imageDamageType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageDamageTypeFindUniqueArgs>(args: SelectSubset<T, ImageDamageTypeFindUniqueArgs<ExtArgs>>): Prisma__ImageDamageTypeClient<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImageDamageType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImageDamageTypeFindUniqueOrThrowArgs} args - Arguments to find a ImageDamageType
     * @example
     * // Get one ImageDamageType
     * const imageDamageType = await prisma.imageDamageType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageDamageTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageDamageTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageDamageTypeClient<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImageDamageType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageDamageTypeFindFirstArgs} args - Arguments to find a ImageDamageType
     * @example
     * // Get one ImageDamageType
     * const imageDamageType = await prisma.imageDamageType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageDamageTypeFindFirstArgs>(args?: SelectSubset<T, ImageDamageTypeFindFirstArgs<ExtArgs>>): Prisma__ImageDamageTypeClient<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImageDamageType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageDamageTypeFindFirstOrThrowArgs} args - Arguments to find a ImageDamageType
     * @example
     * // Get one ImageDamageType
     * const imageDamageType = await prisma.imageDamageType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageDamageTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageDamageTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageDamageTypeClient<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImageDamageTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageDamageTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageDamageTypes
     * const imageDamageTypes = await prisma.imageDamageType.findMany()
     * 
     * // Get first 10 ImageDamageTypes
     * const imageDamageTypes = await prisma.imageDamageType.findMany({ take: 10 })
     * 
     * // Only select the `imageId`
     * const imageDamageTypeWithImageIdOnly = await prisma.imageDamageType.findMany({ select: { imageId: true } })
     * 
     */
    findMany<T extends ImageDamageTypeFindManyArgs>(args?: SelectSubset<T, ImageDamageTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImageDamageType.
     * @param {ImageDamageTypeCreateArgs} args - Arguments to create a ImageDamageType.
     * @example
     * // Create one ImageDamageType
     * const ImageDamageType = await prisma.imageDamageType.create({
     *   data: {
     *     // ... data to create a ImageDamageType
     *   }
     * })
     * 
     */
    create<T extends ImageDamageTypeCreateArgs>(args: SelectSubset<T, ImageDamageTypeCreateArgs<ExtArgs>>): Prisma__ImageDamageTypeClient<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImageDamageTypes.
     * @param {ImageDamageTypeCreateManyArgs} args - Arguments to create many ImageDamageTypes.
     * @example
     * // Create many ImageDamageTypes
     * const imageDamageType = await prisma.imageDamageType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageDamageTypeCreateManyArgs>(args?: SelectSubset<T, ImageDamageTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImageDamageTypes and returns the data saved in the database.
     * @param {ImageDamageTypeCreateManyAndReturnArgs} args - Arguments to create many ImageDamageTypes.
     * @example
     * // Create many ImageDamageTypes
     * const imageDamageType = await prisma.imageDamageType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImageDamageTypes and only return the `imageId`
     * const imageDamageTypeWithImageIdOnly = await prisma.imageDamageType.createManyAndReturn({ 
     *   select: { imageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageDamageTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageDamageTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImageDamageType.
     * @param {ImageDamageTypeDeleteArgs} args - Arguments to delete one ImageDamageType.
     * @example
     * // Delete one ImageDamageType
     * const ImageDamageType = await prisma.imageDamageType.delete({
     *   where: {
     *     // ... filter to delete one ImageDamageType
     *   }
     * })
     * 
     */
    delete<T extends ImageDamageTypeDeleteArgs>(args: SelectSubset<T, ImageDamageTypeDeleteArgs<ExtArgs>>): Prisma__ImageDamageTypeClient<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImageDamageType.
     * @param {ImageDamageTypeUpdateArgs} args - Arguments to update one ImageDamageType.
     * @example
     * // Update one ImageDamageType
     * const imageDamageType = await prisma.imageDamageType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageDamageTypeUpdateArgs>(args: SelectSubset<T, ImageDamageTypeUpdateArgs<ExtArgs>>): Prisma__ImageDamageTypeClient<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImageDamageTypes.
     * @param {ImageDamageTypeDeleteManyArgs} args - Arguments to filter ImageDamageTypes to delete.
     * @example
     * // Delete a few ImageDamageTypes
     * const { count } = await prisma.imageDamageType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDamageTypeDeleteManyArgs>(args?: SelectSubset<T, ImageDamageTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageDamageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageDamageTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageDamageTypes
     * const imageDamageType = await prisma.imageDamageType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageDamageTypeUpdateManyArgs>(args: SelectSubset<T, ImageDamageTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageDamageType.
     * @param {ImageDamageTypeUpsertArgs} args - Arguments to update or create a ImageDamageType.
     * @example
     * // Update or create a ImageDamageType
     * const imageDamageType = await prisma.imageDamageType.upsert({
     *   create: {
     *     // ... data to create a ImageDamageType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageDamageType we want to update
     *   }
     * })
     */
    upsert<T extends ImageDamageTypeUpsertArgs>(args: SelectSubset<T, ImageDamageTypeUpsertArgs<ExtArgs>>): Prisma__ImageDamageTypeClient<$Result.GetResult<Prisma.$ImageDamageTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImageDamageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageDamageTypeCountArgs} args - Arguments to filter ImageDamageTypes to count.
     * @example
     * // Count the number of ImageDamageTypes
     * const count = await prisma.imageDamageType.count({
     *   where: {
     *     // ... the filter for the ImageDamageTypes we want to count
     *   }
     * })
    **/
    count<T extends ImageDamageTypeCountArgs>(
      args?: Subset<T, ImageDamageTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageDamageTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageDamageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageDamageTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageDamageTypeAggregateArgs>(args: Subset<T, ImageDamageTypeAggregateArgs>): Prisma.PrismaPromise<GetImageDamageTypeAggregateType<T>>

    /**
     * Group by ImageDamageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageDamageTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageDamageTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageDamageTypeGroupByArgs['orderBy'] }
        : { orderBy?: ImageDamageTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageDamageTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageDamageTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImageDamageType model
   */
  readonly fields: ImageDamageTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageDamageType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageDamageTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    image<T extends ImageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImageDefaultArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    damageType<T extends DamageTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DamageTypeDefaultArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImageDamageType model
   */ 
  interface ImageDamageTypeFieldRefs {
    readonly imageId: FieldRef<"ImageDamageType", 'String'>
    readonly damageTypeId: FieldRef<"ImageDamageType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImageDamageType findUnique
   */
  export type ImageDamageTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which ImageDamageType to fetch.
     */
    where: ImageDamageTypeWhereUniqueInput
  }

  /**
   * ImageDamageType findUniqueOrThrow
   */
  export type ImageDamageTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which ImageDamageType to fetch.
     */
    where: ImageDamageTypeWhereUniqueInput
  }

  /**
   * ImageDamageType findFirst
   */
  export type ImageDamageTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which ImageDamageType to fetch.
     */
    where?: ImageDamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageDamageTypes to fetch.
     */
    orderBy?: ImageDamageTypeOrderByWithRelationInput | ImageDamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageDamageTypes.
     */
    cursor?: ImageDamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageDamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageDamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageDamageTypes.
     */
    distinct?: ImageDamageTypeScalarFieldEnum | ImageDamageTypeScalarFieldEnum[]
  }

  /**
   * ImageDamageType findFirstOrThrow
   */
  export type ImageDamageTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which ImageDamageType to fetch.
     */
    where?: ImageDamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageDamageTypes to fetch.
     */
    orderBy?: ImageDamageTypeOrderByWithRelationInput | ImageDamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageDamageTypes.
     */
    cursor?: ImageDamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageDamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageDamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageDamageTypes.
     */
    distinct?: ImageDamageTypeScalarFieldEnum | ImageDamageTypeScalarFieldEnum[]
  }

  /**
   * ImageDamageType findMany
   */
  export type ImageDamageTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which ImageDamageTypes to fetch.
     */
    where?: ImageDamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageDamageTypes to fetch.
     */
    orderBy?: ImageDamageTypeOrderByWithRelationInput | ImageDamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageDamageTypes.
     */
    cursor?: ImageDamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageDamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageDamageTypes.
     */
    skip?: number
    distinct?: ImageDamageTypeScalarFieldEnum | ImageDamageTypeScalarFieldEnum[]
  }

  /**
   * ImageDamageType create
   */
  export type ImageDamageTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ImageDamageType.
     */
    data: XOR<ImageDamageTypeCreateInput, ImageDamageTypeUncheckedCreateInput>
  }

  /**
   * ImageDamageType createMany
   */
  export type ImageDamageTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImageDamageTypes.
     */
    data: ImageDamageTypeCreateManyInput | ImageDamageTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImageDamageType createManyAndReturn
   */
  export type ImageDamageTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImageDamageTypes.
     */
    data: ImageDamageTypeCreateManyInput | ImageDamageTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImageDamageType update
   */
  export type ImageDamageTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ImageDamageType.
     */
    data: XOR<ImageDamageTypeUpdateInput, ImageDamageTypeUncheckedUpdateInput>
    /**
     * Choose, which ImageDamageType to update.
     */
    where: ImageDamageTypeWhereUniqueInput
  }

  /**
   * ImageDamageType updateMany
   */
  export type ImageDamageTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImageDamageTypes.
     */
    data: XOR<ImageDamageTypeUpdateManyMutationInput, ImageDamageTypeUncheckedUpdateManyInput>
    /**
     * Filter which ImageDamageTypes to update
     */
    where?: ImageDamageTypeWhereInput
  }

  /**
   * ImageDamageType upsert
   */
  export type ImageDamageTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ImageDamageType to update in case it exists.
     */
    where: ImageDamageTypeWhereUniqueInput
    /**
     * In case the ImageDamageType found by the `where` argument doesn't exist, create a new ImageDamageType with this data.
     */
    create: XOR<ImageDamageTypeCreateInput, ImageDamageTypeUncheckedCreateInput>
    /**
     * In case the ImageDamageType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageDamageTypeUpdateInput, ImageDamageTypeUncheckedUpdateInput>
  }

  /**
   * ImageDamageType delete
   */
  export type ImageDamageTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
    /**
     * Filter which ImageDamageType to delete.
     */
    where: ImageDamageTypeWhereUniqueInput
  }

  /**
   * ImageDamageType deleteMany
   */
  export type ImageDamageTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageDamageTypes to delete
     */
    where?: ImageDamageTypeWhereInput
  }

  /**
   * ImageDamageType without action
   */
  export type ImageDamageTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageDamageType
     */
    select?: ImageDamageTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageDamageTypeInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
  }

  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model VehicleReferenceImage
   */

  export type AggregateVehicleReferenceImage = {
    _count: VehicleReferenceImageCountAggregateOutputType | null
    _min: VehicleReferenceImageMinAggregateOutputType | null
    _max: VehicleReferenceImageMaxAggregateOutputType | null
  }

  export type VehicleReferenceImageMinAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    angle: string | null
    vehicleVin: string | null
  }

  export type VehicleReferenceImageMaxAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    angle: string | null
    vehicleVin: string | null
  }

  export type VehicleReferenceImageCountAggregateOutputType = {
    id: number
    imageUrl: number
    angle: number
    vehicleVin: number
    _all: number
  }


  export type VehicleReferenceImageMinAggregateInputType = {
    id?: true
    imageUrl?: true
    angle?: true
    vehicleVin?: true
  }

  export type VehicleReferenceImageMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    angle?: true
    vehicleVin?: true
  }

  export type VehicleReferenceImageCountAggregateInputType = {
    id?: true
    imageUrl?: true
    angle?: true
    vehicleVin?: true
    _all?: true
  }

  export type VehicleReferenceImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleReferenceImage to aggregate.
     */
    where?: VehicleReferenceImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleReferenceImages to fetch.
     */
    orderBy?: VehicleReferenceImageOrderByWithRelationInput | VehicleReferenceImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleReferenceImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleReferenceImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleReferenceImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleReferenceImages
    **/
    _count?: true | VehicleReferenceImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleReferenceImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleReferenceImageMaxAggregateInputType
  }

  export type GetVehicleReferenceImageAggregateType<T extends VehicleReferenceImageAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleReferenceImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleReferenceImage[P]>
      : GetScalarType<T[P], AggregateVehicleReferenceImage[P]>
  }




  export type VehicleReferenceImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleReferenceImageWhereInput
    orderBy?: VehicleReferenceImageOrderByWithAggregationInput | VehicleReferenceImageOrderByWithAggregationInput[]
    by: VehicleReferenceImageScalarFieldEnum[] | VehicleReferenceImageScalarFieldEnum
    having?: VehicleReferenceImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleReferenceImageCountAggregateInputType | true
    _min?: VehicleReferenceImageMinAggregateInputType
    _max?: VehicleReferenceImageMaxAggregateInputType
  }

  export type VehicleReferenceImageGroupByOutputType = {
    id: string
    imageUrl: string
    angle: string | null
    vehicleVin: string
    _count: VehicleReferenceImageCountAggregateOutputType | null
    _min: VehicleReferenceImageMinAggregateOutputType | null
    _max: VehicleReferenceImageMaxAggregateOutputType | null
  }

  type GetVehicleReferenceImageGroupByPayload<T extends VehicleReferenceImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleReferenceImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleReferenceImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleReferenceImageGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleReferenceImageGroupByOutputType[P]>
        }
      >
    >


  export type VehicleReferenceImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    angle?: boolean
    vehicleVin?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleReferenceImage"]>

  export type VehicleReferenceImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    angle?: boolean
    vehicleVin?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleReferenceImage"]>

  export type VehicleReferenceImageSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    angle?: boolean
    vehicleVin?: boolean
  }

  export type VehicleReferenceImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type VehicleReferenceImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $VehicleReferenceImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleReferenceImage"
    objects: {
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imageUrl: string
      angle: string | null
      vehicleVin: string
    }, ExtArgs["result"]["vehicleReferenceImage"]>
    composites: {}
  }

  type VehicleReferenceImageGetPayload<S extends boolean | null | undefined | VehicleReferenceImageDefaultArgs> = $Result.GetResult<Prisma.$VehicleReferenceImagePayload, S>

  type VehicleReferenceImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleReferenceImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleReferenceImageCountAggregateInputType | true
    }

  export interface VehicleReferenceImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleReferenceImage'], meta: { name: 'VehicleReferenceImage' } }
    /**
     * Find zero or one VehicleReferenceImage that matches the filter.
     * @param {VehicleReferenceImageFindUniqueArgs} args - Arguments to find a VehicleReferenceImage
     * @example
     * // Get one VehicleReferenceImage
     * const vehicleReferenceImage = await prisma.vehicleReferenceImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleReferenceImageFindUniqueArgs>(args: SelectSubset<T, VehicleReferenceImageFindUniqueArgs<ExtArgs>>): Prisma__VehicleReferenceImageClient<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VehicleReferenceImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleReferenceImageFindUniqueOrThrowArgs} args - Arguments to find a VehicleReferenceImage
     * @example
     * // Get one VehicleReferenceImage
     * const vehicleReferenceImage = await prisma.vehicleReferenceImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleReferenceImageFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleReferenceImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleReferenceImageClient<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VehicleReferenceImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleReferenceImageFindFirstArgs} args - Arguments to find a VehicleReferenceImage
     * @example
     * // Get one VehicleReferenceImage
     * const vehicleReferenceImage = await prisma.vehicleReferenceImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleReferenceImageFindFirstArgs>(args?: SelectSubset<T, VehicleReferenceImageFindFirstArgs<ExtArgs>>): Prisma__VehicleReferenceImageClient<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VehicleReferenceImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleReferenceImageFindFirstOrThrowArgs} args - Arguments to find a VehicleReferenceImage
     * @example
     * // Get one VehicleReferenceImage
     * const vehicleReferenceImage = await prisma.vehicleReferenceImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleReferenceImageFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleReferenceImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleReferenceImageClient<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VehicleReferenceImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleReferenceImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleReferenceImages
     * const vehicleReferenceImages = await prisma.vehicleReferenceImage.findMany()
     * 
     * // Get first 10 VehicleReferenceImages
     * const vehicleReferenceImages = await prisma.vehicleReferenceImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleReferenceImageWithIdOnly = await prisma.vehicleReferenceImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleReferenceImageFindManyArgs>(args?: SelectSubset<T, VehicleReferenceImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VehicleReferenceImage.
     * @param {VehicleReferenceImageCreateArgs} args - Arguments to create a VehicleReferenceImage.
     * @example
     * // Create one VehicleReferenceImage
     * const VehicleReferenceImage = await prisma.vehicleReferenceImage.create({
     *   data: {
     *     // ... data to create a VehicleReferenceImage
     *   }
     * })
     * 
     */
    create<T extends VehicleReferenceImageCreateArgs>(args: SelectSubset<T, VehicleReferenceImageCreateArgs<ExtArgs>>): Prisma__VehicleReferenceImageClient<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VehicleReferenceImages.
     * @param {VehicleReferenceImageCreateManyArgs} args - Arguments to create many VehicleReferenceImages.
     * @example
     * // Create many VehicleReferenceImages
     * const vehicleReferenceImage = await prisma.vehicleReferenceImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleReferenceImageCreateManyArgs>(args?: SelectSubset<T, VehicleReferenceImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleReferenceImages and returns the data saved in the database.
     * @param {VehicleReferenceImageCreateManyAndReturnArgs} args - Arguments to create many VehicleReferenceImages.
     * @example
     * // Create many VehicleReferenceImages
     * const vehicleReferenceImage = await prisma.vehicleReferenceImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleReferenceImages and only return the `id`
     * const vehicleReferenceImageWithIdOnly = await prisma.vehicleReferenceImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleReferenceImageCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleReferenceImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VehicleReferenceImage.
     * @param {VehicleReferenceImageDeleteArgs} args - Arguments to delete one VehicleReferenceImage.
     * @example
     * // Delete one VehicleReferenceImage
     * const VehicleReferenceImage = await prisma.vehicleReferenceImage.delete({
     *   where: {
     *     // ... filter to delete one VehicleReferenceImage
     *   }
     * })
     * 
     */
    delete<T extends VehicleReferenceImageDeleteArgs>(args: SelectSubset<T, VehicleReferenceImageDeleteArgs<ExtArgs>>): Prisma__VehicleReferenceImageClient<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VehicleReferenceImage.
     * @param {VehicleReferenceImageUpdateArgs} args - Arguments to update one VehicleReferenceImage.
     * @example
     * // Update one VehicleReferenceImage
     * const vehicleReferenceImage = await prisma.vehicleReferenceImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleReferenceImageUpdateArgs>(args: SelectSubset<T, VehicleReferenceImageUpdateArgs<ExtArgs>>): Prisma__VehicleReferenceImageClient<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VehicleReferenceImages.
     * @param {VehicleReferenceImageDeleteManyArgs} args - Arguments to filter VehicleReferenceImages to delete.
     * @example
     * // Delete a few VehicleReferenceImages
     * const { count } = await prisma.vehicleReferenceImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleReferenceImageDeleteManyArgs>(args?: SelectSubset<T, VehicleReferenceImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleReferenceImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleReferenceImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleReferenceImages
     * const vehicleReferenceImage = await prisma.vehicleReferenceImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleReferenceImageUpdateManyArgs>(args: SelectSubset<T, VehicleReferenceImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VehicleReferenceImage.
     * @param {VehicleReferenceImageUpsertArgs} args - Arguments to update or create a VehicleReferenceImage.
     * @example
     * // Update or create a VehicleReferenceImage
     * const vehicleReferenceImage = await prisma.vehicleReferenceImage.upsert({
     *   create: {
     *     // ... data to create a VehicleReferenceImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleReferenceImage we want to update
     *   }
     * })
     */
    upsert<T extends VehicleReferenceImageUpsertArgs>(args: SelectSubset<T, VehicleReferenceImageUpsertArgs<ExtArgs>>): Prisma__VehicleReferenceImageClient<$Result.GetResult<Prisma.$VehicleReferenceImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VehicleReferenceImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleReferenceImageCountArgs} args - Arguments to filter VehicleReferenceImages to count.
     * @example
     * // Count the number of VehicleReferenceImages
     * const count = await prisma.vehicleReferenceImage.count({
     *   where: {
     *     // ... the filter for the VehicleReferenceImages we want to count
     *   }
     * })
    **/
    count<T extends VehicleReferenceImageCountArgs>(
      args?: Subset<T, VehicleReferenceImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleReferenceImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleReferenceImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleReferenceImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleReferenceImageAggregateArgs>(args: Subset<T, VehicleReferenceImageAggregateArgs>): Prisma.PrismaPromise<GetVehicleReferenceImageAggregateType<T>>

    /**
     * Group by VehicleReferenceImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleReferenceImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleReferenceImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleReferenceImageGroupByArgs['orderBy'] }
        : { orderBy?: VehicleReferenceImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleReferenceImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleReferenceImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleReferenceImage model
   */
  readonly fields: VehicleReferenceImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleReferenceImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleReferenceImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleReferenceImage model
   */ 
  interface VehicleReferenceImageFieldRefs {
    readonly id: FieldRef<"VehicleReferenceImage", 'String'>
    readonly imageUrl: FieldRef<"VehicleReferenceImage", 'String'>
    readonly angle: FieldRef<"VehicleReferenceImage", 'String'>
    readonly vehicleVin: FieldRef<"VehicleReferenceImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehicleReferenceImage findUnique
   */
  export type VehicleReferenceImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleReferenceImage to fetch.
     */
    where: VehicleReferenceImageWhereUniqueInput
  }

  /**
   * VehicleReferenceImage findUniqueOrThrow
   */
  export type VehicleReferenceImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleReferenceImage to fetch.
     */
    where: VehicleReferenceImageWhereUniqueInput
  }

  /**
   * VehicleReferenceImage findFirst
   */
  export type VehicleReferenceImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleReferenceImage to fetch.
     */
    where?: VehicleReferenceImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleReferenceImages to fetch.
     */
    orderBy?: VehicleReferenceImageOrderByWithRelationInput | VehicleReferenceImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleReferenceImages.
     */
    cursor?: VehicleReferenceImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleReferenceImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleReferenceImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleReferenceImages.
     */
    distinct?: VehicleReferenceImageScalarFieldEnum | VehicleReferenceImageScalarFieldEnum[]
  }

  /**
   * VehicleReferenceImage findFirstOrThrow
   */
  export type VehicleReferenceImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleReferenceImage to fetch.
     */
    where?: VehicleReferenceImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleReferenceImages to fetch.
     */
    orderBy?: VehicleReferenceImageOrderByWithRelationInput | VehicleReferenceImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleReferenceImages.
     */
    cursor?: VehicleReferenceImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleReferenceImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleReferenceImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleReferenceImages.
     */
    distinct?: VehicleReferenceImageScalarFieldEnum | VehicleReferenceImageScalarFieldEnum[]
  }

  /**
   * VehicleReferenceImage findMany
   */
  export type VehicleReferenceImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleReferenceImages to fetch.
     */
    where?: VehicleReferenceImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleReferenceImages to fetch.
     */
    orderBy?: VehicleReferenceImageOrderByWithRelationInput | VehicleReferenceImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleReferenceImages.
     */
    cursor?: VehicleReferenceImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleReferenceImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleReferenceImages.
     */
    skip?: number
    distinct?: VehicleReferenceImageScalarFieldEnum | VehicleReferenceImageScalarFieldEnum[]
  }

  /**
   * VehicleReferenceImage create
   */
  export type VehicleReferenceImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleReferenceImage.
     */
    data: XOR<VehicleReferenceImageCreateInput, VehicleReferenceImageUncheckedCreateInput>
  }

  /**
   * VehicleReferenceImage createMany
   */
  export type VehicleReferenceImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleReferenceImages.
     */
    data: VehicleReferenceImageCreateManyInput | VehicleReferenceImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleReferenceImage createManyAndReturn
   */
  export type VehicleReferenceImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VehicleReferenceImages.
     */
    data: VehicleReferenceImageCreateManyInput | VehicleReferenceImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleReferenceImage update
   */
  export type VehicleReferenceImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleReferenceImage.
     */
    data: XOR<VehicleReferenceImageUpdateInput, VehicleReferenceImageUncheckedUpdateInput>
    /**
     * Choose, which VehicleReferenceImage to update.
     */
    where: VehicleReferenceImageWhereUniqueInput
  }

  /**
   * VehicleReferenceImage updateMany
   */
  export type VehicleReferenceImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleReferenceImages.
     */
    data: XOR<VehicleReferenceImageUpdateManyMutationInput, VehicleReferenceImageUncheckedUpdateManyInput>
    /**
     * Filter which VehicleReferenceImages to update
     */
    where?: VehicleReferenceImageWhereInput
  }

  /**
   * VehicleReferenceImage upsert
   */
  export type VehicleReferenceImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleReferenceImage to update in case it exists.
     */
    where: VehicleReferenceImageWhereUniqueInput
    /**
     * In case the VehicleReferenceImage found by the `where` argument doesn't exist, create a new VehicleReferenceImage with this data.
     */
    create: XOR<VehicleReferenceImageCreateInput, VehicleReferenceImageUncheckedCreateInput>
    /**
     * In case the VehicleReferenceImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleReferenceImageUpdateInput, VehicleReferenceImageUncheckedUpdateInput>
  }

  /**
   * VehicleReferenceImage delete
   */
  export type VehicleReferenceImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
    /**
     * Filter which VehicleReferenceImage to delete.
     */
    where: VehicleReferenceImageWhereUniqueInput
  }

  /**
   * VehicleReferenceImage deleteMany
   */
  export type VehicleReferenceImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleReferenceImages to delete
     */
    where?: VehicleReferenceImageWhereInput
  }

  /**
   * VehicleReferenceImage without action
   */
  export type VehicleReferenceImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleReferenceImage
     */
    select?: VehicleReferenceImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleReferenceImageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    hashedPassword: 'hashedPassword',
    createdAt: 'createdAt',
    role: 'role',
    experienceLevel: 'experienceLevel'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    vin: 'vin',
    type: 'type',
    make: 'make',
    model: 'model',
    year: 'year',
    weightClass: 'weightClass',
    owner: 'owner',
    notes: 'notes',
    createdAt: 'createdAt',
    bodyClass: 'bodyClass',
    driveType: 'driveType',
    engineModel: 'engineModel',
    engineCylinders: 'engineCylinders',
    engineDisplacementL: 'engineDisplacementL',
    fuelTypePrimary: 'fuelTypePrimary',
    brakeSystemType: 'brakeSystemType',
    manufacturerName: 'manufacturerName',
    plantCity: 'plantCity',
    plantState: 'plantState',
    plantCountry: 'plantCountry',
    trim: 'trim',
    series: 'series',
    steeringLocation: 'steeringLocation',
    transmissionStyle: 'transmissionStyle',
    vehicleType: 'vehicleType',
    gvwr: 'gvwr',
    doors: 'doors',
    wheels: 'wheels',
    entertainmentSystem: 'entertainmentSystem',
    abs: 'abs',
    airbagLocations: 'airbagLocations',
    electronicStabilityControl: 'electronicStabilityControl',
    basePrice: 'basePrice',
    bedLength: 'bedLength',
    cabType: 'cabType'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const JobReportScalarFieldEnum: {
    id: 'id',
    vin: 'vin',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    status: 'status',
    aiEstimate: 'aiEstimate',
    aiResponse: 'aiResponse'
  };

  export type JobReportScalarFieldEnum = (typeof JobReportScalarFieldEnum)[keyof typeof JobReportScalarFieldEnum]


  export const RepairEstimateScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    timeEstimate: 'timeEstimate',
    costEstimate: 'costEstimate',
    createdAt: 'createdAt'
  };

  export type RepairEstimateScalarFieldEnum = (typeof RepairEstimateScalarFieldEnum)[keyof typeof RepairEstimateScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    jobId: 'jobId',
    estimateId: 'estimateId',
    feedbackType: 'feedbackType',
    message: 'message',
    actualHours: 'actualHours',
    experienceScoreSnapshot: 'experienceScoreSnapshot',
    createdAt: 'createdAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    imagePath: 'imagePath',
    truckSectionId: 'truckSectionId',
    severityId: 'severityId',
    notes: 'notes',
    uploadedAt: 'uploadedAt'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const DetectedDamageScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    aiOutputJson: 'aiOutputJson',
    generatedAt: 'generatedAt'
  };

  export type DetectedDamageScalarFieldEnum = (typeof DetectedDamageScalarFieldEnum)[keyof typeof DetectedDamageScalarFieldEnum]


  export const ActualRepairScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    actualHours: 'actualHours',
    notes: 'notes',
    confirmedById: 'confirmedById',
    confirmedAt: 'confirmedAt'
  };

  export type ActualRepairScalarFieldEnum = (typeof ActualRepairScalarFieldEnum)[keyof typeof ActualRepairScalarFieldEnum]


  export const TrainingImageScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    label: 'label',
    uploadedAt: 'uploadedAt'
  };

  export type TrainingImageScalarFieldEnum = (typeof TrainingImageScalarFieldEnum)[keyof typeof TrainingImageScalarFieldEnum]


  export const VINMetadataScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    vin: 'vin',
    make: 'make',
    model: 'model',
    year: 'year',
    engine: 'engine',
    misc: 'misc',
    decodedAt: 'decodedAt'
  };

  export type VINMetadataScalarFieldEnum = (typeof VINMetadataScalarFieldEnum)[keyof typeof VINMetadataScalarFieldEnum]


  export const TruckSectionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TruckSectionScalarFieldEnum = (typeof TruckSectionScalarFieldEnum)[keyof typeof TruckSectionScalarFieldEnum]


  export const VehiclePartScalarFieldEnum: {
    id: 'id',
    name: 'name',
    truckSectionId: 'truckSectionId'
  };

  export type VehiclePartScalarFieldEnum = (typeof VehiclePartScalarFieldEnum)[keyof typeof VehiclePartScalarFieldEnum]


  export const DamageTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DamageTypeScalarFieldEnum = (typeof DamageTypeScalarFieldEnum)[keyof typeof DamageTypeScalarFieldEnum]


  export const SeverityLevelScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SeverityLevelScalarFieldEnum = (typeof SeverityLevelScalarFieldEnum)[keyof typeof SeverityLevelScalarFieldEnum]


  export const ImageVehiclePartScalarFieldEnum: {
    imageId: 'imageId',
    vehiclePartId: 'vehiclePartId'
  };

  export type ImageVehiclePartScalarFieldEnum = (typeof ImageVehiclePartScalarFieldEnum)[keyof typeof ImageVehiclePartScalarFieldEnum]


  export const ImageDamageTypeScalarFieldEnum: {
    imageId: 'imageId',
    damageTypeId: 'damageTypeId'
  };

  export type ImageDamageTypeScalarFieldEnum = (typeof ImageDamageTypeScalarFieldEnum)[keyof typeof ImageDamageTypeScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const VehicleReferenceImageScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    angle: 'angle',
    vehicleVin: 'vehicleVin'
  };

  export type VehicleReferenceImageScalarFieldEnum = (typeof VehicleReferenceImageScalarFieldEnum)[keyof typeof VehicleReferenceImageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    hashedPassword?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    experienceLevel?: IntFilter<"User"> | number
    jobs?: JobReportListRelationFilter
    confirmedRepairs?: ActualRepairListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    resetTokens?: PasswordResetTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    experienceLevel?: SortOrder
    jobs?: JobReportOrderByRelationAggregateInput
    confirmedRepairs?: ActualRepairOrderByRelationAggregateInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
    resetTokens?: PasswordResetTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    hashedPassword?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    experienceLevel?: IntFilter<"User"> | number
    jobs?: JobReportListRelationFilter
    confirmedRepairs?: ActualRepairListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    resetTokens?: PasswordResetTokenListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    experienceLevel?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    hashedPassword?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: StringWithAggregatesFilter<"User"> | string
    experienceLevel?: IntWithAggregatesFilter<"User"> | number
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    vin?: StringFilter<"Vehicle"> | string
    type?: StringNullableFilter<"Vehicle"> | string | null
    make?: StringNullableFilter<"Vehicle"> | string | null
    model?: StringNullableFilter<"Vehicle"> | string | null
    year?: IntNullableFilter<"Vehicle"> | number | null
    weightClass?: StringNullableFilter<"Vehicle"> | string | null
    owner?: StringNullableFilter<"Vehicle"> | string | null
    notes?: StringNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    bodyClass?: StringNullableFilter<"Vehicle"> | string | null
    driveType?: StringNullableFilter<"Vehicle"> | string | null
    engineModel?: StringNullableFilter<"Vehicle"> | string | null
    engineCylinders?: IntNullableFilter<"Vehicle"> | number | null
    engineDisplacementL?: FloatNullableFilter<"Vehicle"> | number | null
    fuelTypePrimary?: StringNullableFilter<"Vehicle"> | string | null
    brakeSystemType?: StringNullableFilter<"Vehicle"> | string | null
    manufacturerName?: StringNullableFilter<"Vehicle"> | string | null
    plantCity?: StringNullableFilter<"Vehicle"> | string | null
    plantState?: StringNullableFilter<"Vehicle"> | string | null
    plantCountry?: StringNullableFilter<"Vehicle"> | string | null
    trim?: StringNullableFilter<"Vehicle"> | string | null
    series?: StringNullableFilter<"Vehicle"> | string | null
    steeringLocation?: StringNullableFilter<"Vehicle"> | string | null
    transmissionStyle?: StringNullableFilter<"Vehicle"> | string | null
    vehicleType?: StringNullableFilter<"Vehicle"> | string | null
    gvwr?: StringNullableFilter<"Vehicle"> | string | null
    doors?: StringNullableFilter<"Vehicle"> | string | null
    wheels?: StringNullableFilter<"Vehicle"> | string | null
    entertainmentSystem?: StringNullableFilter<"Vehicle"> | string | null
    abs?: StringNullableFilter<"Vehicle"> | string | null
    airbagLocations?: StringNullableFilter<"Vehicle"> | string | null
    electronicStabilityControl?: StringNullableFilter<"Vehicle"> | string | null
    basePrice?: StringNullableFilter<"Vehicle"> | string | null
    bedLength?: StringNullableFilter<"Vehicle"> | string | null
    cabType?: StringNullableFilter<"Vehicle"> | string | null
    jobs?: JobReportListRelationFilter
    referenceImages?: VehicleReferenceImageListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    vin?: SortOrder
    type?: SortOrderInput | SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    weightClass?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bodyClass?: SortOrderInput | SortOrder
    driveType?: SortOrderInput | SortOrder
    engineModel?: SortOrderInput | SortOrder
    engineCylinders?: SortOrderInput | SortOrder
    engineDisplacementL?: SortOrderInput | SortOrder
    fuelTypePrimary?: SortOrderInput | SortOrder
    brakeSystemType?: SortOrderInput | SortOrder
    manufacturerName?: SortOrderInput | SortOrder
    plantCity?: SortOrderInput | SortOrder
    plantState?: SortOrderInput | SortOrder
    plantCountry?: SortOrderInput | SortOrder
    trim?: SortOrderInput | SortOrder
    series?: SortOrderInput | SortOrder
    steeringLocation?: SortOrderInput | SortOrder
    transmissionStyle?: SortOrderInput | SortOrder
    vehicleType?: SortOrderInput | SortOrder
    gvwr?: SortOrderInput | SortOrder
    doors?: SortOrderInput | SortOrder
    wheels?: SortOrderInput | SortOrder
    entertainmentSystem?: SortOrderInput | SortOrder
    abs?: SortOrderInput | SortOrder
    airbagLocations?: SortOrderInput | SortOrder
    electronicStabilityControl?: SortOrderInput | SortOrder
    basePrice?: SortOrderInput | SortOrder
    bedLength?: SortOrderInput | SortOrder
    cabType?: SortOrderInput | SortOrder
    jobs?: JobReportOrderByRelationAggregateInput
    referenceImages?: VehicleReferenceImageOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vin?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    type?: StringNullableFilter<"Vehicle"> | string | null
    make?: StringNullableFilter<"Vehicle"> | string | null
    model?: StringNullableFilter<"Vehicle"> | string | null
    year?: IntNullableFilter<"Vehicle"> | number | null
    weightClass?: StringNullableFilter<"Vehicle"> | string | null
    owner?: StringNullableFilter<"Vehicle"> | string | null
    notes?: StringNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    bodyClass?: StringNullableFilter<"Vehicle"> | string | null
    driveType?: StringNullableFilter<"Vehicle"> | string | null
    engineModel?: StringNullableFilter<"Vehicle"> | string | null
    engineCylinders?: IntNullableFilter<"Vehicle"> | number | null
    engineDisplacementL?: FloatNullableFilter<"Vehicle"> | number | null
    fuelTypePrimary?: StringNullableFilter<"Vehicle"> | string | null
    brakeSystemType?: StringNullableFilter<"Vehicle"> | string | null
    manufacturerName?: StringNullableFilter<"Vehicle"> | string | null
    plantCity?: StringNullableFilter<"Vehicle"> | string | null
    plantState?: StringNullableFilter<"Vehicle"> | string | null
    plantCountry?: StringNullableFilter<"Vehicle"> | string | null
    trim?: StringNullableFilter<"Vehicle"> | string | null
    series?: StringNullableFilter<"Vehicle"> | string | null
    steeringLocation?: StringNullableFilter<"Vehicle"> | string | null
    transmissionStyle?: StringNullableFilter<"Vehicle"> | string | null
    vehicleType?: StringNullableFilter<"Vehicle"> | string | null
    gvwr?: StringNullableFilter<"Vehicle"> | string | null
    doors?: StringNullableFilter<"Vehicle"> | string | null
    wheels?: StringNullableFilter<"Vehicle"> | string | null
    entertainmentSystem?: StringNullableFilter<"Vehicle"> | string | null
    abs?: StringNullableFilter<"Vehicle"> | string | null
    airbagLocations?: StringNullableFilter<"Vehicle"> | string | null
    electronicStabilityControl?: StringNullableFilter<"Vehicle"> | string | null
    basePrice?: StringNullableFilter<"Vehicle"> | string | null
    bedLength?: StringNullableFilter<"Vehicle"> | string | null
    cabType?: StringNullableFilter<"Vehicle"> | string | null
    jobs?: JobReportListRelationFilter
    referenceImages?: VehicleReferenceImageListRelationFilter
  }, "id" | "vin">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    vin?: SortOrder
    type?: SortOrderInput | SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    weightClass?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bodyClass?: SortOrderInput | SortOrder
    driveType?: SortOrderInput | SortOrder
    engineModel?: SortOrderInput | SortOrder
    engineCylinders?: SortOrderInput | SortOrder
    engineDisplacementL?: SortOrderInput | SortOrder
    fuelTypePrimary?: SortOrderInput | SortOrder
    brakeSystemType?: SortOrderInput | SortOrder
    manufacturerName?: SortOrderInput | SortOrder
    plantCity?: SortOrderInput | SortOrder
    plantState?: SortOrderInput | SortOrder
    plantCountry?: SortOrderInput | SortOrder
    trim?: SortOrderInput | SortOrder
    series?: SortOrderInput | SortOrder
    steeringLocation?: SortOrderInput | SortOrder
    transmissionStyle?: SortOrderInput | SortOrder
    vehicleType?: SortOrderInput | SortOrder
    gvwr?: SortOrderInput | SortOrder
    doors?: SortOrderInput | SortOrder
    wheels?: SortOrderInput | SortOrder
    entertainmentSystem?: SortOrderInput | SortOrder
    abs?: SortOrderInput | SortOrder
    airbagLocations?: SortOrderInput | SortOrder
    electronicStabilityControl?: SortOrderInput | SortOrder
    basePrice?: SortOrderInput | SortOrder
    bedLength?: SortOrderInput | SortOrder
    cabType?: SortOrderInput | SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vehicle"> | string
    vin?: StringWithAggregatesFilter<"Vehicle"> | string
    type?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    make?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    model?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    year?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    weightClass?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    owner?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    bodyClass?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    driveType?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    engineModel?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    engineCylinders?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    engineDisplacementL?: FloatNullableWithAggregatesFilter<"Vehicle"> | number | null
    fuelTypePrimary?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    brakeSystemType?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    manufacturerName?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    plantCity?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    plantState?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    plantCountry?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    trim?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    series?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    steeringLocation?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    transmissionStyle?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    vehicleType?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    gvwr?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    doors?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    wheels?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    entertainmentSystem?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    abs?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    airbagLocations?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    electronicStabilityControl?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    basePrice?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    bedLength?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    cabType?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
  }

  export type JobReportWhereInput = {
    AND?: JobReportWhereInput | JobReportWhereInput[]
    OR?: JobReportWhereInput[]
    NOT?: JobReportWhereInput | JobReportWhereInput[]
    id?: StringFilter<"JobReport"> | string
    vin?: StringFilter<"JobReport"> | string
    uploadedById?: StringFilter<"JobReport"> | string
    createdAt?: DateTimeFilter<"JobReport"> | Date | string
    status?: StringFilter<"JobReport"> | string
    aiEstimate?: FloatNullableFilter<"JobReport"> | number | null
    aiResponse?: StringNullableFilter<"JobReport"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    images?: ImageListRelationFilter
    detectedDamages?: DetectedDamageListRelationFilter
    repairEstimates?: RepairEstimateListRelationFilter
    actualRepairs?: ActualRepairListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    vinMetadata?: VINMetadataListRelationFilter
  }

  export type JobReportOrderByWithRelationInput = {
    id?: SortOrder
    vin?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    aiEstimate?: SortOrderInput | SortOrder
    aiResponse?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    images?: ImageOrderByRelationAggregateInput
    detectedDamages?: DetectedDamageOrderByRelationAggregateInput
    repairEstimates?: RepairEstimateOrderByRelationAggregateInput
    actualRepairs?: ActualRepairOrderByRelationAggregateInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
    vinMetadata?: VINMetadataOrderByRelationAggregateInput
  }

  export type JobReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobReportWhereInput | JobReportWhereInput[]
    OR?: JobReportWhereInput[]
    NOT?: JobReportWhereInput | JobReportWhereInput[]
    vin?: StringFilter<"JobReport"> | string
    uploadedById?: StringFilter<"JobReport"> | string
    createdAt?: DateTimeFilter<"JobReport"> | Date | string
    status?: StringFilter<"JobReport"> | string
    aiEstimate?: FloatNullableFilter<"JobReport"> | number | null
    aiResponse?: StringNullableFilter<"JobReport"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    images?: ImageListRelationFilter
    detectedDamages?: DetectedDamageListRelationFilter
    repairEstimates?: RepairEstimateListRelationFilter
    actualRepairs?: ActualRepairListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    vinMetadata?: VINMetadataListRelationFilter
  }, "id">

  export type JobReportOrderByWithAggregationInput = {
    id?: SortOrder
    vin?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    aiEstimate?: SortOrderInput | SortOrder
    aiResponse?: SortOrderInput | SortOrder
    _count?: JobReportCountOrderByAggregateInput
    _avg?: JobReportAvgOrderByAggregateInput
    _max?: JobReportMaxOrderByAggregateInput
    _min?: JobReportMinOrderByAggregateInput
    _sum?: JobReportSumOrderByAggregateInput
  }

  export type JobReportScalarWhereWithAggregatesInput = {
    AND?: JobReportScalarWhereWithAggregatesInput | JobReportScalarWhereWithAggregatesInput[]
    OR?: JobReportScalarWhereWithAggregatesInput[]
    NOT?: JobReportScalarWhereWithAggregatesInput | JobReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobReport"> | string
    vin?: StringWithAggregatesFilter<"JobReport"> | string
    uploadedById?: StringWithAggregatesFilter<"JobReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobReport"> | Date | string
    status?: StringWithAggregatesFilter<"JobReport"> | string
    aiEstimate?: FloatNullableWithAggregatesFilter<"JobReport"> | number | null
    aiResponse?: StringNullableWithAggregatesFilter<"JobReport"> | string | null
  }

  export type RepairEstimateWhereInput = {
    AND?: RepairEstimateWhereInput | RepairEstimateWhereInput[]
    OR?: RepairEstimateWhereInput[]
    NOT?: RepairEstimateWhereInput | RepairEstimateWhereInput[]
    id?: StringFilter<"RepairEstimate"> | string
    jobId?: StringFilter<"RepairEstimate"> | string
    timeEstimate?: FloatFilter<"RepairEstimate"> | number
    costEstimate?: FloatFilter<"RepairEstimate"> | number
    createdAt?: DateTimeFilter<"RepairEstimate"> | Date | string
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
    feedback?: XOR<FeedbackNullableRelationFilter, FeedbackWhereInput> | null
  }

  export type RepairEstimateOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    timeEstimate?: SortOrder
    costEstimate?: SortOrder
    createdAt?: SortOrder
    job?: JobReportOrderByWithRelationInput
    feedback?: FeedbackOrderByWithRelationInput
  }

  export type RepairEstimateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RepairEstimateWhereInput | RepairEstimateWhereInput[]
    OR?: RepairEstimateWhereInput[]
    NOT?: RepairEstimateWhereInput | RepairEstimateWhereInput[]
    jobId?: StringFilter<"RepairEstimate"> | string
    timeEstimate?: FloatFilter<"RepairEstimate"> | number
    costEstimate?: FloatFilter<"RepairEstimate"> | number
    createdAt?: DateTimeFilter<"RepairEstimate"> | Date | string
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
    feedback?: XOR<FeedbackNullableRelationFilter, FeedbackWhereInput> | null
  }, "id">

  export type RepairEstimateOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    timeEstimate?: SortOrder
    costEstimate?: SortOrder
    createdAt?: SortOrder
    _count?: RepairEstimateCountOrderByAggregateInput
    _avg?: RepairEstimateAvgOrderByAggregateInput
    _max?: RepairEstimateMaxOrderByAggregateInput
    _min?: RepairEstimateMinOrderByAggregateInput
    _sum?: RepairEstimateSumOrderByAggregateInput
  }

  export type RepairEstimateScalarWhereWithAggregatesInput = {
    AND?: RepairEstimateScalarWhereWithAggregatesInput | RepairEstimateScalarWhereWithAggregatesInput[]
    OR?: RepairEstimateScalarWhereWithAggregatesInput[]
    NOT?: RepairEstimateScalarWhereWithAggregatesInput | RepairEstimateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RepairEstimate"> | string
    jobId?: StringWithAggregatesFilter<"RepairEstimate"> | string
    timeEstimate?: FloatWithAggregatesFilter<"RepairEstimate"> | number
    costEstimate?: FloatWithAggregatesFilter<"RepairEstimate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RepairEstimate"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: IntFilter<"Feedback"> | number
    userId?: StringFilter<"Feedback"> | string
    jobId?: StringNullableFilter<"Feedback"> | string | null
    estimateId?: StringNullableFilter<"Feedback"> | string | null
    feedbackType?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    actualHours?: FloatNullableFilter<"Feedback"> | number | null
    experienceScoreSnapshot?: FloatNullableFilter<"Feedback"> | number | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    job?: XOR<JobReportNullableRelationFilter, JobReportWhereInput> | null
    estimate?: XOR<RepairEstimateNullableRelationFilter, RepairEstimateWhereInput> | null
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    estimateId?: SortOrderInput | SortOrder
    feedbackType?: SortOrder
    message?: SortOrder
    actualHours?: SortOrderInput | SortOrder
    experienceScoreSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    job?: JobReportOrderByWithRelationInput
    estimate?: RepairEstimateOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    estimateId?: string
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    userId?: StringFilter<"Feedback"> | string
    jobId?: StringNullableFilter<"Feedback"> | string | null
    feedbackType?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    actualHours?: FloatNullableFilter<"Feedback"> | number | null
    experienceScoreSnapshot?: FloatNullableFilter<"Feedback"> | number | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    job?: XOR<JobReportNullableRelationFilter, JobReportWhereInput> | null
    estimate?: XOR<RepairEstimateNullableRelationFilter, RepairEstimateWhereInput> | null
  }, "id" | "estimateId">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    estimateId?: SortOrderInput | SortOrder
    feedbackType?: SortOrder
    message?: SortOrder
    actualHours?: SortOrderInput | SortOrder
    experienceScoreSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feedback"> | number
    userId?: StringWithAggregatesFilter<"Feedback"> | string
    jobId?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    estimateId?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    feedbackType?: StringWithAggregatesFilter<"Feedback"> | string
    message?: StringWithAggregatesFilter<"Feedback"> | string
    actualHours?: FloatNullableWithAggregatesFilter<"Feedback"> | number | null
    experienceScoreSnapshot?: FloatNullableWithAggregatesFilter<"Feedback"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: StringFilter<"Image"> | string
    jobId?: StringFilter<"Image"> | string
    imagePath?: StringFilter<"Image"> | string
    truckSectionId?: StringNullableFilter<"Image"> | string | null
    severityId?: StringNullableFilter<"Image"> | string | null
    notes?: StringNullableFilter<"Image"> | string | null
    uploadedAt?: DateTimeFilter<"Image"> | Date | string
    truckSection?: XOR<TruckSectionNullableRelationFilter, TruckSectionWhereInput> | null
    vehicleParts?: ImageVehiclePartListRelationFilter
    damageTypes?: ImageDamageTypeListRelationFilter
    severity?: XOR<SeverityLevelNullableRelationFilter, SeverityLevelWhereInput> | null
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    imagePath?: SortOrder
    truckSectionId?: SortOrderInput | SortOrder
    severityId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    truckSection?: TruckSectionOrderByWithRelationInput
    vehicleParts?: ImageVehiclePartOrderByRelationAggregateInput
    damageTypes?: ImageDamageTypeOrderByRelationAggregateInput
    severity?: SeverityLevelOrderByWithRelationInput
    job?: JobReportOrderByWithRelationInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    jobId?: StringFilter<"Image"> | string
    imagePath?: StringFilter<"Image"> | string
    truckSectionId?: StringNullableFilter<"Image"> | string | null
    severityId?: StringNullableFilter<"Image"> | string | null
    notes?: StringNullableFilter<"Image"> | string | null
    uploadedAt?: DateTimeFilter<"Image"> | Date | string
    truckSection?: XOR<TruckSectionNullableRelationFilter, TruckSectionWhereInput> | null
    vehicleParts?: ImageVehiclePartListRelationFilter
    damageTypes?: ImageDamageTypeListRelationFilter
    severity?: XOR<SeverityLevelNullableRelationFilter, SeverityLevelWhereInput> | null
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
  }, "id">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    imagePath?: SortOrder
    truckSectionId?: SortOrderInput | SortOrder
    severityId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Image"> | string
    jobId?: StringWithAggregatesFilter<"Image"> | string
    imagePath?: StringWithAggregatesFilter<"Image"> | string
    truckSectionId?: StringNullableWithAggregatesFilter<"Image"> | string | null
    severityId?: StringNullableWithAggregatesFilter<"Image"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Image"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
  }

  export type DetectedDamageWhereInput = {
    AND?: DetectedDamageWhereInput | DetectedDamageWhereInput[]
    OR?: DetectedDamageWhereInput[]
    NOT?: DetectedDamageWhereInput | DetectedDamageWhereInput[]
    id?: StringFilter<"DetectedDamage"> | string
    jobId?: StringFilter<"DetectedDamage"> | string
    aiOutputJson?: StringFilter<"DetectedDamage"> | string
    generatedAt?: DateTimeFilter<"DetectedDamage"> | Date | string
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
  }

  export type DetectedDamageOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    aiOutputJson?: SortOrder
    generatedAt?: SortOrder
    job?: JobReportOrderByWithRelationInput
  }

  export type DetectedDamageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DetectedDamageWhereInput | DetectedDamageWhereInput[]
    OR?: DetectedDamageWhereInput[]
    NOT?: DetectedDamageWhereInput | DetectedDamageWhereInput[]
    jobId?: StringFilter<"DetectedDamage"> | string
    aiOutputJson?: StringFilter<"DetectedDamage"> | string
    generatedAt?: DateTimeFilter<"DetectedDamage"> | Date | string
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
  }, "id">

  export type DetectedDamageOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    aiOutputJson?: SortOrder
    generatedAt?: SortOrder
    _count?: DetectedDamageCountOrderByAggregateInput
    _max?: DetectedDamageMaxOrderByAggregateInput
    _min?: DetectedDamageMinOrderByAggregateInput
  }

  export type DetectedDamageScalarWhereWithAggregatesInput = {
    AND?: DetectedDamageScalarWhereWithAggregatesInput | DetectedDamageScalarWhereWithAggregatesInput[]
    OR?: DetectedDamageScalarWhereWithAggregatesInput[]
    NOT?: DetectedDamageScalarWhereWithAggregatesInput | DetectedDamageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DetectedDamage"> | string
    jobId?: StringWithAggregatesFilter<"DetectedDamage"> | string
    aiOutputJson?: StringWithAggregatesFilter<"DetectedDamage"> | string
    generatedAt?: DateTimeWithAggregatesFilter<"DetectedDamage"> | Date | string
  }

  export type ActualRepairWhereInput = {
    AND?: ActualRepairWhereInput | ActualRepairWhereInput[]
    OR?: ActualRepairWhereInput[]
    NOT?: ActualRepairWhereInput | ActualRepairWhereInput[]
    id?: StringFilter<"ActualRepair"> | string
    jobId?: StringFilter<"ActualRepair"> | string
    actualHours?: FloatFilter<"ActualRepair"> | number
    notes?: StringNullableFilter<"ActualRepair"> | string | null
    confirmedById?: StringNullableFilter<"ActualRepair"> | string | null
    confirmedAt?: DateTimeFilter<"ActualRepair"> | Date | string
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ActualRepairOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    actualHours?: SortOrder
    notes?: SortOrderInput | SortOrder
    confirmedById?: SortOrderInput | SortOrder
    confirmedAt?: SortOrder
    job?: JobReportOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ActualRepairWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActualRepairWhereInput | ActualRepairWhereInput[]
    OR?: ActualRepairWhereInput[]
    NOT?: ActualRepairWhereInput | ActualRepairWhereInput[]
    jobId?: StringFilter<"ActualRepair"> | string
    actualHours?: FloatFilter<"ActualRepair"> | number
    notes?: StringNullableFilter<"ActualRepair"> | string | null
    confirmedById?: StringNullableFilter<"ActualRepair"> | string | null
    confirmedAt?: DateTimeFilter<"ActualRepair"> | Date | string
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ActualRepairOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    actualHours?: SortOrder
    notes?: SortOrderInput | SortOrder
    confirmedById?: SortOrderInput | SortOrder
    confirmedAt?: SortOrder
    _count?: ActualRepairCountOrderByAggregateInput
    _avg?: ActualRepairAvgOrderByAggregateInput
    _max?: ActualRepairMaxOrderByAggregateInput
    _min?: ActualRepairMinOrderByAggregateInput
    _sum?: ActualRepairSumOrderByAggregateInput
  }

  export type ActualRepairScalarWhereWithAggregatesInput = {
    AND?: ActualRepairScalarWhereWithAggregatesInput | ActualRepairScalarWhereWithAggregatesInput[]
    OR?: ActualRepairScalarWhereWithAggregatesInput[]
    NOT?: ActualRepairScalarWhereWithAggregatesInput | ActualRepairScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActualRepair"> | string
    jobId?: StringWithAggregatesFilter<"ActualRepair"> | string
    actualHours?: FloatWithAggregatesFilter<"ActualRepair"> | number
    notes?: StringNullableWithAggregatesFilter<"ActualRepair"> | string | null
    confirmedById?: StringNullableWithAggregatesFilter<"ActualRepair"> | string | null
    confirmedAt?: DateTimeWithAggregatesFilter<"ActualRepair"> | Date | string
  }

  export type TrainingImageWhereInput = {
    AND?: TrainingImageWhereInput | TrainingImageWhereInput[]
    OR?: TrainingImageWhereInput[]
    NOT?: TrainingImageWhereInput | TrainingImageWhereInput[]
    id?: StringFilter<"TrainingImage"> | string
    imageUrl?: StringFilter<"TrainingImage"> | string
    label?: StringNullableFilter<"TrainingImage"> | string | null
    uploadedAt?: DateTimeFilter<"TrainingImage"> | Date | string
  }

  export type TrainingImageOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    label?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
  }

  export type TrainingImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingImageWhereInput | TrainingImageWhereInput[]
    OR?: TrainingImageWhereInput[]
    NOT?: TrainingImageWhereInput | TrainingImageWhereInput[]
    imageUrl?: StringFilter<"TrainingImage"> | string
    label?: StringNullableFilter<"TrainingImage"> | string | null
    uploadedAt?: DateTimeFilter<"TrainingImage"> | Date | string
  }, "id">

  export type TrainingImageOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    label?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: TrainingImageCountOrderByAggregateInput
    _max?: TrainingImageMaxOrderByAggregateInput
    _min?: TrainingImageMinOrderByAggregateInput
  }

  export type TrainingImageScalarWhereWithAggregatesInput = {
    AND?: TrainingImageScalarWhereWithAggregatesInput | TrainingImageScalarWhereWithAggregatesInput[]
    OR?: TrainingImageScalarWhereWithAggregatesInput[]
    NOT?: TrainingImageScalarWhereWithAggregatesInput | TrainingImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingImage"> | string
    imageUrl?: StringWithAggregatesFilter<"TrainingImage"> | string
    label?: StringNullableWithAggregatesFilter<"TrainingImage"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"TrainingImage"> | Date | string
  }

  export type VINMetadataWhereInput = {
    AND?: VINMetadataWhereInput | VINMetadataWhereInput[]
    OR?: VINMetadataWhereInput[]
    NOT?: VINMetadataWhereInput | VINMetadataWhereInput[]
    id?: StringFilter<"VINMetadata"> | string
    jobId?: StringFilter<"VINMetadata"> | string
    vin?: StringFilter<"VINMetadata"> | string
    make?: StringNullableFilter<"VINMetadata"> | string | null
    model?: StringNullableFilter<"VINMetadata"> | string | null
    year?: IntNullableFilter<"VINMetadata"> | number | null
    engine?: StringNullableFilter<"VINMetadata"> | string | null
    misc?: StringNullableFilter<"VINMetadata"> | string | null
    decodedAt?: DateTimeFilter<"VINMetadata"> | Date | string
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
  }

  export type VINMetadataOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    vin?: SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    engine?: SortOrderInput | SortOrder
    misc?: SortOrderInput | SortOrder
    decodedAt?: SortOrder
    job?: JobReportOrderByWithRelationInput
  }

  export type VINMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VINMetadataWhereInput | VINMetadataWhereInput[]
    OR?: VINMetadataWhereInput[]
    NOT?: VINMetadataWhereInput | VINMetadataWhereInput[]
    jobId?: StringFilter<"VINMetadata"> | string
    vin?: StringFilter<"VINMetadata"> | string
    make?: StringNullableFilter<"VINMetadata"> | string | null
    model?: StringNullableFilter<"VINMetadata"> | string | null
    year?: IntNullableFilter<"VINMetadata"> | number | null
    engine?: StringNullableFilter<"VINMetadata"> | string | null
    misc?: StringNullableFilter<"VINMetadata"> | string | null
    decodedAt?: DateTimeFilter<"VINMetadata"> | Date | string
    job?: XOR<JobReportRelationFilter, JobReportWhereInput>
  }, "id">

  export type VINMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    vin?: SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    engine?: SortOrderInput | SortOrder
    misc?: SortOrderInput | SortOrder
    decodedAt?: SortOrder
    _count?: VINMetadataCountOrderByAggregateInput
    _avg?: VINMetadataAvgOrderByAggregateInput
    _max?: VINMetadataMaxOrderByAggregateInput
    _min?: VINMetadataMinOrderByAggregateInput
    _sum?: VINMetadataSumOrderByAggregateInput
  }

  export type VINMetadataScalarWhereWithAggregatesInput = {
    AND?: VINMetadataScalarWhereWithAggregatesInput | VINMetadataScalarWhereWithAggregatesInput[]
    OR?: VINMetadataScalarWhereWithAggregatesInput[]
    NOT?: VINMetadataScalarWhereWithAggregatesInput | VINMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VINMetadata"> | string
    jobId?: StringWithAggregatesFilter<"VINMetadata"> | string
    vin?: StringWithAggregatesFilter<"VINMetadata"> | string
    make?: StringNullableWithAggregatesFilter<"VINMetadata"> | string | null
    model?: StringNullableWithAggregatesFilter<"VINMetadata"> | string | null
    year?: IntNullableWithAggregatesFilter<"VINMetadata"> | number | null
    engine?: StringNullableWithAggregatesFilter<"VINMetadata"> | string | null
    misc?: StringNullableWithAggregatesFilter<"VINMetadata"> | string | null
    decodedAt?: DateTimeWithAggregatesFilter<"VINMetadata"> | Date | string
  }

  export type TruckSectionWhereInput = {
    AND?: TruckSectionWhereInput | TruckSectionWhereInput[]
    OR?: TruckSectionWhereInput[]
    NOT?: TruckSectionWhereInput | TruckSectionWhereInput[]
    id?: StringFilter<"TruckSection"> | string
    name?: StringFilter<"TruckSection"> | string
    vehicleParts?: VehiclePartListRelationFilter
    images?: ImageListRelationFilter
  }

  export type TruckSectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    vehicleParts?: VehiclePartOrderByRelationAggregateInput
    images?: ImageOrderByRelationAggregateInput
  }

  export type TruckSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TruckSectionWhereInput | TruckSectionWhereInput[]
    OR?: TruckSectionWhereInput[]
    NOT?: TruckSectionWhereInput | TruckSectionWhereInput[]
    vehicleParts?: VehiclePartListRelationFilter
    images?: ImageListRelationFilter
  }, "id" | "name">

  export type TruckSectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TruckSectionCountOrderByAggregateInput
    _max?: TruckSectionMaxOrderByAggregateInput
    _min?: TruckSectionMinOrderByAggregateInput
  }

  export type TruckSectionScalarWhereWithAggregatesInput = {
    AND?: TruckSectionScalarWhereWithAggregatesInput | TruckSectionScalarWhereWithAggregatesInput[]
    OR?: TruckSectionScalarWhereWithAggregatesInput[]
    NOT?: TruckSectionScalarWhereWithAggregatesInput | TruckSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TruckSection"> | string
    name?: StringWithAggregatesFilter<"TruckSection"> | string
  }

  export type VehiclePartWhereInput = {
    AND?: VehiclePartWhereInput | VehiclePartWhereInput[]
    OR?: VehiclePartWhereInput[]
    NOT?: VehiclePartWhereInput | VehiclePartWhereInput[]
    id?: StringFilter<"VehiclePart"> | string
    name?: StringFilter<"VehiclePart"> | string
    truckSectionId?: StringFilter<"VehiclePart"> | string
    truckSection?: XOR<TruckSectionRelationFilter, TruckSectionWhereInput>
    images?: ImageVehiclePartListRelationFilter
  }

  export type VehiclePartOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    truckSectionId?: SortOrder
    truckSection?: TruckSectionOrderByWithRelationInput
    images?: ImageVehiclePartOrderByRelationAggregateInput
  }

  export type VehiclePartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: VehiclePartWhereInput | VehiclePartWhereInput[]
    OR?: VehiclePartWhereInput[]
    NOT?: VehiclePartWhereInput | VehiclePartWhereInput[]
    truckSectionId?: StringFilter<"VehiclePart"> | string
    truckSection?: XOR<TruckSectionRelationFilter, TruckSectionWhereInput>
    images?: ImageVehiclePartListRelationFilter
  }, "id" | "name">

  export type VehiclePartOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    truckSectionId?: SortOrder
    _count?: VehiclePartCountOrderByAggregateInput
    _max?: VehiclePartMaxOrderByAggregateInput
    _min?: VehiclePartMinOrderByAggregateInput
  }

  export type VehiclePartScalarWhereWithAggregatesInput = {
    AND?: VehiclePartScalarWhereWithAggregatesInput | VehiclePartScalarWhereWithAggregatesInput[]
    OR?: VehiclePartScalarWhereWithAggregatesInput[]
    NOT?: VehiclePartScalarWhereWithAggregatesInput | VehiclePartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VehiclePart"> | string
    name?: StringWithAggregatesFilter<"VehiclePart"> | string
    truckSectionId?: StringWithAggregatesFilter<"VehiclePart"> | string
  }

  export type DamageTypeWhereInput = {
    AND?: DamageTypeWhereInput | DamageTypeWhereInput[]
    OR?: DamageTypeWhereInput[]
    NOT?: DamageTypeWhereInput | DamageTypeWhereInput[]
    id?: StringFilter<"DamageType"> | string
    name?: StringFilter<"DamageType"> | string
    images?: ImageDamageTypeListRelationFilter
  }

  export type DamageTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    images?: ImageDamageTypeOrderByRelationAggregateInput
  }

  export type DamageTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DamageTypeWhereInput | DamageTypeWhereInput[]
    OR?: DamageTypeWhereInput[]
    NOT?: DamageTypeWhereInput | DamageTypeWhereInput[]
    images?: ImageDamageTypeListRelationFilter
  }, "id" | "name">

  export type DamageTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DamageTypeCountOrderByAggregateInput
    _max?: DamageTypeMaxOrderByAggregateInput
    _min?: DamageTypeMinOrderByAggregateInput
  }

  export type DamageTypeScalarWhereWithAggregatesInput = {
    AND?: DamageTypeScalarWhereWithAggregatesInput | DamageTypeScalarWhereWithAggregatesInput[]
    OR?: DamageTypeScalarWhereWithAggregatesInput[]
    NOT?: DamageTypeScalarWhereWithAggregatesInput | DamageTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DamageType"> | string
    name?: StringWithAggregatesFilter<"DamageType"> | string
  }

  export type SeverityLevelWhereInput = {
    AND?: SeverityLevelWhereInput | SeverityLevelWhereInput[]
    OR?: SeverityLevelWhereInput[]
    NOT?: SeverityLevelWhereInput | SeverityLevelWhereInput[]
    id?: StringFilter<"SeverityLevel"> | string
    name?: StringFilter<"SeverityLevel"> | string
    images?: ImageListRelationFilter
  }

  export type SeverityLevelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    images?: ImageOrderByRelationAggregateInput
  }

  export type SeverityLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SeverityLevelWhereInput | SeverityLevelWhereInput[]
    OR?: SeverityLevelWhereInput[]
    NOT?: SeverityLevelWhereInput | SeverityLevelWhereInput[]
    images?: ImageListRelationFilter
  }, "id" | "name">

  export type SeverityLevelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: SeverityLevelCountOrderByAggregateInput
    _max?: SeverityLevelMaxOrderByAggregateInput
    _min?: SeverityLevelMinOrderByAggregateInput
  }

  export type SeverityLevelScalarWhereWithAggregatesInput = {
    AND?: SeverityLevelScalarWhereWithAggregatesInput | SeverityLevelScalarWhereWithAggregatesInput[]
    OR?: SeverityLevelScalarWhereWithAggregatesInput[]
    NOT?: SeverityLevelScalarWhereWithAggregatesInput | SeverityLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SeverityLevel"> | string
    name?: StringWithAggregatesFilter<"SeverityLevel"> | string
  }

  export type ImageVehiclePartWhereInput = {
    AND?: ImageVehiclePartWhereInput | ImageVehiclePartWhereInput[]
    OR?: ImageVehiclePartWhereInput[]
    NOT?: ImageVehiclePartWhereInput | ImageVehiclePartWhereInput[]
    imageId?: StringFilter<"ImageVehiclePart"> | string
    vehiclePartId?: StringFilter<"ImageVehiclePart"> | string
    image?: XOR<ImageRelationFilter, ImageWhereInput>
    vehiclePart?: XOR<VehiclePartRelationFilter, VehiclePartWhereInput>
  }

  export type ImageVehiclePartOrderByWithRelationInput = {
    imageId?: SortOrder
    vehiclePartId?: SortOrder
    image?: ImageOrderByWithRelationInput
    vehiclePart?: VehiclePartOrderByWithRelationInput
  }

  export type ImageVehiclePartWhereUniqueInput = Prisma.AtLeast<{
    imageId_vehiclePartId?: ImageVehiclePartImageIdVehiclePartIdCompoundUniqueInput
    AND?: ImageVehiclePartWhereInput | ImageVehiclePartWhereInput[]
    OR?: ImageVehiclePartWhereInput[]
    NOT?: ImageVehiclePartWhereInput | ImageVehiclePartWhereInput[]
    imageId?: StringFilter<"ImageVehiclePart"> | string
    vehiclePartId?: StringFilter<"ImageVehiclePart"> | string
    image?: XOR<ImageRelationFilter, ImageWhereInput>
    vehiclePart?: XOR<VehiclePartRelationFilter, VehiclePartWhereInput>
  }, "imageId_vehiclePartId">

  export type ImageVehiclePartOrderByWithAggregationInput = {
    imageId?: SortOrder
    vehiclePartId?: SortOrder
    _count?: ImageVehiclePartCountOrderByAggregateInput
    _max?: ImageVehiclePartMaxOrderByAggregateInput
    _min?: ImageVehiclePartMinOrderByAggregateInput
  }

  export type ImageVehiclePartScalarWhereWithAggregatesInput = {
    AND?: ImageVehiclePartScalarWhereWithAggregatesInput | ImageVehiclePartScalarWhereWithAggregatesInput[]
    OR?: ImageVehiclePartScalarWhereWithAggregatesInput[]
    NOT?: ImageVehiclePartScalarWhereWithAggregatesInput | ImageVehiclePartScalarWhereWithAggregatesInput[]
    imageId?: StringWithAggregatesFilter<"ImageVehiclePart"> | string
    vehiclePartId?: StringWithAggregatesFilter<"ImageVehiclePart"> | string
  }

  export type ImageDamageTypeWhereInput = {
    AND?: ImageDamageTypeWhereInput | ImageDamageTypeWhereInput[]
    OR?: ImageDamageTypeWhereInput[]
    NOT?: ImageDamageTypeWhereInput | ImageDamageTypeWhereInput[]
    imageId?: StringFilter<"ImageDamageType"> | string
    damageTypeId?: StringFilter<"ImageDamageType"> | string
    image?: XOR<ImageRelationFilter, ImageWhereInput>
    damageType?: XOR<DamageTypeRelationFilter, DamageTypeWhereInput>
  }

  export type ImageDamageTypeOrderByWithRelationInput = {
    imageId?: SortOrder
    damageTypeId?: SortOrder
    image?: ImageOrderByWithRelationInput
    damageType?: DamageTypeOrderByWithRelationInput
  }

  export type ImageDamageTypeWhereUniqueInput = Prisma.AtLeast<{
    imageId_damageTypeId?: ImageDamageTypeImageIdDamageTypeIdCompoundUniqueInput
    AND?: ImageDamageTypeWhereInput | ImageDamageTypeWhereInput[]
    OR?: ImageDamageTypeWhereInput[]
    NOT?: ImageDamageTypeWhereInput | ImageDamageTypeWhereInput[]
    imageId?: StringFilter<"ImageDamageType"> | string
    damageTypeId?: StringFilter<"ImageDamageType"> | string
    image?: XOR<ImageRelationFilter, ImageWhereInput>
    damageType?: XOR<DamageTypeRelationFilter, DamageTypeWhereInput>
  }, "imageId_damageTypeId">

  export type ImageDamageTypeOrderByWithAggregationInput = {
    imageId?: SortOrder
    damageTypeId?: SortOrder
    _count?: ImageDamageTypeCountOrderByAggregateInput
    _max?: ImageDamageTypeMaxOrderByAggregateInput
    _min?: ImageDamageTypeMinOrderByAggregateInput
  }

  export type ImageDamageTypeScalarWhereWithAggregatesInput = {
    AND?: ImageDamageTypeScalarWhereWithAggregatesInput | ImageDamageTypeScalarWhereWithAggregatesInput[]
    OR?: ImageDamageTypeScalarWhereWithAggregatesInput[]
    NOT?: ImageDamageTypeScalarWhereWithAggregatesInput | ImageDamageTypeScalarWhereWithAggregatesInput[]
    imageId?: StringWithAggregatesFilter<"ImageDamageType"> | string
    damageTypeId?: StringWithAggregatesFilter<"ImageDamageType"> | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type VehicleReferenceImageWhereInput = {
    AND?: VehicleReferenceImageWhereInput | VehicleReferenceImageWhereInput[]
    OR?: VehicleReferenceImageWhereInput[]
    NOT?: VehicleReferenceImageWhereInput | VehicleReferenceImageWhereInput[]
    id?: StringFilter<"VehicleReferenceImage"> | string
    imageUrl?: StringFilter<"VehicleReferenceImage"> | string
    angle?: StringNullableFilter<"VehicleReferenceImage"> | string | null
    vehicleVin?: StringFilter<"VehicleReferenceImage"> | string
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }

  export type VehicleReferenceImageOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    angle?: SortOrderInput | SortOrder
    vehicleVin?: SortOrder
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type VehicleReferenceImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VehicleReferenceImageWhereInput | VehicleReferenceImageWhereInput[]
    OR?: VehicleReferenceImageWhereInput[]
    NOT?: VehicleReferenceImageWhereInput | VehicleReferenceImageWhereInput[]
    imageUrl?: StringFilter<"VehicleReferenceImage"> | string
    angle?: StringNullableFilter<"VehicleReferenceImage"> | string | null
    vehicleVin?: StringFilter<"VehicleReferenceImage"> | string
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }, "id">

  export type VehicleReferenceImageOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    angle?: SortOrderInput | SortOrder
    vehicleVin?: SortOrder
    _count?: VehicleReferenceImageCountOrderByAggregateInput
    _max?: VehicleReferenceImageMaxOrderByAggregateInput
    _min?: VehicleReferenceImageMinOrderByAggregateInput
  }

  export type VehicleReferenceImageScalarWhereWithAggregatesInput = {
    AND?: VehicleReferenceImageScalarWhereWithAggregatesInput | VehicleReferenceImageScalarWhereWithAggregatesInput[]
    OR?: VehicleReferenceImageScalarWhereWithAggregatesInput[]
    NOT?: VehicleReferenceImageScalarWhereWithAggregatesInput | VehicleReferenceImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VehicleReferenceImage"> | string
    imageUrl?: StringWithAggregatesFilter<"VehicleReferenceImage"> | string
    angle?: StringNullableWithAggregatesFilter<"VehicleReferenceImage"> | string | null
    vehicleVin?: StringWithAggregatesFilter<"VehicleReferenceImage"> | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    jobs?: JobReportCreateNestedManyWithoutUserInput
    confirmedRepairs?: ActualRepairCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    jobs?: JobReportUncheckedCreateNestedManyWithoutUserInput
    confirmedRepairs?: ActualRepairUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    jobs?: JobReportUpdateManyWithoutUserNestedInput
    confirmedRepairs?: ActualRepairUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    jobs?: JobReportUncheckedUpdateManyWithoutUserNestedInput
    confirmedRepairs?: ActualRepairUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleCreateInput = {
    id?: string
    vin: string
    type?: string | null
    make?: string | null
    model?: string | null
    year?: number | null
    weightClass?: string | null
    owner?: string | null
    notes?: string | null
    createdAt?: Date | string
    bodyClass?: string | null
    driveType?: string | null
    engineModel?: string | null
    engineCylinders?: number | null
    engineDisplacementL?: number | null
    fuelTypePrimary?: string | null
    brakeSystemType?: string | null
    manufacturerName?: string | null
    plantCity?: string | null
    plantState?: string | null
    plantCountry?: string | null
    trim?: string | null
    series?: string | null
    steeringLocation?: string | null
    transmissionStyle?: string | null
    vehicleType?: string | null
    gvwr?: string | null
    doors?: string | null
    wheels?: string | null
    entertainmentSystem?: string | null
    abs?: string | null
    airbagLocations?: string | null
    electronicStabilityControl?: string | null
    basePrice?: string | null
    bedLength?: string | null
    cabType?: string | null
    jobs?: JobReportCreateNestedManyWithoutVehicleInput
    referenceImages?: VehicleReferenceImageCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: string
    vin: string
    type?: string | null
    make?: string | null
    model?: string | null
    year?: number | null
    weightClass?: string | null
    owner?: string | null
    notes?: string | null
    createdAt?: Date | string
    bodyClass?: string | null
    driveType?: string | null
    engineModel?: string | null
    engineCylinders?: number | null
    engineDisplacementL?: number | null
    fuelTypePrimary?: string | null
    brakeSystemType?: string | null
    manufacturerName?: string | null
    plantCity?: string | null
    plantState?: string | null
    plantCountry?: string | null
    trim?: string | null
    series?: string | null
    steeringLocation?: string | null
    transmissionStyle?: string | null
    vehicleType?: string | null
    gvwr?: string | null
    doors?: string | null
    wheels?: string | null
    entertainmentSystem?: string | null
    abs?: string | null
    airbagLocations?: string | null
    electronicStabilityControl?: string | null
    basePrice?: string | null
    bedLength?: string | null
    cabType?: string | null
    jobs?: JobReportUncheckedCreateNestedManyWithoutVehicleInput
    referenceImages?: VehicleReferenceImageUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    weightClass?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyClass?: NullableStringFieldUpdateOperationsInput | string | null
    driveType?: NullableStringFieldUpdateOperationsInput | string | null
    engineModel?: NullableStringFieldUpdateOperationsInput | string | null
    engineCylinders?: NullableIntFieldUpdateOperationsInput | number | null
    engineDisplacementL?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelTypePrimary?: NullableStringFieldUpdateOperationsInput | string | null
    brakeSystemType?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturerName?: NullableStringFieldUpdateOperationsInput | string | null
    plantCity?: NullableStringFieldUpdateOperationsInput | string | null
    plantState?: NullableStringFieldUpdateOperationsInput | string | null
    plantCountry?: NullableStringFieldUpdateOperationsInput | string | null
    trim?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    steeringLocation?: NullableStringFieldUpdateOperationsInput | string | null
    transmissionStyle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    gvwr?: NullableStringFieldUpdateOperationsInput | string | null
    doors?: NullableStringFieldUpdateOperationsInput | string | null
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    entertainmentSystem?: NullableStringFieldUpdateOperationsInput | string | null
    abs?: NullableStringFieldUpdateOperationsInput | string | null
    airbagLocations?: NullableStringFieldUpdateOperationsInput | string | null
    electronicStabilityControl?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    bedLength?: NullableStringFieldUpdateOperationsInput | string | null
    cabType?: NullableStringFieldUpdateOperationsInput | string | null
    jobs?: JobReportUpdateManyWithoutVehicleNestedInput
    referenceImages?: VehicleReferenceImageUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    weightClass?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyClass?: NullableStringFieldUpdateOperationsInput | string | null
    driveType?: NullableStringFieldUpdateOperationsInput | string | null
    engineModel?: NullableStringFieldUpdateOperationsInput | string | null
    engineCylinders?: NullableIntFieldUpdateOperationsInput | number | null
    engineDisplacementL?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelTypePrimary?: NullableStringFieldUpdateOperationsInput | string | null
    brakeSystemType?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturerName?: NullableStringFieldUpdateOperationsInput | string | null
    plantCity?: NullableStringFieldUpdateOperationsInput | string | null
    plantState?: NullableStringFieldUpdateOperationsInput | string | null
    plantCountry?: NullableStringFieldUpdateOperationsInput | string | null
    trim?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    steeringLocation?: NullableStringFieldUpdateOperationsInput | string | null
    transmissionStyle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    gvwr?: NullableStringFieldUpdateOperationsInput | string | null
    doors?: NullableStringFieldUpdateOperationsInput | string | null
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    entertainmentSystem?: NullableStringFieldUpdateOperationsInput | string | null
    abs?: NullableStringFieldUpdateOperationsInput | string | null
    airbagLocations?: NullableStringFieldUpdateOperationsInput | string | null
    electronicStabilityControl?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    bedLength?: NullableStringFieldUpdateOperationsInput | string | null
    cabType?: NullableStringFieldUpdateOperationsInput | string | null
    jobs?: JobReportUncheckedUpdateManyWithoutVehicleNestedInput
    referenceImages?: VehicleReferenceImageUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: string
    vin: string
    type?: string | null
    make?: string | null
    model?: string | null
    year?: number | null
    weightClass?: string | null
    owner?: string | null
    notes?: string | null
    createdAt?: Date | string
    bodyClass?: string | null
    driveType?: string | null
    engineModel?: string | null
    engineCylinders?: number | null
    engineDisplacementL?: number | null
    fuelTypePrimary?: string | null
    brakeSystemType?: string | null
    manufacturerName?: string | null
    plantCity?: string | null
    plantState?: string | null
    plantCountry?: string | null
    trim?: string | null
    series?: string | null
    steeringLocation?: string | null
    transmissionStyle?: string | null
    vehicleType?: string | null
    gvwr?: string | null
    doors?: string | null
    wheels?: string | null
    entertainmentSystem?: string | null
    abs?: string | null
    airbagLocations?: string | null
    electronicStabilityControl?: string | null
    basePrice?: string | null
    bedLength?: string | null
    cabType?: string | null
  }

  export type VehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    weightClass?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyClass?: NullableStringFieldUpdateOperationsInput | string | null
    driveType?: NullableStringFieldUpdateOperationsInput | string | null
    engineModel?: NullableStringFieldUpdateOperationsInput | string | null
    engineCylinders?: NullableIntFieldUpdateOperationsInput | number | null
    engineDisplacementL?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelTypePrimary?: NullableStringFieldUpdateOperationsInput | string | null
    brakeSystemType?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturerName?: NullableStringFieldUpdateOperationsInput | string | null
    plantCity?: NullableStringFieldUpdateOperationsInput | string | null
    plantState?: NullableStringFieldUpdateOperationsInput | string | null
    plantCountry?: NullableStringFieldUpdateOperationsInput | string | null
    trim?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    steeringLocation?: NullableStringFieldUpdateOperationsInput | string | null
    transmissionStyle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    gvwr?: NullableStringFieldUpdateOperationsInput | string | null
    doors?: NullableStringFieldUpdateOperationsInput | string | null
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    entertainmentSystem?: NullableStringFieldUpdateOperationsInput | string | null
    abs?: NullableStringFieldUpdateOperationsInput | string | null
    airbagLocations?: NullableStringFieldUpdateOperationsInput | string | null
    electronicStabilityControl?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    bedLength?: NullableStringFieldUpdateOperationsInput | string | null
    cabType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    weightClass?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyClass?: NullableStringFieldUpdateOperationsInput | string | null
    driveType?: NullableStringFieldUpdateOperationsInput | string | null
    engineModel?: NullableStringFieldUpdateOperationsInput | string | null
    engineCylinders?: NullableIntFieldUpdateOperationsInput | number | null
    engineDisplacementL?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelTypePrimary?: NullableStringFieldUpdateOperationsInput | string | null
    brakeSystemType?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturerName?: NullableStringFieldUpdateOperationsInput | string | null
    plantCity?: NullableStringFieldUpdateOperationsInput | string | null
    plantState?: NullableStringFieldUpdateOperationsInput | string | null
    plantCountry?: NullableStringFieldUpdateOperationsInput | string | null
    trim?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    steeringLocation?: NullableStringFieldUpdateOperationsInput | string | null
    transmissionStyle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    gvwr?: NullableStringFieldUpdateOperationsInput | string | null
    doors?: NullableStringFieldUpdateOperationsInput | string | null
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    entertainmentSystem?: NullableStringFieldUpdateOperationsInput | string | null
    abs?: NullableStringFieldUpdateOperationsInput | string | null
    airbagLocations?: NullableStringFieldUpdateOperationsInput | string | null
    electronicStabilityControl?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    bedLength?: NullableStringFieldUpdateOperationsInput | string | null
    cabType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobReportCreateInput = {
    id?: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    user: UserCreateNestedOneWithoutJobsInput
    vehicle: VehicleCreateNestedOneWithoutJobsInput
    images?: ImageCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataCreateNestedManyWithoutJobInput
  }

  export type JobReportUncheckedCreateInput = {
    id?: string
    vin: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    images?: ImageUncheckedCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageUncheckedCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateUncheckedCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairUncheckedCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutJobsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutJobsNestedInput
    images?: ImageUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageUncheckedUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUncheckedUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUncheckedUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUncheckedUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobReportCreateManyInput = {
    id?: string
    vin: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
  }

  export type JobReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairEstimateCreateInput = {
    id?: string
    timeEstimate: number
    costEstimate: number
    createdAt?: Date | string
    job: JobReportCreateNestedOneWithoutRepairEstimatesInput
    feedback?: FeedbackCreateNestedOneWithoutEstimateInput
  }

  export type RepairEstimateUncheckedCreateInput = {
    id?: string
    jobId: string
    timeEstimate: number
    costEstimate: number
    createdAt?: Date | string
    feedback?: FeedbackUncheckedCreateNestedOneWithoutEstimateInput
  }

  export type RepairEstimateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeEstimate?: FloatFieldUpdateOperationsInput | number
    costEstimate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobReportUpdateOneRequiredWithoutRepairEstimatesNestedInput
    feedback?: FeedbackUpdateOneWithoutEstimateNestedInput
  }

  export type RepairEstimateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timeEstimate?: FloatFieldUpdateOperationsInput | number
    costEstimate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateOneWithoutEstimateNestedInput
  }

  export type RepairEstimateCreateManyInput = {
    id?: string
    jobId: string
    timeEstimate: number
    costEstimate: number
    createdAt?: Date | string
  }

  export type RepairEstimateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeEstimate?: FloatFieldUpdateOperationsInput | number
    costEstimate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairEstimateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timeEstimate?: FloatFieldUpdateOperationsInput | number
    costEstimate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbacksInput
    job?: JobReportCreateNestedOneWithoutFeedbacksInput
    estimate?: RepairEstimateCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: number
    userId: string
    jobId?: string | null
    estimateId?: string | null
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateInput = {
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
    job?: JobReportUpdateOneWithoutFeedbacksNestedInput
    estimate?: RepairEstimateUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    estimateId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyInput = {
    id?: number
    userId: string
    jobId?: string | null
    estimateId?: string | null
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    estimateId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateInput = {
    id?: string
    imagePath: string
    notes?: string | null
    uploadedAt?: Date | string
    truckSection?: TruckSectionCreateNestedOneWithoutImagesInput
    vehicleParts?: ImageVehiclePartCreateNestedManyWithoutImageInput
    damageTypes?: ImageDamageTypeCreateNestedManyWithoutImageInput
    severity?: SeverityLevelCreateNestedOneWithoutImagesInput
    job: JobReportCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateInput = {
    id?: string
    jobId: string
    imagePath: string
    truckSectionId?: string | null
    severityId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
    vehicleParts?: ImageVehiclePartUncheckedCreateNestedManyWithoutImageInput
    damageTypes?: ImageDamageTypeUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    truckSection?: TruckSectionUpdateOneWithoutImagesNestedInput
    vehicleParts?: ImageVehiclePartUpdateManyWithoutImageNestedInput
    damageTypes?: ImageDamageTypeUpdateManyWithoutImageNestedInput
    severity?: SeverityLevelUpdateOneWithoutImagesNestedInput
    job?: JobReportUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    truckSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    severityId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleParts?: ImageVehiclePartUncheckedUpdateManyWithoutImageNestedInput
    damageTypes?: ImageDamageTypeUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageCreateManyInput = {
    id?: string
    jobId: string
    imagePath: string
    truckSectionId?: string | null
    severityId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
  }

  export type ImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    truckSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    severityId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedDamageCreateInput = {
    id?: string
    aiOutputJson: string
    generatedAt?: Date | string
    job: JobReportCreateNestedOneWithoutDetectedDamagesInput
  }

  export type DetectedDamageUncheckedCreateInput = {
    id?: string
    jobId: string
    aiOutputJson: string
    generatedAt?: Date | string
  }

  export type DetectedDamageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiOutputJson?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobReportUpdateOneRequiredWithoutDetectedDamagesNestedInput
  }

  export type DetectedDamageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    aiOutputJson?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedDamageCreateManyInput = {
    id?: string
    jobId: string
    aiOutputJson: string
    generatedAt?: Date | string
  }

  export type DetectedDamageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiOutputJson?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedDamageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    aiOutputJson?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualRepairCreateInput = {
    id?: string
    actualHours: number
    notes?: string | null
    confirmedAt?: Date | string
    job: JobReportCreateNestedOneWithoutActualRepairsInput
    user?: UserCreateNestedOneWithoutConfirmedRepairsInput
  }

  export type ActualRepairUncheckedCreateInput = {
    id?: string
    jobId: string
    actualHours: number
    notes?: string | null
    confirmedById?: string | null
    confirmedAt?: Date | string
  }

  export type ActualRepairUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobReportUpdateOneRequiredWithoutActualRepairsNestedInput
    user?: UserUpdateOneWithoutConfirmedRepairsNestedInput
  }

  export type ActualRepairUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedById?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualRepairCreateManyInput = {
    id?: string
    jobId: string
    actualHours: number
    notes?: string | null
    confirmedById?: string | null
    confirmedAt?: Date | string
  }

  export type ActualRepairUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualRepairUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedById?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingImageCreateInput = {
    id?: string
    imageUrl: string
    label?: string | null
    uploadedAt?: Date | string
  }

  export type TrainingImageUncheckedCreateInput = {
    id?: string
    imageUrl: string
    label?: string | null
    uploadedAt?: Date | string
  }

  export type TrainingImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingImageCreateManyInput = {
    id?: string
    imageUrl: string
    label?: string | null
    uploadedAt?: Date | string
  }

  export type TrainingImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VINMetadataCreateInput = {
    id?: string
    vin: string
    make?: string | null
    model?: string | null
    year?: number | null
    engine?: string | null
    misc?: string | null
    decodedAt?: Date | string
    job: JobReportCreateNestedOneWithoutVinMetadataInput
  }

  export type VINMetadataUncheckedCreateInput = {
    id?: string
    jobId: string
    vin: string
    make?: string | null
    model?: string | null
    year?: number | null
    engine?: string | null
    misc?: string | null
    decodedAt?: Date | string
  }

  export type VINMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    misc?: NullableStringFieldUpdateOperationsInput | string | null
    decodedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobReportUpdateOneRequiredWithoutVinMetadataNestedInput
  }

  export type VINMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    misc?: NullableStringFieldUpdateOperationsInput | string | null
    decodedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VINMetadataCreateManyInput = {
    id?: string
    jobId: string
    vin: string
    make?: string | null
    model?: string | null
    year?: number | null
    engine?: string | null
    misc?: string | null
    decodedAt?: Date | string
  }

  export type VINMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    misc?: NullableStringFieldUpdateOperationsInput | string | null
    decodedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VINMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    misc?: NullableStringFieldUpdateOperationsInput | string | null
    decodedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TruckSectionCreateInput = {
    id?: string
    name: string
    vehicleParts?: VehiclePartCreateNestedManyWithoutTruckSectionInput
    images?: ImageCreateNestedManyWithoutTruckSectionInput
  }

  export type TruckSectionUncheckedCreateInput = {
    id?: string
    name: string
    vehicleParts?: VehiclePartUncheckedCreateNestedManyWithoutTruckSectionInput
    images?: ImageUncheckedCreateNestedManyWithoutTruckSectionInput
  }

  export type TruckSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vehicleParts?: VehiclePartUpdateManyWithoutTruckSectionNestedInput
    images?: ImageUpdateManyWithoutTruckSectionNestedInput
  }

  export type TruckSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vehicleParts?: VehiclePartUncheckedUpdateManyWithoutTruckSectionNestedInput
    images?: ImageUncheckedUpdateManyWithoutTruckSectionNestedInput
  }

  export type TruckSectionCreateManyInput = {
    id?: string
    name: string
  }

  export type TruckSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TruckSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VehiclePartCreateInput = {
    id?: string
    name: string
    truckSection: TruckSectionCreateNestedOneWithoutVehiclePartsInput
    images?: ImageVehiclePartCreateNestedManyWithoutVehiclePartInput
  }

  export type VehiclePartUncheckedCreateInput = {
    id?: string
    name: string
    truckSectionId: string
    images?: ImageVehiclePartUncheckedCreateNestedManyWithoutVehiclePartInput
  }

  export type VehiclePartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    truckSection?: TruckSectionUpdateOneRequiredWithoutVehiclePartsNestedInput
    images?: ImageVehiclePartUpdateManyWithoutVehiclePartNestedInput
  }

  export type VehiclePartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    truckSectionId?: StringFieldUpdateOperationsInput | string
    images?: ImageVehiclePartUncheckedUpdateManyWithoutVehiclePartNestedInput
  }

  export type VehiclePartCreateManyInput = {
    id?: string
    name: string
    truckSectionId: string
  }

  export type VehiclePartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VehiclePartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    truckSectionId?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeCreateInput = {
    id?: string
    name: string
    images?: ImageDamageTypeCreateNestedManyWithoutDamageTypeInput
  }

  export type DamageTypeUncheckedCreateInput = {
    id?: string
    name: string
    images?: ImageDamageTypeUncheckedCreateNestedManyWithoutDamageTypeInput
  }

  export type DamageTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: ImageDamageTypeUpdateManyWithoutDamageTypeNestedInput
  }

  export type DamageTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: ImageDamageTypeUncheckedUpdateManyWithoutDamageTypeNestedInput
  }

  export type DamageTypeCreateManyInput = {
    id?: string
    name: string
  }

  export type DamageTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SeverityLevelCreateInput = {
    id?: string
    name: string
    images?: ImageCreateNestedManyWithoutSeverityInput
  }

  export type SeverityLevelUncheckedCreateInput = {
    id?: string
    name: string
    images?: ImageUncheckedCreateNestedManyWithoutSeverityInput
  }

  export type SeverityLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: ImageUpdateManyWithoutSeverityNestedInput
  }

  export type SeverityLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: ImageUncheckedUpdateManyWithoutSeverityNestedInput
  }

  export type SeverityLevelCreateManyInput = {
    id?: string
    name: string
  }

  export type SeverityLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SeverityLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ImageVehiclePartCreateInput = {
    image: ImageCreateNestedOneWithoutVehiclePartsInput
    vehiclePart: VehiclePartCreateNestedOneWithoutImagesInput
  }

  export type ImageVehiclePartUncheckedCreateInput = {
    imageId: string
    vehiclePartId: string
  }

  export type ImageVehiclePartUpdateInput = {
    image?: ImageUpdateOneRequiredWithoutVehiclePartsNestedInput
    vehiclePart?: VehiclePartUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageVehiclePartUncheckedUpdateInput = {
    imageId?: StringFieldUpdateOperationsInput | string
    vehiclePartId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageVehiclePartCreateManyInput = {
    imageId: string
    vehiclePartId: string
  }

  export type ImageVehiclePartUpdateManyMutationInput = {

  }

  export type ImageVehiclePartUncheckedUpdateManyInput = {
    imageId?: StringFieldUpdateOperationsInput | string
    vehiclePartId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageDamageTypeCreateInput = {
    image: ImageCreateNestedOneWithoutDamageTypesInput
    damageType: DamageTypeCreateNestedOneWithoutImagesInput
  }

  export type ImageDamageTypeUncheckedCreateInput = {
    imageId: string
    damageTypeId: string
  }

  export type ImageDamageTypeUpdateInput = {
    image?: ImageUpdateOneRequiredWithoutDamageTypesNestedInput
    damageType?: DamageTypeUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageDamageTypeUncheckedUpdateInput = {
    imageId?: StringFieldUpdateOperationsInput | string
    damageTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageDamageTypeCreateManyInput = {
    imageId: string
    damageTypeId: string
  }

  export type ImageDamageTypeUpdateManyMutationInput = {

  }

  export type ImageDamageTypeUncheckedUpdateManyInput = {
    imageId?: StringFieldUpdateOperationsInput | string
    damageTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleReferenceImageCreateInput = {
    id?: string
    imageUrl: string
    angle?: string | null
    vehicle: VehicleCreateNestedOneWithoutReferenceImagesInput
  }

  export type VehicleReferenceImageUncheckedCreateInput = {
    id?: string
    imageUrl: string
    angle?: string | null
    vehicleVin: string
  }

  export type VehicleReferenceImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle?: VehicleUpdateOneRequiredWithoutReferenceImagesNestedInput
  }

  export type VehicleReferenceImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleVin?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleReferenceImageCreateManyInput = {
    id?: string
    imageUrl: string
    angle?: string | null
    vehicleVin: string
  }

  export type VehicleReferenceImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    angle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleReferenceImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    angle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleVin?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type JobReportListRelationFilter = {
    every?: JobReportWhereInput
    some?: JobReportWhereInput
    none?: JobReportWhereInput
  }

  export type ActualRepairListRelationFilter = {
    every?: ActualRepairWhereInput
    some?: ActualRepairWhereInput
    none?: ActualRepairWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type JobReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActualRepairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    experienceLevel?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    experienceLevel?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    experienceLevel?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    experienceLevel?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    experienceLevel?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VehicleReferenceImageListRelationFilter = {
    every?: VehicleReferenceImageWhereInput
    some?: VehicleReferenceImageWhereInput
    none?: VehicleReferenceImageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VehicleReferenceImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    vin?: SortOrder
    type?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    weightClass?: SortOrder
    owner?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    bodyClass?: SortOrder
    driveType?: SortOrder
    engineModel?: SortOrder
    engineCylinders?: SortOrder
    engineDisplacementL?: SortOrder
    fuelTypePrimary?: SortOrder
    brakeSystemType?: SortOrder
    manufacturerName?: SortOrder
    plantCity?: SortOrder
    plantState?: SortOrder
    plantCountry?: SortOrder
    trim?: SortOrder
    series?: SortOrder
    steeringLocation?: SortOrder
    transmissionStyle?: SortOrder
    vehicleType?: SortOrder
    gvwr?: SortOrder
    doors?: SortOrder
    wheels?: SortOrder
    entertainmentSystem?: SortOrder
    abs?: SortOrder
    airbagLocations?: SortOrder
    electronicStabilityControl?: SortOrder
    basePrice?: SortOrder
    bedLength?: SortOrder
    cabType?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    year?: SortOrder
    engineCylinders?: SortOrder
    engineDisplacementL?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    vin?: SortOrder
    type?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    weightClass?: SortOrder
    owner?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    bodyClass?: SortOrder
    driveType?: SortOrder
    engineModel?: SortOrder
    engineCylinders?: SortOrder
    engineDisplacementL?: SortOrder
    fuelTypePrimary?: SortOrder
    brakeSystemType?: SortOrder
    manufacturerName?: SortOrder
    plantCity?: SortOrder
    plantState?: SortOrder
    plantCountry?: SortOrder
    trim?: SortOrder
    series?: SortOrder
    steeringLocation?: SortOrder
    transmissionStyle?: SortOrder
    vehicleType?: SortOrder
    gvwr?: SortOrder
    doors?: SortOrder
    wheels?: SortOrder
    entertainmentSystem?: SortOrder
    abs?: SortOrder
    airbagLocations?: SortOrder
    electronicStabilityControl?: SortOrder
    basePrice?: SortOrder
    bedLength?: SortOrder
    cabType?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    vin?: SortOrder
    type?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    weightClass?: SortOrder
    owner?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    bodyClass?: SortOrder
    driveType?: SortOrder
    engineModel?: SortOrder
    engineCylinders?: SortOrder
    engineDisplacementL?: SortOrder
    fuelTypePrimary?: SortOrder
    brakeSystemType?: SortOrder
    manufacturerName?: SortOrder
    plantCity?: SortOrder
    plantState?: SortOrder
    plantCountry?: SortOrder
    trim?: SortOrder
    series?: SortOrder
    steeringLocation?: SortOrder
    transmissionStyle?: SortOrder
    vehicleType?: SortOrder
    gvwr?: SortOrder
    doors?: SortOrder
    wheels?: SortOrder
    entertainmentSystem?: SortOrder
    abs?: SortOrder
    airbagLocations?: SortOrder
    electronicStabilityControl?: SortOrder
    basePrice?: SortOrder
    bedLength?: SortOrder
    cabType?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    year?: SortOrder
    engineCylinders?: SortOrder
    engineDisplacementL?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VehicleRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type DetectedDamageListRelationFilter = {
    every?: DetectedDamageWhereInput
    some?: DetectedDamageWhereInput
    none?: DetectedDamageWhereInput
  }

  export type RepairEstimateListRelationFilter = {
    every?: RepairEstimateWhereInput
    some?: RepairEstimateWhereInput
    none?: RepairEstimateWhereInput
  }

  export type VINMetadataListRelationFilter = {
    every?: VINMetadataWhereInput
    some?: VINMetadataWhereInput
    none?: VINMetadataWhereInput
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DetectedDamageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepairEstimateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VINMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobReportCountOrderByAggregateInput = {
    id?: SortOrder
    vin?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    aiEstimate?: SortOrder
    aiResponse?: SortOrder
  }

  export type JobReportAvgOrderByAggregateInput = {
    aiEstimate?: SortOrder
  }

  export type JobReportMaxOrderByAggregateInput = {
    id?: SortOrder
    vin?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    aiEstimate?: SortOrder
    aiResponse?: SortOrder
  }

  export type JobReportMinOrderByAggregateInput = {
    id?: SortOrder
    vin?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    aiEstimate?: SortOrder
    aiResponse?: SortOrder
  }

  export type JobReportSumOrderByAggregateInput = {
    aiEstimate?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type JobReportRelationFilter = {
    is?: JobReportWhereInput
    isNot?: JobReportWhereInput
  }

  export type FeedbackNullableRelationFilter = {
    is?: FeedbackWhereInput | null
    isNot?: FeedbackWhereInput | null
  }

  export type RepairEstimateCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    timeEstimate?: SortOrder
    costEstimate?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairEstimateAvgOrderByAggregateInput = {
    timeEstimate?: SortOrder
    costEstimate?: SortOrder
  }

  export type RepairEstimateMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    timeEstimate?: SortOrder
    costEstimate?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairEstimateMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    timeEstimate?: SortOrder
    costEstimate?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairEstimateSumOrderByAggregateInput = {
    timeEstimate?: SortOrder
    costEstimate?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type JobReportNullableRelationFilter = {
    is?: JobReportWhereInput | null
    isNot?: JobReportWhereInput | null
  }

  export type RepairEstimateNullableRelationFilter = {
    is?: RepairEstimateWhereInput | null
    isNot?: RepairEstimateWhereInput | null
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    estimateId?: SortOrder
    feedbackType?: SortOrder
    message?: SortOrder
    actualHours?: SortOrder
    experienceScoreSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    actualHours?: SortOrder
    experienceScoreSnapshot?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    estimateId?: SortOrder
    feedbackType?: SortOrder
    message?: SortOrder
    actualHours?: SortOrder
    experienceScoreSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    estimateId?: SortOrder
    feedbackType?: SortOrder
    message?: SortOrder
    actualHours?: SortOrder
    experienceScoreSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    actualHours?: SortOrder
    experienceScoreSnapshot?: SortOrder
  }

  export type TruckSectionNullableRelationFilter = {
    is?: TruckSectionWhereInput | null
    isNot?: TruckSectionWhereInput | null
  }

  export type ImageVehiclePartListRelationFilter = {
    every?: ImageVehiclePartWhereInput
    some?: ImageVehiclePartWhereInput
    none?: ImageVehiclePartWhereInput
  }

  export type ImageDamageTypeListRelationFilter = {
    every?: ImageDamageTypeWhereInput
    some?: ImageDamageTypeWhereInput
    none?: ImageDamageTypeWhereInput
  }

  export type SeverityLevelNullableRelationFilter = {
    is?: SeverityLevelWhereInput | null
    isNot?: SeverityLevelWhereInput | null
  }

  export type ImageVehiclePartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageDamageTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    imagePath?: SortOrder
    truckSectionId?: SortOrder
    severityId?: SortOrder
    notes?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    imagePath?: SortOrder
    truckSectionId?: SortOrder
    severityId?: SortOrder
    notes?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    imagePath?: SortOrder
    truckSectionId?: SortOrder
    severityId?: SortOrder
    notes?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DetectedDamageCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    aiOutputJson?: SortOrder
    generatedAt?: SortOrder
  }

  export type DetectedDamageMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    aiOutputJson?: SortOrder
    generatedAt?: SortOrder
  }

  export type DetectedDamageMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    aiOutputJson?: SortOrder
    generatedAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ActualRepairCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    actualHours?: SortOrder
    notes?: SortOrder
    confirmedById?: SortOrder
    confirmedAt?: SortOrder
  }

  export type ActualRepairAvgOrderByAggregateInput = {
    actualHours?: SortOrder
  }

  export type ActualRepairMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    actualHours?: SortOrder
    notes?: SortOrder
    confirmedById?: SortOrder
    confirmedAt?: SortOrder
  }

  export type ActualRepairMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    actualHours?: SortOrder
    notes?: SortOrder
    confirmedById?: SortOrder
    confirmedAt?: SortOrder
  }

  export type ActualRepairSumOrderByAggregateInput = {
    actualHours?: SortOrder
  }

  export type TrainingImageCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    label?: SortOrder
    uploadedAt?: SortOrder
  }

  export type TrainingImageMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    label?: SortOrder
    uploadedAt?: SortOrder
  }

  export type TrainingImageMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    label?: SortOrder
    uploadedAt?: SortOrder
  }

  export type VINMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    vin?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    engine?: SortOrder
    misc?: SortOrder
    decodedAt?: SortOrder
  }

  export type VINMetadataAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type VINMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    vin?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    engine?: SortOrder
    misc?: SortOrder
    decodedAt?: SortOrder
  }

  export type VINMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    vin?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    engine?: SortOrder
    misc?: SortOrder
    decodedAt?: SortOrder
  }

  export type VINMetadataSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type VehiclePartListRelationFilter = {
    every?: VehiclePartWhereInput
    some?: VehiclePartWhereInput
    none?: VehiclePartWhereInput
  }

  export type VehiclePartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TruckSectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TruckSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TruckSectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TruckSectionRelationFilter = {
    is?: TruckSectionWhereInput
    isNot?: TruckSectionWhereInput
  }

  export type VehiclePartCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    truckSectionId?: SortOrder
  }

  export type VehiclePartMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    truckSectionId?: SortOrder
  }

  export type VehiclePartMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    truckSectionId?: SortOrder
  }

  export type DamageTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DamageTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DamageTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SeverityLevelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SeverityLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SeverityLevelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ImageRelationFilter = {
    is?: ImageWhereInput
    isNot?: ImageWhereInput
  }

  export type VehiclePartRelationFilter = {
    is?: VehiclePartWhereInput
    isNot?: VehiclePartWhereInput
  }

  export type ImageVehiclePartImageIdVehiclePartIdCompoundUniqueInput = {
    imageId: string
    vehiclePartId: string
  }

  export type ImageVehiclePartCountOrderByAggregateInput = {
    imageId?: SortOrder
    vehiclePartId?: SortOrder
  }

  export type ImageVehiclePartMaxOrderByAggregateInput = {
    imageId?: SortOrder
    vehiclePartId?: SortOrder
  }

  export type ImageVehiclePartMinOrderByAggregateInput = {
    imageId?: SortOrder
    vehiclePartId?: SortOrder
  }

  export type DamageTypeRelationFilter = {
    is?: DamageTypeWhereInput
    isNot?: DamageTypeWhereInput
  }

  export type ImageDamageTypeImageIdDamageTypeIdCompoundUniqueInput = {
    imageId: string
    damageTypeId: string
  }

  export type ImageDamageTypeCountOrderByAggregateInput = {
    imageId?: SortOrder
    damageTypeId?: SortOrder
  }

  export type ImageDamageTypeMaxOrderByAggregateInput = {
    imageId?: SortOrder
    damageTypeId?: SortOrder
  }

  export type ImageDamageTypeMinOrderByAggregateInput = {
    imageId?: SortOrder
    damageTypeId?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
  }

  export type VehicleReferenceImageCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    angle?: SortOrder
    vehicleVin?: SortOrder
  }

  export type VehicleReferenceImageMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    angle?: SortOrder
    vehicleVin?: SortOrder
  }

  export type VehicleReferenceImageMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    angle?: SortOrder
    vehicleVin?: SortOrder
  }

  export type JobReportCreateNestedManyWithoutUserInput = {
    create?: XOR<JobReportCreateWithoutUserInput, JobReportUncheckedCreateWithoutUserInput> | JobReportCreateWithoutUserInput[] | JobReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobReportCreateOrConnectWithoutUserInput | JobReportCreateOrConnectWithoutUserInput[]
    createMany?: JobReportCreateManyUserInputEnvelope
    connect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
  }

  export type ActualRepairCreateNestedManyWithoutUserInput = {
    create?: XOR<ActualRepairCreateWithoutUserInput, ActualRepairUncheckedCreateWithoutUserInput> | ActualRepairCreateWithoutUserInput[] | ActualRepairUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActualRepairCreateOrConnectWithoutUserInput | ActualRepairCreateOrConnectWithoutUserInput[]
    createMany?: ActualRepairCreateManyUserInputEnvelope
    connect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type JobReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JobReportCreateWithoutUserInput, JobReportUncheckedCreateWithoutUserInput> | JobReportCreateWithoutUserInput[] | JobReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobReportCreateOrConnectWithoutUserInput | JobReportCreateOrConnectWithoutUserInput[]
    createMany?: JobReportCreateManyUserInputEnvelope
    connect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
  }

  export type ActualRepairUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActualRepairCreateWithoutUserInput, ActualRepairUncheckedCreateWithoutUserInput> | ActualRepairCreateWithoutUserInput[] | ActualRepairUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActualRepairCreateOrConnectWithoutUserInput | ActualRepairCreateOrConnectWithoutUserInput[]
    createMany?: ActualRepairCreateManyUserInputEnvelope
    connect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobReportCreateWithoutUserInput, JobReportUncheckedCreateWithoutUserInput> | JobReportCreateWithoutUserInput[] | JobReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobReportCreateOrConnectWithoutUserInput | JobReportCreateOrConnectWithoutUserInput[]
    upsert?: JobReportUpsertWithWhereUniqueWithoutUserInput | JobReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobReportCreateManyUserInputEnvelope
    set?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    disconnect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    delete?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    connect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    update?: JobReportUpdateWithWhereUniqueWithoutUserInput | JobReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobReportUpdateManyWithWhereWithoutUserInput | JobReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobReportScalarWhereInput | JobReportScalarWhereInput[]
  }

  export type ActualRepairUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActualRepairCreateWithoutUserInput, ActualRepairUncheckedCreateWithoutUserInput> | ActualRepairCreateWithoutUserInput[] | ActualRepairUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActualRepairCreateOrConnectWithoutUserInput | ActualRepairCreateOrConnectWithoutUserInput[]
    upsert?: ActualRepairUpsertWithWhereUniqueWithoutUserInput | ActualRepairUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActualRepairCreateManyUserInputEnvelope
    set?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    disconnect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    delete?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    connect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    update?: ActualRepairUpdateWithWhereUniqueWithoutUserInput | ActualRepairUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActualRepairUpdateManyWithWhereWithoutUserInput | ActualRepairUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActualRepairScalarWhereInput | ActualRepairScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type JobReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobReportCreateWithoutUserInput, JobReportUncheckedCreateWithoutUserInput> | JobReportCreateWithoutUserInput[] | JobReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobReportCreateOrConnectWithoutUserInput | JobReportCreateOrConnectWithoutUserInput[]
    upsert?: JobReportUpsertWithWhereUniqueWithoutUserInput | JobReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobReportCreateManyUserInputEnvelope
    set?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    disconnect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    delete?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    connect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    update?: JobReportUpdateWithWhereUniqueWithoutUserInput | JobReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobReportUpdateManyWithWhereWithoutUserInput | JobReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobReportScalarWhereInput | JobReportScalarWhereInput[]
  }

  export type ActualRepairUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActualRepairCreateWithoutUserInput, ActualRepairUncheckedCreateWithoutUserInput> | ActualRepairCreateWithoutUserInput[] | ActualRepairUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActualRepairCreateOrConnectWithoutUserInput | ActualRepairCreateOrConnectWithoutUserInput[]
    upsert?: ActualRepairUpsertWithWhereUniqueWithoutUserInput | ActualRepairUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActualRepairCreateManyUserInputEnvelope
    set?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    disconnect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    delete?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    connect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    update?: ActualRepairUpdateWithWhereUniqueWithoutUserInput | ActualRepairUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActualRepairUpdateManyWithWhereWithoutUserInput | ActualRepairUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActualRepairScalarWhereInput | ActualRepairScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type JobReportCreateNestedManyWithoutVehicleInput = {
    create?: XOR<JobReportCreateWithoutVehicleInput, JobReportUncheckedCreateWithoutVehicleInput> | JobReportCreateWithoutVehicleInput[] | JobReportUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: JobReportCreateOrConnectWithoutVehicleInput | JobReportCreateOrConnectWithoutVehicleInput[]
    createMany?: JobReportCreateManyVehicleInputEnvelope
    connect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
  }

  export type VehicleReferenceImageCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleReferenceImageCreateWithoutVehicleInput, VehicleReferenceImageUncheckedCreateWithoutVehicleInput> | VehicleReferenceImageCreateWithoutVehicleInput[] | VehicleReferenceImageUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleReferenceImageCreateOrConnectWithoutVehicleInput | VehicleReferenceImageCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleReferenceImageCreateManyVehicleInputEnvelope
    connect?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
  }

  export type JobReportUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<JobReportCreateWithoutVehicleInput, JobReportUncheckedCreateWithoutVehicleInput> | JobReportCreateWithoutVehicleInput[] | JobReportUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: JobReportCreateOrConnectWithoutVehicleInput | JobReportCreateOrConnectWithoutVehicleInput[]
    createMany?: JobReportCreateManyVehicleInputEnvelope
    connect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
  }

  export type VehicleReferenceImageUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleReferenceImageCreateWithoutVehicleInput, VehicleReferenceImageUncheckedCreateWithoutVehicleInput> | VehicleReferenceImageCreateWithoutVehicleInput[] | VehicleReferenceImageUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleReferenceImageCreateOrConnectWithoutVehicleInput | VehicleReferenceImageCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleReferenceImageCreateManyVehicleInputEnvelope
    connect?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobReportUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<JobReportCreateWithoutVehicleInput, JobReportUncheckedCreateWithoutVehicleInput> | JobReportCreateWithoutVehicleInput[] | JobReportUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: JobReportCreateOrConnectWithoutVehicleInput | JobReportCreateOrConnectWithoutVehicleInput[]
    upsert?: JobReportUpsertWithWhereUniqueWithoutVehicleInput | JobReportUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: JobReportCreateManyVehicleInputEnvelope
    set?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    disconnect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    delete?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    connect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    update?: JobReportUpdateWithWhereUniqueWithoutVehicleInput | JobReportUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: JobReportUpdateManyWithWhereWithoutVehicleInput | JobReportUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: JobReportScalarWhereInput | JobReportScalarWhereInput[]
  }

  export type VehicleReferenceImageUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleReferenceImageCreateWithoutVehicleInput, VehicleReferenceImageUncheckedCreateWithoutVehicleInput> | VehicleReferenceImageCreateWithoutVehicleInput[] | VehicleReferenceImageUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleReferenceImageCreateOrConnectWithoutVehicleInput | VehicleReferenceImageCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleReferenceImageUpsertWithWhereUniqueWithoutVehicleInput | VehicleReferenceImageUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleReferenceImageCreateManyVehicleInputEnvelope
    set?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
    disconnect?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
    delete?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
    connect?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
    update?: VehicleReferenceImageUpdateWithWhereUniqueWithoutVehicleInput | VehicleReferenceImageUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleReferenceImageUpdateManyWithWhereWithoutVehicleInput | VehicleReferenceImageUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleReferenceImageScalarWhereInput | VehicleReferenceImageScalarWhereInput[]
  }

  export type JobReportUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<JobReportCreateWithoutVehicleInput, JobReportUncheckedCreateWithoutVehicleInput> | JobReportCreateWithoutVehicleInput[] | JobReportUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: JobReportCreateOrConnectWithoutVehicleInput | JobReportCreateOrConnectWithoutVehicleInput[]
    upsert?: JobReportUpsertWithWhereUniqueWithoutVehicleInput | JobReportUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: JobReportCreateManyVehicleInputEnvelope
    set?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    disconnect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    delete?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    connect?: JobReportWhereUniqueInput | JobReportWhereUniqueInput[]
    update?: JobReportUpdateWithWhereUniqueWithoutVehicleInput | JobReportUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: JobReportUpdateManyWithWhereWithoutVehicleInput | JobReportUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: JobReportScalarWhereInput | JobReportScalarWhereInput[]
  }

  export type VehicleReferenceImageUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleReferenceImageCreateWithoutVehicleInput, VehicleReferenceImageUncheckedCreateWithoutVehicleInput> | VehicleReferenceImageCreateWithoutVehicleInput[] | VehicleReferenceImageUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleReferenceImageCreateOrConnectWithoutVehicleInput | VehicleReferenceImageCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleReferenceImageUpsertWithWhereUniqueWithoutVehicleInput | VehicleReferenceImageUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleReferenceImageCreateManyVehicleInputEnvelope
    set?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
    disconnect?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
    delete?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
    connect?: VehicleReferenceImageWhereUniqueInput | VehicleReferenceImageWhereUniqueInput[]
    update?: VehicleReferenceImageUpdateWithWhereUniqueWithoutVehicleInput | VehicleReferenceImageUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleReferenceImageUpdateManyWithWhereWithoutVehicleInput | VehicleReferenceImageUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleReferenceImageScalarWhereInput | VehicleReferenceImageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutJobsInput = {
    create?: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsInput
    connect?: UserWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutJobsInput = {
    create?: XOR<VehicleCreateWithoutJobsInput, VehicleUncheckedCreateWithoutJobsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutJobsInput
    connect?: VehicleWhereUniqueInput
  }

  export type ImageCreateNestedManyWithoutJobInput = {
    create?: XOR<ImageCreateWithoutJobInput, ImageUncheckedCreateWithoutJobInput> | ImageCreateWithoutJobInput[] | ImageUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutJobInput | ImageCreateOrConnectWithoutJobInput[]
    createMany?: ImageCreateManyJobInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type DetectedDamageCreateNestedManyWithoutJobInput = {
    create?: XOR<DetectedDamageCreateWithoutJobInput, DetectedDamageUncheckedCreateWithoutJobInput> | DetectedDamageCreateWithoutJobInput[] | DetectedDamageUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DetectedDamageCreateOrConnectWithoutJobInput | DetectedDamageCreateOrConnectWithoutJobInput[]
    createMany?: DetectedDamageCreateManyJobInputEnvelope
    connect?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
  }

  export type RepairEstimateCreateNestedManyWithoutJobInput = {
    create?: XOR<RepairEstimateCreateWithoutJobInput, RepairEstimateUncheckedCreateWithoutJobInput> | RepairEstimateCreateWithoutJobInput[] | RepairEstimateUncheckedCreateWithoutJobInput[]
    connectOrCreate?: RepairEstimateCreateOrConnectWithoutJobInput | RepairEstimateCreateOrConnectWithoutJobInput[]
    createMany?: RepairEstimateCreateManyJobInputEnvelope
    connect?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
  }

  export type ActualRepairCreateNestedManyWithoutJobInput = {
    create?: XOR<ActualRepairCreateWithoutJobInput, ActualRepairUncheckedCreateWithoutJobInput> | ActualRepairCreateWithoutJobInput[] | ActualRepairUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ActualRepairCreateOrConnectWithoutJobInput | ActualRepairCreateOrConnectWithoutJobInput[]
    createMany?: ActualRepairCreateManyJobInputEnvelope
    connect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutJobInput = {
    create?: XOR<FeedbackCreateWithoutJobInput, FeedbackUncheckedCreateWithoutJobInput> | FeedbackCreateWithoutJobInput[] | FeedbackUncheckedCreateWithoutJobInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutJobInput | FeedbackCreateOrConnectWithoutJobInput[]
    createMany?: FeedbackCreateManyJobInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type VINMetadataCreateNestedManyWithoutJobInput = {
    create?: XOR<VINMetadataCreateWithoutJobInput, VINMetadataUncheckedCreateWithoutJobInput> | VINMetadataCreateWithoutJobInput[] | VINMetadataUncheckedCreateWithoutJobInput[]
    connectOrCreate?: VINMetadataCreateOrConnectWithoutJobInput | VINMetadataCreateOrConnectWithoutJobInput[]
    createMany?: VINMetadataCreateManyJobInputEnvelope
    connect?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<ImageCreateWithoutJobInput, ImageUncheckedCreateWithoutJobInput> | ImageCreateWithoutJobInput[] | ImageUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutJobInput | ImageCreateOrConnectWithoutJobInput[]
    createMany?: ImageCreateManyJobInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type DetectedDamageUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<DetectedDamageCreateWithoutJobInput, DetectedDamageUncheckedCreateWithoutJobInput> | DetectedDamageCreateWithoutJobInput[] | DetectedDamageUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DetectedDamageCreateOrConnectWithoutJobInput | DetectedDamageCreateOrConnectWithoutJobInput[]
    createMany?: DetectedDamageCreateManyJobInputEnvelope
    connect?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
  }

  export type RepairEstimateUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<RepairEstimateCreateWithoutJobInput, RepairEstimateUncheckedCreateWithoutJobInput> | RepairEstimateCreateWithoutJobInput[] | RepairEstimateUncheckedCreateWithoutJobInput[]
    connectOrCreate?: RepairEstimateCreateOrConnectWithoutJobInput | RepairEstimateCreateOrConnectWithoutJobInput[]
    createMany?: RepairEstimateCreateManyJobInputEnvelope
    connect?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
  }

  export type ActualRepairUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<ActualRepairCreateWithoutJobInput, ActualRepairUncheckedCreateWithoutJobInput> | ActualRepairCreateWithoutJobInput[] | ActualRepairUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ActualRepairCreateOrConnectWithoutJobInput | ActualRepairCreateOrConnectWithoutJobInput[]
    createMany?: ActualRepairCreateManyJobInputEnvelope
    connect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<FeedbackCreateWithoutJobInput, FeedbackUncheckedCreateWithoutJobInput> | FeedbackCreateWithoutJobInput[] | FeedbackUncheckedCreateWithoutJobInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutJobInput | FeedbackCreateOrConnectWithoutJobInput[]
    createMany?: FeedbackCreateManyJobInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type VINMetadataUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<VINMetadataCreateWithoutJobInput, VINMetadataUncheckedCreateWithoutJobInput> | VINMetadataCreateWithoutJobInput[] | VINMetadataUncheckedCreateWithoutJobInput[]
    connectOrCreate?: VINMetadataCreateOrConnectWithoutJobInput | VINMetadataCreateOrConnectWithoutJobInput[]
    createMany?: VINMetadataCreateManyJobInputEnvelope
    connect?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsInput
    upsert?: UserUpsertWithoutJobsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobsInput, UserUpdateWithoutJobsInput>, UserUncheckedUpdateWithoutJobsInput>
  }

  export type VehicleUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<VehicleCreateWithoutJobsInput, VehicleUncheckedCreateWithoutJobsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutJobsInput
    upsert?: VehicleUpsertWithoutJobsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutJobsInput, VehicleUpdateWithoutJobsInput>, VehicleUncheckedUpdateWithoutJobsInput>
  }

  export type ImageUpdateManyWithoutJobNestedInput = {
    create?: XOR<ImageCreateWithoutJobInput, ImageUncheckedCreateWithoutJobInput> | ImageCreateWithoutJobInput[] | ImageUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutJobInput | ImageCreateOrConnectWithoutJobInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutJobInput | ImageUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ImageCreateManyJobInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutJobInput | ImageUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutJobInput | ImageUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type DetectedDamageUpdateManyWithoutJobNestedInput = {
    create?: XOR<DetectedDamageCreateWithoutJobInput, DetectedDamageUncheckedCreateWithoutJobInput> | DetectedDamageCreateWithoutJobInput[] | DetectedDamageUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DetectedDamageCreateOrConnectWithoutJobInput | DetectedDamageCreateOrConnectWithoutJobInput[]
    upsert?: DetectedDamageUpsertWithWhereUniqueWithoutJobInput | DetectedDamageUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: DetectedDamageCreateManyJobInputEnvelope
    set?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
    disconnect?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
    delete?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
    connect?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
    update?: DetectedDamageUpdateWithWhereUniqueWithoutJobInput | DetectedDamageUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: DetectedDamageUpdateManyWithWhereWithoutJobInput | DetectedDamageUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: DetectedDamageScalarWhereInput | DetectedDamageScalarWhereInput[]
  }

  export type RepairEstimateUpdateManyWithoutJobNestedInput = {
    create?: XOR<RepairEstimateCreateWithoutJobInput, RepairEstimateUncheckedCreateWithoutJobInput> | RepairEstimateCreateWithoutJobInput[] | RepairEstimateUncheckedCreateWithoutJobInput[]
    connectOrCreate?: RepairEstimateCreateOrConnectWithoutJobInput | RepairEstimateCreateOrConnectWithoutJobInput[]
    upsert?: RepairEstimateUpsertWithWhereUniqueWithoutJobInput | RepairEstimateUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: RepairEstimateCreateManyJobInputEnvelope
    set?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
    disconnect?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
    delete?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
    connect?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
    update?: RepairEstimateUpdateWithWhereUniqueWithoutJobInput | RepairEstimateUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: RepairEstimateUpdateManyWithWhereWithoutJobInput | RepairEstimateUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: RepairEstimateScalarWhereInput | RepairEstimateScalarWhereInput[]
  }

  export type ActualRepairUpdateManyWithoutJobNestedInput = {
    create?: XOR<ActualRepairCreateWithoutJobInput, ActualRepairUncheckedCreateWithoutJobInput> | ActualRepairCreateWithoutJobInput[] | ActualRepairUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ActualRepairCreateOrConnectWithoutJobInput | ActualRepairCreateOrConnectWithoutJobInput[]
    upsert?: ActualRepairUpsertWithWhereUniqueWithoutJobInput | ActualRepairUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ActualRepairCreateManyJobInputEnvelope
    set?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    disconnect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    delete?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    connect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    update?: ActualRepairUpdateWithWhereUniqueWithoutJobInput | ActualRepairUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ActualRepairUpdateManyWithWhereWithoutJobInput | ActualRepairUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ActualRepairScalarWhereInput | ActualRepairScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutJobNestedInput = {
    create?: XOR<FeedbackCreateWithoutJobInput, FeedbackUncheckedCreateWithoutJobInput> | FeedbackCreateWithoutJobInput[] | FeedbackUncheckedCreateWithoutJobInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutJobInput | FeedbackCreateOrConnectWithoutJobInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutJobInput | FeedbackUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: FeedbackCreateManyJobInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutJobInput | FeedbackUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutJobInput | FeedbackUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type VINMetadataUpdateManyWithoutJobNestedInput = {
    create?: XOR<VINMetadataCreateWithoutJobInput, VINMetadataUncheckedCreateWithoutJobInput> | VINMetadataCreateWithoutJobInput[] | VINMetadataUncheckedCreateWithoutJobInput[]
    connectOrCreate?: VINMetadataCreateOrConnectWithoutJobInput | VINMetadataCreateOrConnectWithoutJobInput[]
    upsert?: VINMetadataUpsertWithWhereUniqueWithoutJobInput | VINMetadataUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: VINMetadataCreateManyJobInputEnvelope
    set?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
    disconnect?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
    delete?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
    connect?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
    update?: VINMetadataUpdateWithWhereUniqueWithoutJobInput | VINMetadataUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: VINMetadataUpdateManyWithWhereWithoutJobInput | VINMetadataUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: VINMetadataScalarWhereInput | VINMetadataScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<ImageCreateWithoutJobInput, ImageUncheckedCreateWithoutJobInput> | ImageCreateWithoutJobInput[] | ImageUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutJobInput | ImageCreateOrConnectWithoutJobInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutJobInput | ImageUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ImageCreateManyJobInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutJobInput | ImageUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutJobInput | ImageUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type DetectedDamageUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<DetectedDamageCreateWithoutJobInput, DetectedDamageUncheckedCreateWithoutJobInput> | DetectedDamageCreateWithoutJobInput[] | DetectedDamageUncheckedCreateWithoutJobInput[]
    connectOrCreate?: DetectedDamageCreateOrConnectWithoutJobInput | DetectedDamageCreateOrConnectWithoutJobInput[]
    upsert?: DetectedDamageUpsertWithWhereUniqueWithoutJobInput | DetectedDamageUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: DetectedDamageCreateManyJobInputEnvelope
    set?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
    disconnect?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
    delete?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
    connect?: DetectedDamageWhereUniqueInput | DetectedDamageWhereUniqueInput[]
    update?: DetectedDamageUpdateWithWhereUniqueWithoutJobInput | DetectedDamageUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: DetectedDamageUpdateManyWithWhereWithoutJobInput | DetectedDamageUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: DetectedDamageScalarWhereInput | DetectedDamageScalarWhereInput[]
  }

  export type RepairEstimateUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<RepairEstimateCreateWithoutJobInput, RepairEstimateUncheckedCreateWithoutJobInput> | RepairEstimateCreateWithoutJobInput[] | RepairEstimateUncheckedCreateWithoutJobInput[]
    connectOrCreate?: RepairEstimateCreateOrConnectWithoutJobInput | RepairEstimateCreateOrConnectWithoutJobInput[]
    upsert?: RepairEstimateUpsertWithWhereUniqueWithoutJobInput | RepairEstimateUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: RepairEstimateCreateManyJobInputEnvelope
    set?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
    disconnect?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
    delete?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
    connect?: RepairEstimateWhereUniqueInput | RepairEstimateWhereUniqueInput[]
    update?: RepairEstimateUpdateWithWhereUniqueWithoutJobInput | RepairEstimateUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: RepairEstimateUpdateManyWithWhereWithoutJobInput | RepairEstimateUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: RepairEstimateScalarWhereInput | RepairEstimateScalarWhereInput[]
  }

  export type ActualRepairUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<ActualRepairCreateWithoutJobInput, ActualRepairUncheckedCreateWithoutJobInput> | ActualRepairCreateWithoutJobInput[] | ActualRepairUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ActualRepairCreateOrConnectWithoutJobInput | ActualRepairCreateOrConnectWithoutJobInput[]
    upsert?: ActualRepairUpsertWithWhereUniqueWithoutJobInput | ActualRepairUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ActualRepairCreateManyJobInputEnvelope
    set?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    disconnect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    delete?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    connect?: ActualRepairWhereUniqueInput | ActualRepairWhereUniqueInput[]
    update?: ActualRepairUpdateWithWhereUniqueWithoutJobInput | ActualRepairUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ActualRepairUpdateManyWithWhereWithoutJobInput | ActualRepairUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ActualRepairScalarWhereInput | ActualRepairScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<FeedbackCreateWithoutJobInput, FeedbackUncheckedCreateWithoutJobInput> | FeedbackCreateWithoutJobInput[] | FeedbackUncheckedCreateWithoutJobInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutJobInput | FeedbackCreateOrConnectWithoutJobInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutJobInput | FeedbackUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: FeedbackCreateManyJobInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutJobInput | FeedbackUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutJobInput | FeedbackUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type VINMetadataUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<VINMetadataCreateWithoutJobInput, VINMetadataUncheckedCreateWithoutJobInput> | VINMetadataCreateWithoutJobInput[] | VINMetadataUncheckedCreateWithoutJobInput[]
    connectOrCreate?: VINMetadataCreateOrConnectWithoutJobInput | VINMetadataCreateOrConnectWithoutJobInput[]
    upsert?: VINMetadataUpsertWithWhereUniqueWithoutJobInput | VINMetadataUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: VINMetadataCreateManyJobInputEnvelope
    set?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
    disconnect?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
    delete?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
    connect?: VINMetadataWhereUniqueInput | VINMetadataWhereUniqueInput[]
    update?: VINMetadataUpdateWithWhereUniqueWithoutJobInput | VINMetadataUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: VINMetadataUpdateManyWithWhereWithoutJobInput | VINMetadataUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: VINMetadataScalarWhereInput | VINMetadataScalarWhereInput[]
  }

  export type JobReportCreateNestedOneWithoutRepairEstimatesInput = {
    create?: XOR<JobReportCreateWithoutRepairEstimatesInput, JobReportUncheckedCreateWithoutRepairEstimatesInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutRepairEstimatesInput
    connect?: JobReportWhereUniqueInput
  }

  export type FeedbackCreateNestedOneWithoutEstimateInput = {
    create?: XOR<FeedbackCreateWithoutEstimateInput, FeedbackUncheckedCreateWithoutEstimateInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutEstimateInput
    connect?: FeedbackWhereUniqueInput
  }

  export type FeedbackUncheckedCreateNestedOneWithoutEstimateInput = {
    create?: XOR<FeedbackCreateWithoutEstimateInput, FeedbackUncheckedCreateWithoutEstimateInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutEstimateInput
    connect?: FeedbackWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobReportUpdateOneRequiredWithoutRepairEstimatesNestedInput = {
    create?: XOR<JobReportCreateWithoutRepairEstimatesInput, JobReportUncheckedCreateWithoutRepairEstimatesInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutRepairEstimatesInput
    upsert?: JobReportUpsertWithoutRepairEstimatesInput
    connect?: JobReportWhereUniqueInput
    update?: XOR<XOR<JobReportUpdateToOneWithWhereWithoutRepairEstimatesInput, JobReportUpdateWithoutRepairEstimatesInput>, JobReportUncheckedUpdateWithoutRepairEstimatesInput>
  }

  export type FeedbackUpdateOneWithoutEstimateNestedInput = {
    create?: XOR<FeedbackCreateWithoutEstimateInput, FeedbackUncheckedCreateWithoutEstimateInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutEstimateInput
    upsert?: FeedbackUpsertWithoutEstimateInput
    disconnect?: FeedbackWhereInput | boolean
    delete?: FeedbackWhereInput | boolean
    connect?: FeedbackWhereUniqueInput
    update?: XOR<XOR<FeedbackUpdateToOneWithWhereWithoutEstimateInput, FeedbackUpdateWithoutEstimateInput>, FeedbackUncheckedUpdateWithoutEstimateInput>
  }

  export type FeedbackUncheckedUpdateOneWithoutEstimateNestedInput = {
    create?: XOR<FeedbackCreateWithoutEstimateInput, FeedbackUncheckedCreateWithoutEstimateInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutEstimateInput
    upsert?: FeedbackUpsertWithoutEstimateInput
    disconnect?: FeedbackWhereInput | boolean
    delete?: FeedbackWhereInput | boolean
    connect?: FeedbackWhereUniqueInput
    update?: XOR<XOR<FeedbackUpdateToOneWithWhereWithoutEstimateInput, FeedbackUpdateWithoutEstimateInput>, FeedbackUncheckedUpdateWithoutEstimateInput>
  }

  export type UserCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
  }

  export type JobReportCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<JobReportCreateWithoutFeedbacksInput, JobReportUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutFeedbacksInput
    connect?: JobReportWhereUniqueInput
  }

  export type RepairEstimateCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<RepairEstimateCreateWithoutFeedbackInput, RepairEstimateUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: RepairEstimateCreateOrConnectWithoutFeedbackInput
    connect?: RepairEstimateWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    upsert?: UserUpsertWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbacksInput, UserUpdateWithoutFeedbacksInput>, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type JobReportUpdateOneWithoutFeedbacksNestedInput = {
    create?: XOR<JobReportCreateWithoutFeedbacksInput, JobReportUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutFeedbacksInput
    upsert?: JobReportUpsertWithoutFeedbacksInput
    disconnect?: JobReportWhereInput | boolean
    delete?: JobReportWhereInput | boolean
    connect?: JobReportWhereUniqueInput
    update?: XOR<XOR<JobReportUpdateToOneWithWhereWithoutFeedbacksInput, JobReportUpdateWithoutFeedbacksInput>, JobReportUncheckedUpdateWithoutFeedbacksInput>
  }

  export type RepairEstimateUpdateOneWithoutFeedbackNestedInput = {
    create?: XOR<RepairEstimateCreateWithoutFeedbackInput, RepairEstimateUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: RepairEstimateCreateOrConnectWithoutFeedbackInput
    upsert?: RepairEstimateUpsertWithoutFeedbackInput
    disconnect?: RepairEstimateWhereInput | boolean
    delete?: RepairEstimateWhereInput | boolean
    connect?: RepairEstimateWhereUniqueInput
    update?: XOR<XOR<RepairEstimateUpdateToOneWithWhereWithoutFeedbackInput, RepairEstimateUpdateWithoutFeedbackInput>, RepairEstimateUncheckedUpdateWithoutFeedbackInput>
  }

  export type TruckSectionCreateNestedOneWithoutImagesInput = {
    create?: XOR<TruckSectionCreateWithoutImagesInput, TruckSectionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: TruckSectionCreateOrConnectWithoutImagesInput
    connect?: TruckSectionWhereUniqueInput
  }

  export type ImageVehiclePartCreateNestedManyWithoutImageInput = {
    create?: XOR<ImageVehiclePartCreateWithoutImageInput, ImageVehiclePartUncheckedCreateWithoutImageInput> | ImageVehiclePartCreateWithoutImageInput[] | ImageVehiclePartUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageVehiclePartCreateOrConnectWithoutImageInput | ImageVehiclePartCreateOrConnectWithoutImageInput[]
    createMany?: ImageVehiclePartCreateManyImageInputEnvelope
    connect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
  }

  export type ImageDamageTypeCreateNestedManyWithoutImageInput = {
    create?: XOR<ImageDamageTypeCreateWithoutImageInput, ImageDamageTypeUncheckedCreateWithoutImageInput> | ImageDamageTypeCreateWithoutImageInput[] | ImageDamageTypeUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageDamageTypeCreateOrConnectWithoutImageInput | ImageDamageTypeCreateOrConnectWithoutImageInput[]
    createMany?: ImageDamageTypeCreateManyImageInputEnvelope
    connect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
  }

  export type SeverityLevelCreateNestedOneWithoutImagesInput = {
    create?: XOR<SeverityLevelCreateWithoutImagesInput, SeverityLevelUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SeverityLevelCreateOrConnectWithoutImagesInput
    connect?: SeverityLevelWhereUniqueInput
  }

  export type JobReportCreateNestedOneWithoutImagesInput = {
    create?: XOR<JobReportCreateWithoutImagesInput, JobReportUncheckedCreateWithoutImagesInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutImagesInput
    connect?: JobReportWhereUniqueInput
  }

  export type ImageVehiclePartUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<ImageVehiclePartCreateWithoutImageInput, ImageVehiclePartUncheckedCreateWithoutImageInput> | ImageVehiclePartCreateWithoutImageInput[] | ImageVehiclePartUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageVehiclePartCreateOrConnectWithoutImageInput | ImageVehiclePartCreateOrConnectWithoutImageInput[]
    createMany?: ImageVehiclePartCreateManyImageInputEnvelope
    connect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
  }

  export type ImageDamageTypeUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<ImageDamageTypeCreateWithoutImageInput, ImageDamageTypeUncheckedCreateWithoutImageInput> | ImageDamageTypeCreateWithoutImageInput[] | ImageDamageTypeUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageDamageTypeCreateOrConnectWithoutImageInput | ImageDamageTypeCreateOrConnectWithoutImageInput[]
    createMany?: ImageDamageTypeCreateManyImageInputEnvelope
    connect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
  }

  export type TruckSectionUpdateOneWithoutImagesNestedInput = {
    create?: XOR<TruckSectionCreateWithoutImagesInput, TruckSectionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: TruckSectionCreateOrConnectWithoutImagesInput
    upsert?: TruckSectionUpsertWithoutImagesInput
    disconnect?: TruckSectionWhereInput | boolean
    delete?: TruckSectionWhereInput | boolean
    connect?: TruckSectionWhereUniqueInput
    update?: XOR<XOR<TruckSectionUpdateToOneWithWhereWithoutImagesInput, TruckSectionUpdateWithoutImagesInput>, TruckSectionUncheckedUpdateWithoutImagesInput>
  }

  export type ImageVehiclePartUpdateManyWithoutImageNestedInput = {
    create?: XOR<ImageVehiclePartCreateWithoutImageInput, ImageVehiclePartUncheckedCreateWithoutImageInput> | ImageVehiclePartCreateWithoutImageInput[] | ImageVehiclePartUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageVehiclePartCreateOrConnectWithoutImageInput | ImageVehiclePartCreateOrConnectWithoutImageInput[]
    upsert?: ImageVehiclePartUpsertWithWhereUniqueWithoutImageInput | ImageVehiclePartUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: ImageVehiclePartCreateManyImageInputEnvelope
    set?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    disconnect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    delete?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    connect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    update?: ImageVehiclePartUpdateWithWhereUniqueWithoutImageInput | ImageVehiclePartUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: ImageVehiclePartUpdateManyWithWhereWithoutImageInput | ImageVehiclePartUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: ImageVehiclePartScalarWhereInput | ImageVehiclePartScalarWhereInput[]
  }

  export type ImageDamageTypeUpdateManyWithoutImageNestedInput = {
    create?: XOR<ImageDamageTypeCreateWithoutImageInput, ImageDamageTypeUncheckedCreateWithoutImageInput> | ImageDamageTypeCreateWithoutImageInput[] | ImageDamageTypeUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageDamageTypeCreateOrConnectWithoutImageInput | ImageDamageTypeCreateOrConnectWithoutImageInput[]
    upsert?: ImageDamageTypeUpsertWithWhereUniqueWithoutImageInput | ImageDamageTypeUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: ImageDamageTypeCreateManyImageInputEnvelope
    set?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    disconnect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    delete?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    connect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    update?: ImageDamageTypeUpdateWithWhereUniqueWithoutImageInput | ImageDamageTypeUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: ImageDamageTypeUpdateManyWithWhereWithoutImageInput | ImageDamageTypeUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: ImageDamageTypeScalarWhereInput | ImageDamageTypeScalarWhereInput[]
  }

  export type SeverityLevelUpdateOneWithoutImagesNestedInput = {
    create?: XOR<SeverityLevelCreateWithoutImagesInput, SeverityLevelUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SeverityLevelCreateOrConnectWithoutImagesInput
    upsert?: SeverityLevelUpsertWithoutImagesInput
    disconnect?: SeverityLevelWhereInput | boolean
    delete?: SeverityLevelWhereInput | boolean
    connect?: SeverityLevelWhereUniqueInput
    update?: XOR<XOR<SeverityLevelUpdateToOneWithWhereWithoutImagesInput, SeverityLevelUpdateWithoutImagesInput>, SeverityLevelUncheckedUpdateWithoutImagesInput>
  }

  export type JobReportUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<JobReportCreateWithoutImagesInput, JobReportUncheckedCreateWithoutImagesInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutImagesInput
    upsert?: JobReportUpsertWithoutImagesInput
    connect?: JobReportWhereUniqueInput
    update?: XOR<XOR<JobReportUpdateToOneWithWhereWithoutImagesInput, JobReportUpdateWithoutImagesInput>, JobReportUncheckedUpdateWithoutImagesInput>
  }

  export type ImageVehiclePartUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<ImageVehiclePartCreateWithoutImageInput, ImageVehiclePartUncheckedCreateWithoutImageInput> | ImageVehiclePartCreateWithoutImageInput[] | ImageVehiclePartUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageVehiclePartCreateOrConnectWithoutImageInput | ImageVehiclePartCreateOrConnectWithoutImageInput[]
    upsert?: ImageVehiclePartUpsertWithWhereUniqueWithoutImageInput | ImageVehiclePartUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: ImageVehiclePartCreateManyImageInputEnvelope
    set?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    disconnect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    delete?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    connect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    update?: ImageVehiclePartUpdateWithWhereUniqueWithoutImageInput | ImageVehiclePartUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: ImageVehiclePartUpdateManyWithWhereWithoutImageInput | ImageVehiclePartUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: ImageVehiclePartScalarWhereInput | ImageVehiclePartScalarWhereInput[]
  }

  export type ImageDamageTypeUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<ImageDamageTypeCreateWithoutImageInput, ImageDamageTypeUncheckedCreateWithoutImageInput> | ImageDamageTypeCreateWithoutImageInput[] | ImageDamageTypeUncheckedCreateWithoutImageInput[]
    connectOrCreate?: ImageDamageTypeCreateOrConnectWithoutImageInput | ImageDamageTypeCreateOrConnectWithoutImageInput[]
    upsert?: ImageDamageTypeUpsertWithWhereUniqueWithoutImageInput | ImageDamageTypeUpsertWithWhereUniqueWithoutImageInput[]
    createMany?: ImageDamageTypeCreateManyImageInputEnvelope
    set?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    disconnect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    delete?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    connect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    update?: ImageDamageTypeUpdateWithWhereUniqueWithoutImageInput | ImageDamageTypeUpdateWithWhereUniqueWithoutImageInput[]
    updateMany?: ImageDamageTypeUpdateManyWithWhereWithoutImageInput | ImageDamageTypeUpdateManyWithWhereWithoutImageInput[]
    deleteMany?: ImageDamageTypeScalarWhereInput | ImageDamageTypeScalarWhereInput[]
  }

  export type JobReportCreateNestedOneWithoutDetectedDamagesInput = {
    create?: XOR<JobReportCreateWithoutDetectedDamagesInput, JobReportUncheckedCreateWithoutDetectedDamagesInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutDetectedDamagesInput
    connect?: JobReportWhereUniqueInput
  }

  export type JobReportUpdateOneRequiredWithoutDetectedDamagesNestedInput = {
    create?: XOR<JobReportCreateWithoutDetectedDamagesInput, JobReportUncheckedCreateWithoutDetectedDamagesInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutDetectedDamagesInput
    upsert?: JobReportUpsertWithoutDetectedDamagesInput
    connect?: JobReportWhereUniqueInput
    update?: XOR<XOR<JobReportUpdateToOneWithWhereWithoutDetectedDamagesInput, JobReportUpdateWithoutDetectedDamagesInput>, JobReportUncheckedUpdateWithoutDetectedDamagesInput>
  }

  export type JobReportCreateNestedOneWithoutActualRepairsInput = {
    create?: XOR<JobReportCreateWithoutActualRepairsInput, JobReportUncheckedCreateWithoutActualRepairsInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutActualRepairsInput
    connect?: JobReportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConfirmedRepairsInput = {
    create?: XOR<UserCreateWithoutConfirmedRepairsInput, UserUncheckedCreateWithoutConfirmedRepairsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmedRepairsInput
    connect?: UserWhereUniqueInput
  }

  export type JobReportUpdateOneRequiredWithoutActualRepairsNestedInput = {
    create?: XOR<JobReportCreateWithoutActualRepairsInput, JobReportUncheckedCreateWithoutActualRepairsInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutActualRepairsInput
    upsert?: JobReportUpsertWithoutActualRepairsInput
    connect?: JobReportWhereUniqueInput
    update?: XOR<XOR<JobReportUpdateToOneWithWhereWithoutActualRepairsInput, JobReportUpdateWithoutActualRepairsInput>, JobReportUncheckedUpdateWithoutActualRepairsInput>
  }

  export type UserUpdateOneWithoutConfirmedRepairsNestedInput = {
    create?: XOR<UserCreateWithoutConfirmedRepairsInput, UserUncheckedCreateWithoutConfirmedRepairsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmedRepairsInput
    upsert?: UserUpsertWithoutConfirmedRepairsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConfirmedRepairsInput, UserUpdateWithoutConfirmedRepairsInput>, UserUncheckedUpdateWithoutConfirmedRepairsInput>
  }

  export type JobReportCreateNestedOneWithoutVinMetadataInput = {
    create?: XOR<JobReportCreateWithoutVinMetadataInput, JobReportUncheckedCreateWithoutVinMetadataInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutVinMetadataInput
    connect?: JobReportWhereUniqueInput
  }

  export type JobReportUpdateOneRequiredWithoutVinMetadataNestedInput = {
    create?: XOR<JobReportCreateWithoutVinMetadataInput, JobReportUncheckedCreateWithoutVinMetadataInput>
    connectOrCreate?: JobReportCreateOrConnectWithoutVinMetadataInput
    upsert?: JobReportUpsertWithoutVinMetadataInput
    connect?: JobReportWhereUniqueInput
    update?: XOR<XOR<JobReportUpdateToOneWithWhereWithoutVinMetadataInput, JobReportUpdateWithoutVinMetadataInput>, JobReportUncheckedUpdateWithoutVinMetadataInput>
  }

  export type VehiclePartCreateNestedManyWithoutTruckSectionInput = {
    create?: XOR<VehiclePartCreateWithoutTruckSectionInput, VehiclePartUncheckedCreateWithoutTruckSectionInput> | VehiclePartCreateWithoutTruckSectionInput[] | VehiclePartUncheckedCreateWithoutTruckSectionInput[]
    connectOrCreate?: VehiclePartCreateOrConnectWithoutTruckSectionInput | VehiclePartCreateOrConnectWithoutTruckSectionInput[]
    createMany?: VehiclePartCreateManyTruckSectionInputEnvelope
    connect?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
  }

  export type ImageCreateNestedManyWithoutTruckSectionInput = {
    create?: XOR<ImageCreateWithoutTruckSectionInput, ImageUncheckedCreateWithoutTruckSectionInput> | ImageCreateWithoutTruckSectionInput[] | ImageUncheckedCreateWithoutTruckSectionInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutTruckSectionInput | ImageCreateOrConnectWithoutTruckSectionInput[]
    createMany?: ImageCreateManyTruckSectionInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type VehiclePartUncheckedCreateNestedManyWithoutTruckSectionInput = {
    create?: XOR<VehiclePartCreateWithoutTruckSectionInput, VehiclePartUncheckedCreateWithoutTruckSectionInput> | VehiclePartCreateWithoutTruckSectionInput[] | VehiclePartUncheckedCreateWithoutTruckSectionInput[]
    connectOrCreate?: VehiclePartCreateOrConnectWithoutTruckSectionInput | VehiclePartCreateOrConnectWithoutTruckSectionInput[]
    createMany?: VehiclePartCreateManyTruckSectionInputEnvelope
    connect?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutTruckSectionInput = {
    create?: XOR<ImageCreateWithoutTruckSectionInput, ImageUncheckedCreateWithoutTruckSectionInput> | ImageCreateWithoutTruckSectionInput[] | ImageUncheckedCreateWithoutTruckSectionInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutTruckSectionInput | ImageCreateOrConnectWithoutTruckSectionInput[]
    createMany?: ImageCreateManyTruckSectionInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type VehiclePartUpdateManyWithoutTruckSectionNestedInput = {
    create?: XOR<VehiclePartCreateWithoutTruckSectionInput, VehiclePartUncheckedCreateWithoutTruckSectionInput> | VehiclePartCreateWithoutTruckSectionInput[] | VehiclePartUncheckedCreateWithoutTruckSectionInput[]
    connectOrCreate?: VehiclePartCreateOrConnectWithoutTruckSectionInput | VehiclePartCreateOrConnectWithoutTruckSectionInput[]
    upsert?: VehiclePartUpsertWithWhereUniqueWithoutTruckSectionInput | VehiclePartUpsertWithWhereUniqueWithoutTruckSectionInput[]
    createMany?: VehiclePartCreateManyTruckSectionInputEnvelope
    set?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
    disconnect?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
    delete?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
    connect?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
    update?: VehiclePartUpdateWithWhereUniqueWithoutTruckSectionInput | VehiclePartUpdateWithWhereUniqueWithoutTruckSectionInput[]
    updateMany?: VehiclePartUpdateManyWithWhereWithoutTruckSectionInput | VehiclePartUpdateManyWithWhereWithoutTruckSectionInput[]
    deleteMany?: VehiclePartScalarWhereInput | VehiclePartScalarWhereInput[]
  }

  export type ImageUpdateManyWithoutTruckSectionNestedInput = {
    create?: XOR<ImageCreateWithoutTruckSectionInput, ImageUncheckedCreateWithoutTruckSectionInput> | ImageCreateWithoutTruckSectionInput[] | ImageUncheckedCreateWithoutTruckSectionInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutTruckSectionInput | ImageCreateOrConnectWithoutTruckSectionInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutTruckSectionInput | ImageUpsertWithWhereUniqueWithoutTruckSectionInput[]
    createMany?: ImageCreateManyTruckSectionInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutTruckSectionInput | ImageUpdateWithWhereUniqueWithoutTruckSectionInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutTruckSectionInput | ImageUpdateManyWithWhereWithoutTruckSectionInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type VehiclePartUncheckedUpdateManyWithoutTruckSectionNestedInput = {
    create?: XOR<VehiclePartCreateWithoutTruckSectionInput, VehiclePartUncheckedCreateWithoutTruckSectionInput> | VehiclePartCreateWithoutTruckSectionInput[] | VehiclePartUncheckedCreateWithoutTruckSectionInput[]
    connectOrCreate?: VehiclePartCreateOrConnectWithoutTruckSectionInput | VehiclePartCreateOrConnectWithoutTruckSectionInput[]
    upsert?: VehiclePartUpsertWithWhereUniqueWithoutTruckSectionInput | VehiclePartUpsertWithWhereUniqueWithoutTruckSectionInput[]
    createMany?: VehiclePartCreateManyTruckSectionInputEnvelope
    set?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
    disconnect?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
    delete?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
    connect?: VehiclePartWhereUniqueInput | VehiclePartWhereUniqueInput[]
    update?: VehiclePartUpdateWithWhereUniqueWithoutTruckSectionInput | VehiclePartUpdateWithWhereUniqueWithoutTruckSectionInput[]
    updateMany?: VehiclePartUpdateManyWithWhereWithoutTruckSectionInput | VehiclePartUpdateManyWithWhereWithoutTruckSectionInput[]
    deleteMany?: VehiclePartScalarWhereInput | VehiclePartScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutTruckSectionNestedInput = {
    create?: XOR<ImageCreateWithoutTruckSectionInput, ImageUncheckedCreateWithoutTruckSectionInput> | ImageCreateWithoutTruckSectionInput[] | ImageUncheckedCreateWithoutTruckSectionInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutTruckSectionInput | ImageCreateOrConnectWithoutTruckSectionInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutTruckSectionInput | ImageUpsertWithWhereUniqueWithoutTruckSectionInput[]
    createMany?: ImageCreateManyTruckSectionInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutTruckSectionInput | ImageUpdateWithWhereUniqueWithoutTruckSectionInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutTruckSectionInput | ImageUpdateManyWithWhereWithoutTruckSectionInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type TruckSectionCreateNestedOneWithoutVehiclePartsInput = {
    create?: XOR<TruckSectionCreateWithoutVehiclePartsInput, TruckSectionUncheckedCreateWithoutVehiclePartsInput>
    connectOrCreate?: TruckSectionCreateOrConnectWithoutVehiclePartsInput
    connect?: TruckSectionWhereUniqueInput
  }

  export type ImageVehiclePartCreateNestedManyWithoutVehiclePartInput = {
    create?: XOR<ImageVehiclePartCreateWithoutVehiclePartInput, ImageVehiclePartUncheckedCreateWithoutVehiclePartInput> | ImageVehiclePartCreateWithoutVehiclePartInput[] | ImageVehiclePartUncheckedCreateWithoutVehiclePartInput[]
    connectOrCreate?: ImageVehiclePartCreateOrConnectWithoutVehiclePartInput | ImageVehiclePartCreateOrConnectWithoutVehiclePartInput[]
    createMany?: ImageVehiclePartCreateManyVehiclePartInputEnvelope
    connect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
  }

  export type ImageVehiclePartUncheckedCreateNestedManyWithoutVehiclePartInput = {
    create?: XOR<ImageVehiclePartCreateWithoutVehiclePartInput, ImageVehiclePartUncheckedCreateWithoutVehiclePartInput> | ImageVehiclePartCreateWithoutVehiclePartInput[] | ImageVehiclePartUncheckedCreateWithoutVehiclePartInput[]
    connectOrCreate?: ImageVehiclePartCreateOrConnectWithoutVehiclePartInput | ImageVehiclePartCreateOrConnectWithoutVehiclePartInput[]
    createMany?: ImageVehiclePartCreateManyVehiclePartInputEnvelope
    connect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
  }

  export type TruckSectionUpdateOneRequiredWithoutVehiclePartsNestedInput = {
    create?: XOR<TruckSectionCreateWithoutVehiclePartsInput, TruckSectionUncheckedCreateWithoutVehiclePartsInput>
    connectOrCreate?: TruckSectionCreateOrConnectWithoutVehiclePartsInput
    upsert?: TruckSectionUpsertWithoutVehiclePartsInput
    connect?: TruckSectionWhereUniqueInput
    update?: XOR<XOR<TruckSectionUpdateToOneWithWhereWithoutVehiclePartsInput, TruckSectionUpdateWithoutVehiclePartsInput>, TruckSectionUncheckedUpdateWithoutVehiclePartsInput>
  }

  export type ImageVehiclePartUpdateManyWithoutVehiclePartNestedInput = {
    create?: XOR<ImageVehiclePartCreateWithoutVehiclePartInput, ImageVehiclePartUncheckedCreateWithoutVehiclePartInput> | ImageVehiclePartCreateWithoutVehiclePartInput[] | ImageVehiclePartUncheckedCreateWithoutVehiclePartInput[]
    connectOrCreate?: ImageVehiclePartCreateOrConnectWithoutVehiclePartInput | ImageVehiclePartCreateOrConnectWithoutVehiclePartInput[]
    upsert?: ImageVehiclePartUpsertWithWhereUniqueWithoutVehiclePartInput | ImageVehiclePartUpsertWithWhereUniqueWithoutVehiclePartInput[]
    createMany?: ImageVehiclePartCreateManyVehiclePartInputEnvelope
    set?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    disconnect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    delete?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    connect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    update?: ImageVehiclePartUpdateWithWhereUniqueWithoutVehiclePartInput | ImageVehiclePartUpdateWithWhereUniqueWithoutVehiclePartInput[]
    updateMany?: ImageVehiclePartUpdateManyWithWhereWithoutVehiclePartInput | ImageVehiclePartUpdateManyWithWhereWithoutVehiclePartInput[]
    deleteMany?: ImageVehiclePartScalarWhereInput | ImageVehiclePartScalarWhereInput[]
  }

  export type ImageVehiclePartUncheckedUpdateManyWithoutVehiclePartNestedInput = {
    create?: XOR<ImageVehiclePartCreateWithoutVehiclePartInput, ImageVehiclePartUncheckedCreateWithoutVehiclePartInput> | ImageVehiclePartCreateWithoutVehiclePartInput[] | ImageVehiclePartUncheckedCreateWithoutVehiclePartInput[]
    connectOrCreate?: ImageVehiclePartCreateOrConnectWithoutVehiclePartInput | ImageVehiclePartCreateOrConnectWithoutVehiclePartInput[]
    upsert?: ImageVehiclePartUpsertWithWhereUniqueWithoutVehiclePartInput | ImageVehiclePartUpsertWithWhereUniqueWithoutVehiclePartInput[]
    createMany?: ImageVehiclePartCreateManyVehiclePartInputEnvelope
    set?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    disconnect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    delete?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    connect?: ImageVehiclePartWhereUniqueInput | ImageVehiclePartWhereUniqueInput[]
    update?: ImageVehiclePartUpdateWithWhereUniqueWithoutVehiclePartInput | ImageVehiclePartUpdateWithWhereUniqueWithoutVehiclePartInput[]
    updateMany?: ImageVehiclePartUpdateManyWithWhereWithoutVehiclePartInput | ImageVehiclePartUpdateManyWithWhereWithoutVehiclePartInput[]
    deleteMany?: ImageVehiclePartScalarWhereInput | ImageVehiclePartScalarWhereInput[]
  }

  export type ImageDamageTypeCreateNestedManyWithoutDamageTypeInput = {
    create?: XOR<ImageDamageTypeCreateWithoutDamageTypeInput, ImageDamageTypeUncheckedCreateWithoutDamageTypeInput> | ImageDamageTypeCreateWithoutDamageTypeInput[] | ImageDamageTypeUncheckedCreateWithoutDamageTypeInput[]
    connectOrCreate?: ImageDamageTypeCreateOrConnectWithoutDamageTypeInput | ImageDamageTypeCreateOrConnectWithoutDamageTypeInput[]
    createMany?: ImageDamageTypeCreateManyDamageTypeInputEnvelope
    connect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
  }

  export type ImageDamageTypeUncheckedCreateNestedManyWithoutDamageTypeInput = {
    create?: XOR<ImageDamageTypeCreateWithoutDamageTypeInput, ImageDamageTypeUncheckedCreateWithoutDamageTypeInput> | ImageDamageTypeCreateWithoutDamageTypeInput[] | ImageDamageTypeUncheckedCreateWithoutDamageTypeInput[]
    connectOrCreate?: ImageDamageTypeCreateOrConnectWithoutDamageTypeInput | ImageDamageTypeCreateOrConnectWithoutDamageTypeInput[]
    createMany?: ImageDamageTypeCreateManyDamageTypeInputEnvelope
    connect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
  }

  export type ImageDamageTypeUpdateManyWithoutDamageTypeNestedInput = {
    create?: XOR<ImageDamageTypeCreateWithoutDamageTypeInput, ImageDamageTypeUncheckedCreateWithoutDamageTypeInput> | ImageDamageTypeCreateWithoutDamageTypeInput[] | ImageDamageTypeUncheckedCreateWithoutDamageTypeInput[]
    connectOrCreate?: ImageDamageTypeCreateOrConnectWithoutDamageTypeInput | ImageDamageTypeCreateOrConnectWithoutDamageTypeInput[]
    upsert?: ImageDamageTypeUpsertWithWhereUniqueWithoutDamageTypeInput | ImageDamageTypeUpsertWithWhereUniqueWithoutDamageTypeInput[]
    createMany?: ImageDamageTypeCreateManyDamageTypeInputEnvelope
    set?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    disconnect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    delete?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    connect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    update?: ImageDamageTypeUpdateWithWhereUniqueWithoutDamageTypeInput | ImageDamageTypeUpdateWithWhereUniqueWithoutDamageTypeInput[]
    updateMany?: ImageDamageTypeUpdateManyWithWhereWithoutDamageTypeInput | ImageDamageTypeUpdateManyWithWhereWithoutDamageTypeInput[]
    deleteMany?: ImageDamageTypeScalarWhereInput | ImageDamageTypeScalarWhereInput[]
  }

  export type ImageDamageTypeUncheckedUpdateManyWithoutDamageTypeNestedInput = {
    create?: XOR<ImageDamageTypeCreateWithoutDamageTypeInput, ImageDamageTypeUncheckedCreateWithoutDamageTypeInput> | ImageDamageTypeCreateWithoutDamageTypeInput[] | ImageDamageTypeUncheckedCreateWithoutDamageTypeInput[]
    connectOrCreate?: ImageDamageTypeCreateOrConnectWithoutDamageTypeInput | ImageDamageTypeCreateOrConnectWithoutDamageTypeInput[]
    upsert?: ImageDamageTypeUpsertWithWhereUniqueWithoutDamageTypeInput | ImageDamageTypeUpsertWithWhereUniqueWithoutDamageTypeInput[]
    createMany?: ImageDamageTypeCreateManyDamageTypeInputEnvelope
    set?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    disconnect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    delete?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    connect?: ImageDamageTypeWhereUniqueInput | ImageDamageTypeWhereUniqueInput[]
    update?: ImageDamageTypeUpdateWithWhereUniqueWithoutDamageTypeInput | ImageDamageTypeUpdateWithWhereUniqueWithoutDamageTypeInput[]
    updateMany?: ImageDamageTypeUpdateManyWithWhereWithoutDamageTypeInput | ImageDamageTypeUpdateManyWithWhereWithoutDamageTypeInput[]
    deleteMany?: ImageDamageTypeScalarWhereInput | ImageDamageTypeScalarWhereInput[]
  }

  export type ImageCreateNestedManyWithoutSeverityInput = {
    create?: XOR<ImageCreateWithoutSeverityInput, ImageUncheckedCreateWithoutSeverityInput> | ImageCreateWithoutSeverityInput[] | ImageUncheckedCreateWithoutSeverityInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutSeverityInput | ImageCreateOrConnectWithoutSeverityInput[]
    createMany?: ImageCreateManySeverityInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutSeverityInput = {
    create?: XOR<ImageCreateWithoutSeverityInput, ImageUncheckedCreateWithoutSeverityInput> | ImageCreateWithoutSeverityInput[] | ImageUncheckedCreateWithoutSeverityInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutSeverityInput | ImageCreateOrConnectWithoutSeverityInput[]
    createMany?: ImageCreateManySeverityInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ImageUpdateManyWithoutSeverityNestedInput = {
    create?: XOR<ImageCreateWithoutSeverityInput, ImageUncheckedCreateWithoutSeverityInput> | ImageCreateWithoutSeverityInput[] | ImageUncheckedCreateWithoutSeverityInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutSeverityInput | ImageCreateOrConnectWithoutSeverityInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutSeverityInput | ImageUpsertWithWhereUniqueWithoutSeverityInput[]
    createMany?: ImageCreateManySeverityInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutSeverityInput | ImageUpdateWithWhereUniqueWithoutSeverityInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutSeverityInput | ImageUpdateManyWithWhereWithoutSeverityInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutSeverityNestedInput = {
    create?: XOR<ImageCreateWithoutSeverityInput, ImageUncheckedCreateWithoutSeverityInput> | ImageCreateWithoutSeverityInput[] | ImageUncheckedCreateWithoutSeverityInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutSeverityInput | ImageCreateOrConnectWithoutSeverityInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutSeverityInput | ImageUpsertWithWhereUniqueWithoutSeverityInput[]
    createMany?: ImageCreateManySeverityInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutSeverityInput | ImageUpdateWithWhereUniqueWithoutSeverityInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutSeverityInput | ImageUpdateManyWithWhereWithoutSeverityInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ImageCreateNestedOneWithoutVehiclePartsInput = {
    create?: XOR<ImageCreateWithoutVehiclePartsInput, ImageUncheckedCreateWithoutVehiclePartsInput>
    connectOrCreate?: ImageCreateOrConnectWithoutVehiclePartsInput
    connect?: ImageWhereUniqueInput
  }

  export type VehiclePartCreateNestedOneWithoutImagesInput = {
    create?: XOR<VehiclePartCreateWithoutImagesInput, VehiclePartUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VehiclePartCreateOrConnectWithoutImagesInput
    connect?: VehiclePartWhereUniqueInput
  }

  export type ImageUpdateOneRequiredWithoutVehiclePartsNestedInput = {
    create?: XOR<ImageCreateWithoutVehiclePartsInput, ImageUncheckedCreateWithoutVehiclePartsInput>
    connectOrCreate?: ImageCreateOrConnectWithoutVehiclePartsInput
    upsert?: ImageUpsertWithoutVehiclePartsInput
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutVehiclePartsInput, ImageUpdateWithoutVehiclePartsInput>, ImageUncheckedUpdateWithoutVehiclePartsInput>
  }

  export type VehiclePartUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<VehiclePartCreateWithoutImagesInput, VehiclePartUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VehiclePartCreateOrConnectWithoutImagesInput
    upsert?: VehiclePartUpsertWithoutImagesInput
    connect?: VehiclePartWhereUniqueInput
    update?: XOR<XOR<VehiclePartUpdateToOneWithWhereWithoutImagesInput, VehiclePartUpdateWithoutImagesInput>, VehiclePartUncheckedUpdateWithoutImagesInput>
  }

  export type ImageCreateNestedOneWithoutDamageTypesInput = {
    create?: XOR<ImageCreateWithoutDamageTypesInput, ImageUncheckedCreateWithoutDamageTypesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutDamageTypesInput
    connect?: ImageWhereUniqueInput
  }

  export type DamageTypeCreateNestedOneWithoutImagesInput = {
    create?: XOR<DamageTypeCreateWithoutImagesInput, DamageTypeUncheckedCreateWithoutImagesInput>
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImagesInput
    connect?: DamageTypeWhereUniqueInput
  }

  export type ImageUpdateOneRequiredWithoutDamageTypesNestedInput = {
    create?: XOR<ImageCreateWithoutDamageTypesInput, ImageUncheckedCreateWithoutDamageTypesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutDamageTypesInput
    upsert?: ImageUpsertWithoutDamageTypesInput
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutDamageTypesInput, ImageUpdateWithoutDamageTypesInput>, ImageUncheckedUpdateWithoutDamageTypesInput>
  }

  export type DamageTypeUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<DamageTypeCreateWithoutImagesInput, DamageTypeUncheckedCreateWithoutImagesInput>
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImagesInput
    upsert?: DamageTypeUpsertWithoutImagesInput
    connect?: DamageTypeWhereUniqueInput
    update?: XOR<XOR<DamageTypeUpdateToOneWithWhereWithoutImagesInput, DamageTypeUpdateWithoutImagesInput>, DamageTypeUncheckedUpdateWithoutImagesInput>
  }

  export type UserCreateNestedOneWithoutResetTokensInput = {
    create?: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokensInput
    upsert?: UserUpsertWithoutResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResetTokensInput, UserUpdateWithoutResetTokensInput>, UserUncheckedUpdateWithoutResetTokensInput>
  }

  export type VehicleCreateNestedOneWithoutReferenceImagesInput = {
    create?: XOR<VehicleCreateWithoutReferenceImagesInput, VehicleUncheckedCreateWithoutReferenceImagesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutReferenceImagesInput
    connect?: VehicleWhereUniqueInput
  }

  export type VehicleUpdateOneRequiredWithoutReferenceImagesNestedInput = {
    create?: XOR<VehicleCreateWithoutReferenceImagesInput, VehicleUncheckedCreateWithoutReferenceImagesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutReferenceImagesInput
    upsert?: VehicleUpsertWithoutReferenceImagesInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutReferenceImagesInput, VehicleUpdateWithoutReferenceImagesInput>, VehicleUncheckedUpdateWithoutReferenceImagesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type JobReportCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    vehicle: VehicleCreateNestedOneWithoutJobsInput
    images?: ImageCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataCreateNestedManyWithoutJobInput
  }

  export type JobReportUncheckedCreateWithoutUserInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    images?: ImageUncheckedCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageUncheckedCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateUncheckedCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairUncheckedCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobReportCreateOrConnectWithoutUserInput = {
    where: JobReportWhereUniqueInput
    create: XOR<JobReportCreateWithoutUserInput, JobReportUncheckedCreateWithoutUserInput>
  }

  export type JobReportCreateManyUserInputEnvelope = {
    data: JobReportCreateManyUserInput | JobReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActualRepairCreateWithoutUserInput = {
    id?: string
    actualHours: number
    notes?: string | null
    confirmedAt?: Date | string
    job: JobReportCreateNestedOneWithoutActualRepairsInput
  }

  export type ActualRepairUncheckedCreateWithoutUserInput = {
    id?: string
    jobId: string
    actualHours: number
    notes?: string | null
    confirmedAt?: Date | string
  }

  export type ActualRepairCreateOrConnectWithoutUserInput = {
    where: ActualRepairWhereUniqueInput
    create: XOR<ActualRepairCreateWithoutUserInput, ActualRepairUncheckedCreateWithoutUserInput>
  }

  export type ActualRepairCreateManyUserInputEnvelope = {
    data: ActualRepairCreateManyUserInput | ActualRepairCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutUserInput = {
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
    job?: JobReportCreateNestedOneWithoutFeedbacksInput
    estimate?: RepairEstimateCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutUserInput = {
    id?: number
    jobId?: string | null
    estimateId?: string | null
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackCreateManyUserInputEnvelope = {
    data: FeedbackCreateManyUserInput | FeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JobReportUpsertWithWhereUniqueWithoutUserInput = {
    where: JobReportWhereUniqueInput
    update: XOR<JobReportUpdateWithoutUserInput, JobReportUncheckedUpdateWithoutUserInput>
    create: XOR<JobReportCreateWithoutUserInput, JobReportUncheckedCreateWithoutUserInput>
  }

  export type JobReportUpdateWithWhereUniqueWithoutUserInput = {
    where: JobReportWhereUniqueInput
    data: XOR<JobReportUpdateWithoutUserInput, JobReportUncheckedUpdateWithoutUserInput>
  }

  export type JobReportUpdateManyWithWhereWithoutUserInput = {
    where: JobReportScalarWhereInput
    data: XOR<JobReportUpdateManyMutationInput, JobReportUncheckedUpdateManyWithoutUserInput>
  }

  export type JobReportScalarWhereInput = {
    AND?: JobReportScalarWhereInput | JobReportScalarWhereInput[]
    OR?: JobReportScalarWhereInput[]
    NOT?: JobReportScalarWhereInput | JobReportScalarWhereInput[]
    id?: StringFilter<"JobReport"> | string
    vin?: StringFilter<"JobReport"> | string
    uploadedById?: StringFilter<"JobReport"> | string
    createdAt?: DateTimeFilter<"JobReport"> | Date | string
    status?: StringFilter<"JobReport"> | string
    aiEstimate?: FloatNullableFilter<"JobReport"> | number | null
    aiResponse?: StringNullableFilter<"JobReport"> | string | null
  }

  export type ActualRepairUpsertWithWhereUniqueWithoutUserInput = {
    where: ActualRepairWhereUniqueInput
    update: XOR<ActualRepairUpdateWithoutUserInput, ActualRepairUncheckedUpdateWithoutUserInput>
    create: XOR<ActualRepairCreateWithoutUserInput, ActualRepairUncheckedCreateWithoutUserInput>
  }

  export type ActualRepairUpdateWithWhereUniqueWithoutUserInput = {
    where: ActualRepairWhereUniqueInput
    data: XOR<ActualRepairUpdateWithoutUserInput, ActualRepairUncheckedUpdateWithoutUserInput>
  }

  export type ActualRepairUpdateManyWithWhereWithoutUserInput = {
    where: ActualRepairScalarWhereInput
    data: XOR<ActualRepairUpdateManyMutationInput, ActualRepairUncheckedUpdateManyWithoutUserInput>
  }

  export type ActualRepairScalarWhereInput = {
    AND?: ActualRepairScalarWhereInput | ActualRepairScalarWhereInput[]
    OR?: ActualRepairScalarWhereInput[]
    NOT?: ActualRepairScalarWhereInput | ActualRepairScalarWhereInput[]
    id?: StringFilter<"ActualRepair"> | string
    jobId?: StringFilter<"ActualRepair"> | string
    actualHours?: FloatFilter<"ActualRepair"> | number
    notes?: StringNullableFilter<"ActualRepair"> | string | null
    confirmedById?: StringNullableFilter<"ActualRepair"> | string | null
    confirmedAt?: DateTimeFilter<"ActualRepair"> | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: IntFilter<"Feedback"> | number
    userId?: StringFilter<"Feedback"> | string
    jobId?: StringNullableFilter<"Feedback"> | string | null
    estimateId?: StringNullableFilter<"Feedback"> | string | null
    feedbackType?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    actualHours?: FloatNullableFilter<"Feedback"> | number | null
    experienceScoreSnapshot?: FloatNullableFilter<"Feedback"> | number | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type JobReportCreateWithoutVehicleInput = {
    id?: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    user: UserCreateNestedOneWithoutJobsInput
    images?: ImageCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataCreateNestedManyWithoutJobInput
  }

  export type JobReportUncheckedCreateWithoutVehicleInput = {
    id?: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    images?: ImageUncheckedCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageUncheckedCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateUncheckedCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairUncheckedCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobReportCreateOrConnectWithoutVehicleInput = {
    where: JobReportWhereUniqueInput
    create: XOR<JobReportCreateWithoutVehicleInput, JobReportUncheckedCreateWithoutVehicleInput>
  }

  export type JobReportCreateManyVehicleInputEnvelope = {
    data: JobReportCreateManyVehicleInput | JobReportCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type VehicleReferenceImageCreateWithoutVehicleInput = {
    id?: string
    imageUrl: string
    angle?: string | null
  }

  export type VehicleReferenceImageUncheckedCreateWithoutVehicleInput = {
    id?: string
    imageUrl: string
    angle?: string | null
  }

  export type VehicleReferenceImageCreateOrConnectWithoutVehicleInput = {
    where: VehicleReferenceImageWhereUniqueInput
    create: XOR<VehicleReferenceImageCreateWithoutVehicleInput, VehicleReferenceImageUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleReferenceImageCreateManyVehicleInputEnvelope = {
    data: VehicleReferenceImageCreateManyVehicleInput | VehicleReferenceImageCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type JobReportUpsertWithWhereUniqueWithoutVehicleInput = {
    where: JobReportWhereUniqueInput
    update: XOR<JobReportUpdateWithoutVehicleInput, JobReportUncheckedUpdateWithoutVehicleInput>
    create: XOR<JobReportCreateWithoutVehicleInput, JobReportUncheckedCreateWithoutVehicleInput>
  }

  export type JobReportUpdateWithWhereUniqueWithoutVehicleInput = {
    where: JobReportWhereUniqueInput
    data: XOR<JobReportUpdateWithoutVehicleInput, JobReportUncheckedUpdateWithoutVehicleInput>
  }

  export type JobReportUpdateManyWithWhereWithoutVehicleInput = {
    where: JobReportScalarWhereInput
    data: XOR<JobReportUpdateManyMutationInput, JobReportUncheckedUpdateManyWithoutVehicleInput>
  }

  export type VehicleReferenceImageUpsertWithWhereUniqueWithoutVehicleInput = {
    where: VehicleReferenceImageWhereUniqueInput
    update: XOR<VehicleReferenceImageUpdateWithoutVehicleInput, VehicleReferenceImageUncheckedUpdateWithoutVehicleInput>
    create: XOR<VehicleReferenceImageCreateWithoutVehicleInput, VehicleReferenceImageUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleReferenceImageUpdateWithWhereUniqueWithoutVehicleInput = {
    where: VehicleReferenceImageWhereUniqueInput
    data: XOR<VehicleReferenceImageUpdateWithoutVehicleInput, VehicleReferenceImageUncheckedUpdateWithoutVehicleInput>
  }

  export type VehicleReferenceImageUpdateManyWithWhereWithoutVehicleInput = {
    where: VehicleReferenceImageScalarWhereInput
    data: XOR<VehicleReferenceImageUpdateManyMutationInput, VehicleReferenceImageUncheckedUpdateManyWithoutVehicleInput>
  }

  export type VehicleReferenceImageScalarWhereInput = {
    AND?: VehicleReferenceImageScalarWhereInput | VehicleReferenceImageScalarWhereInput[]
    OR?: VehicleReferenceImageScalarWhereInput[]
    NOT?: VehicleReferenceImageScalarWhereInput | VehicleReferenceImageScalarWhereInput[]
    id?: StringFilter<"VehicleReferenceImage"> | string
    imageUrl?: StringFilter<"VehicleReferenceImage"> | string
    angle?: StringNullableFilter<"VehicleReferenceImage"> | string | null
    vehicleVin?: StringFilter<"VehicleReferenceImage"> | string
  }

  export type UserCreateWithoutJobsInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    confirmedRepairs?: ActualRepairCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJobsInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    confirmedRepairs?: ActualRepairUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
  }

  export type VehicleCreateWithoutJobsInput = {
    id?: string
    vin: string
    type?: string | null
    make?: string | null
    model?: string | null
    year?: number | null
    weightClass?: string | null
    owner?: string | null
    notes?: string | null
    createdAt?: Date | string
    bodyClass?: string | null
    driveType?: string | null
    engineModel?: string | null
    engineCylinders?: number | null
    engineDisplacementL?: number | null
    fuelTypePrimary?: string | null
    brakeSystemType?: string | null
    manufacturerName?: string | null
    plantCity?: string | null
    plantState?: string | null
    plantCountry?: string | null
    trim?: string | null
    series?: string | null
    steeringLocation?: string | null
    transmissionStyle?: string | null
    vehicleType?: string | null
    gvwr?: string | null
    doors?: string | null
    wheels?: string | null
    entertainmentSystem?: string | null
    abs?: string | null
    airbagLocations?: string | null
    electronicStabilityControl?: string | null
    basePrice?: string | null
    bedLength?: string | null
    cabType?: string | null
    referenceImages?: VehicleReferenceImageCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutJobsInput = {
    id?: string
    vin: string
    type?: string | null
    make?: string | null
    model?: string | null
    year?: number | null
    weightClass?: string | null
    owner?: string | null
    notes?: string | null
    createdAt?: Date | string
    bodyClass?: string | null
    driveType?: string | null
    engineModel?: string | null
    engineCylinders?: number | null
    engineDisplacementL?: number | null
    fuelTypePrimary?: string | null
    brakeSystemType?: string | null
    manufacturerName?: string | null
    plantCity?: string | null
    plantState?: string | null
    plantCountry?: string | null
    trim?: string | null
    series?: string | null
    steeringLocation?: string | null
    transmissionStyle?: string | null
    vehicleType?: string | null
    gvwr?: string | null
    doors?: string | null
    wheels?: string | null
    entertainmentSystem?: string | null
    abs?: string | null
    airbagLocations?: string | null
    electronicStabilityControl?: string | null
    basePrice?: string | null
    bedLength?: string | null
    cabType?: string | null
    referenceImages?: VehicleReferenceImageUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutJobsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutJobsInput, VehicleUncheckedCreateWithoutJobsInput>
  }

  export type ImageCreateWithoutJobInput = {
    id?: string
    imagePath: string
    notes?: string | null
    uploadedAt?: Date | string
    truckSection?: TruckSectionCreateNestedOneWithoutImagesInput
    vehicleParts?: ImageVehiclePartCreateNestedManyWithoutImageInput
    damageTypes?: ImageDamageTypeCreateNestedManyWithoutImageInput
    severity?: SeverityLevelCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutJobInput = {
    id?: string
    imagePath: string
    truckSectionId?: string | null
    severityId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
    vehicleParts?: ImageVehiclePartUncheckedCreateNestedManyWithoutImageInput
    damageTypes?: ImageDamageTypeUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutJobInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutJobInput, ImageUncheckedCreateWithoutJobInput>
  }

  export type ImageCreateManyJobInputEnvelope = {
    data: ImageCreateManyJobInput | ImageCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type DetectedDamageCreateWithoutJobInput = {
    id?: string
    aiOutputJson: string
    generatedAt?: Date | string
  }

  export type DetectedDamageUncheckedCreateWithoutJobInput = {
    id?: string
    aiOutputJson: string
    generatedAt?: Date | string
  }

  export type DetectedDamageCreateOrConnectWithoutJobInput = {
    where: DetectedDamageWhereUniqueInput
    create: XOR<DetectedDamageCreateWithoutJobInput, DetectedDamageUncheckedCreateWithoutJobInput>
  }

  export type DetectedDamageCreateManyJobInputEnvelope = {
    data: DetectedDamageCreateManyJobInput | DetectedDamageCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type RepairEstimateCreateWithoutJobInput = {
    id?: string
    timeEstimate: number
    costEstimate: number
    createdAt?: Date | string
    feedback?: FeedbackCreateNestedOneWithoutEstimateInput
  }

  export type RepairEstimateUncheckedCreateWithoutJobInput = {
    id?: string
    timeEstimate: number
    costEstimate: number
    createdAt?: Date | string
    feedback?: FeedbackUncheckedCreateNestedOneWithoutEstimateInput
  }

  export type RepairEstimateCreateOrConnectWithoutJobInput = {
    where: RepairEstimateWhereUniqueInput
    create: XOR<RepairEstimateCreateWithoutJobInput, RepairEstimateUncheckedCreateWithoutJobInput>
  }

  export type RepairEstimateCreateManyJobInputEnvelope = {
    data: RepairEstimateCreateManyJobInput | RepairEstimateCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type ActualRepairCreateWithoutJobInput = {
    id?: string
    actualHours: number
    notes?: string | null
    confirmedAt?: Date | string
    user?: UserCreateNestedOneWithoutConfirmedRepairsInput
  }

  export type ActualRepairUncheckedCreateWithoutJobInput = {
    id?: string
    actualHours: number
    notes?: string | null
    confirmedById?: string | null
    confirmedAt?: Date | string
  }

  export type ActualRepairCreateOrConnectWithoutJobInput = {
    where: ActualRepairWhereUniqueInput
    create: XOR<ActualRepairCreateWithoutJobInput, ActualRepairUncheckedCreateWithoutJobInput>
  }

  export type ActualRepairCreateManyJobInputEnvelope = {
    data: ActualRepairCreateManyJobInput | ActualRepairCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutJobInput = {
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbacksInput
    estimate?: RepairEstimateCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutJobInput = {
    id?: number
    userId: string
    estimateId?: string | null
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutJobInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutJobInput, FeedbackUncheckedCreateWithoutJobInput>
  }

  export type FeedbackCreateManyJobInputEnvelope = {
    data: FeedbackCreateManyJobInput | FeedbackCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type VINMetadataCreateWithoutJobInput = {
    id?: string
    vin: string
    make?: string | null
    model?: string | null
    year?: number | null
    engine?: string | null
    misc?: string | null
    decodedAt?: Date | string
  }

  export type VINMetadataUncheckedCreateWithoutJobInput = {
    id?: string
    vin: string
    make?: string | null
    model?: string | null
    year?: number | null
    engine?: string | null
    misc?: string | null
    decodedAt?: Date | string
  }

  export type VINMetadataCreateOrConnectWithoutJobInput = {
    where: VINMetadataWhereUniqueInput
    create: XOR<VINMetadataCreateWithoutJobInput, VINMetadataUncheckedCreateWithoutJobInput>
  }

  export type VINMetadataCreateManyJobInputEnvelope = {
    data: VINMetadataCreateManyJobInput | VINMetadataCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutJobsInput = {
    update: XOR<UserUpdateWithoutJobsInput, UserUncheckedUpdateWithoutJobsInput>
    create: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobsInput, UserUncheckedUpdateWithoutJobsInput>
  }

  export type UserUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    confirmedRepairs?: ActualRepairUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    confirmedRepairs?: ActualRepairUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VehicleUpsertWithoutJobsInput = {
    update: XOR<VehicleUpdateWithoutJobsInput, VehicleUncheckedUpdateWithoutJobsInput>
    create: XOR<VehicleCreateWithoutJobsInput, VehicleUncheckedCreateWithoutJobsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutJobsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutJobsInput, VehicleUncheckedUpdateWithoutJobsInput>
  }

  export type VehicleUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    weightClass?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyClass?: NullableStringFieldUpdateOperationsInput | string | null
    driveType?: NullableStringFieldUpdateOperationsInput | string | null
    engineModel?: NullableStringFieldUpdateOperationsInput | string | null
    engineCylinders?: NullableIntFieldUpdateOperationsInput | number | null
    engineDisplacementL?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelTypePrimary?: NullableStringFieldUpdateOperationsInput | string | null
    brakeSystemType?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturerName?: NullableStringFieldUpdateOperationsInput | string | null
    plantCity?: NullableStringFieldUpdateOperationsInput | string | null
    plantState?: NullableStringFieldUpdateOperationsInput | string | null
    plantCountry?: NullableStringFieldUpdateOperationsInput | string | null
    trim?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    steeringLocation?: NullableStringFieldUpdateOperationsInput | string | null
    transmissionStyle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    gvwr?: NullableStringFieldUpdateOperationsInput | string | null
    doors?: NullableStringFieldUpdateOperationsInput | string | null
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    entertainmentSystem?: NullableStringFieldUpdateOperationsInput | string | null
    abs?: NullableStringFieldUpdateOperationsInput | string | null
    airbagLocations?: NullableStringFieldUpdateOperationsInput | string | null
    electronicStabilityControl?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    bedLength?: NullableStringFieldUpdateOperationsInput | string | null
    cabType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceImages?: VehicleReferenceImageUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    weightClass?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyClass?: NullableStringFieldUpdateOperationsInput | string | null
    driveType?: NullableStringFieldUpdateOperationsInput | string | null
    engineModel?: NullableStringFieldUpdateOperationsInput | string | null
    engineCylinders?: NullableIntFieldUpdateOperationsInput | number | null
    engineDisplacementL?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelTypePrimary?: NullableStringFieldUpdateOperationsInput | string | null
    brakeSystemType?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturerName?: NullableStringFieldUpdateOperationsInput | string | null
    plantCity?: NullableStringFieldUpdateOperationsInput | string | null
    plantState?: NullableStringFieldUpdateOperationsInput | string | null
    plantCountry?: NullableStringFieldUpdateOperationsInput | string | null
    trim?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    steeringLocation?: NullableStringFieldUpdateOperationsInput | string | null
    transmissionStyle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    gvwr?: NullableStringFieldUpdateOperationsInput | string | null
    doors?: NullableStringFieldUpdateOperationsInput | string | null
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    entertainmentSystem?: NullableStringFieldUpdateOperationsInput | string | null
    abs?: NullableStringFieldUpdateOperationsInput | string | null
    airbagLocations?: NullableStringFieldUpdateOperationsInput | string | null
    electronicStabilityControl?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    bedLength?: NullableStringFieldUpdateOperationsInput | string | null
    cabType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceImages?: VehicleReferenceImageUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type ImageUpsertWithWhereUniqueWithoutJobInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutJobInput, ImageUncheckedUpdateWithoutJobInput>
    create: XOR<ImageCreateWithoutJobInput, ImageUncheckedCreateWithoutJobInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutJobInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutJobInput, ImageUncheckedUpdateWithoutJobInput>
  }

  export type ImageUpdateManyWithWhereWithoutJobInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutJobInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    id?: StringFilter<"Image"> | string
    jobId?: StringFilter<"Image"> | string
    imagePath?: StringFilter<"Image"> | string
    truckSectionId?: StringNullableFilter<"Image"> | string | null
    severityId?: StringNullableFilter<"Image"> | string | null
    notes?: StringNullableFilter<"Image"> | string | null
    uploadedAt?: DateTimeFilter<"Image"> | Date | string
  }

  export type DetectedDamageUpsertWithWhereUniqueWithoutJobInput = {
    where: DetectedDamageWhereUniqueInput
    update: XOR<DetectedDamageUpdateWithoutJobInput, DetectedDamageUncheckedUpdateWithoutJobInput>
    create: XOR<DetectedDamageCreateWithoutJobInput, DetectedDamageUncheckedCreateWithoutJobInput>
  }

  export type DetectedDamageUpdateWithWhereUniqueWithoutJobInput = {
    where: DetectedDamageWhereUniqueInput
    data: XOR<DetectedDamageUpdateWithoutJobInput, DetectedDamageUncheckedUpdateWithoutJobInput>
  }

  export type DetectedDamageUpdateManyWithWhereWithoutJobInput = {
    where: DetectedDamageScalarWhereInput
    data: XOR<DetectedDamageUpdateManyMutationInput, DetectedDamageUncheckedUpdateManyWithoutJobInput>
  }

  export type DetectedDamageScalarWhereInput = {
    AND?: DetectedDamageScalarWhereInput | DetectedDamageScalarWhereInput[]
    OR?: DetectedDamageScalarWhereInput[]
    NOT?: DetectedDamageScalarWhereInput | DetectedDamageScalarWhereInput[]
    id?: StringFilter<"DetectedDamage"> | string
    jobId?: StringFilter<"DetectedDamage"> | string
    aiOutputJson?: StringFilter<"DetectedDamage"> | string
    generatedAt?: DateTimeFilter<"DetectedDamage"> | Date | string
  }

  export type RepairEstimateUpsertWithWhereUniqueWithoutJobInput = {
    where: RepairEstimateWhereUniqueInput
    update: XOR<RepairEstimateUpdateWithoutJobInput, RepairEstimateUncheckedUpdateWithoutJobInput>
    create: XOR<RepairEstimateCreateWithoutJobInput, RepairEstimateUncheckedCreateWithoutJobInput>
  }

  export type RepairEstimateUpdateWithWhereUniqueWithoutJobInput = {
    where: RepairEstimateWhereUniqueInput
    data: XOR<RepairEstimateUpdateWithoutJobInput, RepairEstimateUncheckedUpdateWithoutJobInput>
  }

  export type RepairEstimateUpdateManyWithWhereWithoutJobInput = {
    where: RepairEstimateScalarWhereInput
    data: XOR<RepairEstimateUpdateManyMutationInput, RepairEstimateUncheckedUpdateManyWithoutJobInput>
  }

  export type RepairEstimateScalarWhereInput = {
    AND?: RepairEstimateScalarWhereInput | RepairEstimateScalarWhereInput[]
    OR?: RepairEstimateScalarWhereInput[]
    NOT?: RepairEstimateScalarWhereInput | RepairEstimateScalarWhereInput[]
    id?: StringFilter<"RepairEstimate"> | string
    jobId?: StringFilter<"RepairEstimate"> | string
    timeEstimate?: FloatFilter<"RepairEstimate"> | number
    costEstimate?: FloatFilter<"RepairEstimate"> | number
    createdAt?: DateTimeFilter<"RepairEstimate"> | Date | string
  }

  export type ActualRepairUpsertWithWhereUniqueWithoutJobInput = {
    where: ActualRepairWhereUniqueInput
    update: XOR<ActualRepairUpdateWithoutJobInput, ActualRepairUncheckedUpdateWithoutJobInput>
    create: XOR<ActualRepairCreateWithoutJobInput, ActualRepairUncheckedCreateWithoutJobInput>
  }

  export type ActualRepairUpdateWithWhereUniqueWithoutJobInput = {
    where: ActualRepairWhereUniqueInput
    data: XOR<ActualRepairUpdateWithoutJobInput, ActualRepairUncheckedUpdateWithoutJobInput>
  }

  export type ActualRepairUpdateManyWithWhereWithoutJobInput = {
    where: ActualRepairScalarWhereInput
    data: XOR<ActualRepairUpdateManyMutationInput, ActualRepairUncheckedUpdateManyWithoutJobInput>
  }

  export type FeedbackUpsertWithWhereUniqueWithoutJobInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutJobInput, FeedbackUncheckedUpdateWithoutJobInput>
    create: XOR<FeedbackCreateWithoutJobInput, FeedbackUncheckedCreateWithoutJobInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutJobInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutJobInput, FeedbackUncheckedUpdateWithoutJobInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutJobInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutJobInput>
  }

  export type VINMetadataUpsertWithWhereUniqueWithoutJobInput = {
    where: VINMetadataWhereUniqueInput
    update: XOR<VINMetadataUpdateWithoutJobInput, VINMetadataUncheckedUpdateWithoutJobInput>
    create: XOR<VINMetadataCreateWithoutJobInput, VINMetadataUncheckedCreateWithoutJobInput>
  }

  export type VINMetadataUpdateWithWhereUniqueWithoutJobInput = {
    where: VINMetadataWhereUniqueInput
    data: XOR<VINMetadataUpdateWithoutJobInput, VINMetadataUncheckedUpdateWithoutJobInput>
  }

  export type VINMetadataUpdateManyWithWhereWithoutJobInput = {
    where: VINMetadataScalarWhereInput
    data: XOR<VINMetadataUpdateManyMutationInput, VINMetadataUncheckedUpdateManyWithoutJobInput>
  }

  export type VINMetadataScalarWhereInput = {
    AND?: VINMetadataScalarWhereInput | VINMetadataScalarWhereInput[]
    OR?: VINMetadataScalarWhereInput[]
    NOT?: VINMetadataScalarWhereInput | VINMetadataScalarWhereInput[]
    id?: StringFilter<"VINMetadata"> | string
    jobId?: StringFilter<"VINMetadata"> | string
    vin?: StringFilter<"VINMetadata"> | string
    make?: StringNullableFilter<"VINMetadata"> | string | null
    model?: StringNullableFilter<"VINMetadata"> | string | null
    year?: IntNullableFilter<"VINMetadata"> | number | null
    engine?: StringNullableFilter<"VINMetadata"> | string | null
    misc?: StringNullableFilter<"VINMetadata"> | string | null
    decodedAt?: DateTimeFilter<"VINMetadata"> | Date | string
  }

  export type JobReportCreateWithoutRepairEstimatesInput = {
    id?: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    user: UserCreateNestedOneWithoutJobsInput
    vehicle: VehicleCreateNestedOneWithoutJobsInput
    images?: ImageCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataCreateNestedManyWithoutJobInput
  }

  export type JobReportUncheckedCreateWithoutRepairEstimatesInput = {
    id?: string
    vin: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    images?: ImageUncheckedCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageUncheckedCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairUncheckedCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobReportCreateOrConnectWithoutRepairEstimatesInput = {
    where: JobReportWhereUniqueInput
    create: XOR<JobReportCreateWithoutRepairEstimatesInput, JobReportUncheckedCreateWithoutRepairEstimatesInput>
  }

  export type FeedbackCreateWithoutEstimateInput = {
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbacksInput
    job?: JobReportCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateWithoutEstimateInput = {
    id?: number
    userId: string
    jobId?: string | null
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutEstimateInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutEstimateInput, FeedbackUncheckedCreateWithoutEstimateInput>
  }

  export type JobReportUpsertWithoutRepairEstimatesInput = {
    update: XOR<JobReportUpdateWithoutRepairEstimatesInput, JobReportUncheckedUpdateWithoutRepairEstimatesInput>
    create: XOR<JobReportCreateWithoutRepairEstimatesInput, JobReportUncheckedCreateWithoutRepairEstimatesInput>
    where?: JobReportWhereInput
  }

  export type JobReportUpdateToOneWithWhereWithoutRepairEstimatesInput = {
    where?: JobReportWhereInput
    data: XOR<JobReportUpdateWithoutRepairEstimatesInput, JobReportUncheckedUpdateWithoutRepairEstimatesInput>
  }

  export type JobReportUpdateWithoutRepairEstimatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutJobsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutJobsNestedInput
    images?: ImageUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateWithoutRepairEstimatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageUncheckedUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUncheckedUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUncheckedUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUncheckedUpdateManyWithoutJobNestedInput
  }

  export type FeedbackUpsertWithoutEstimateInput = {
    update: XOR<FeedbackUpdateWithoutEstimateInput, FeedbackUncheckedUpdateWithoutEstimateInput>
    create: XOR<FeedbackCreateWithoutEstimateInput, FeedbackUncheckedCreateWithoutEstimateInput>
    where?: FeedbackWhereInput
  }

  export type FeedbackUpdateToOneWithWhereWithoutEstimateInput = {
    where?: FeedbackWhereInput
    data: XOR<FeedbackUpdateWithoutEstimateInput, FeedbackUncheckedUpdateWithoutEstimateInput>
  }

  export type FeedbackUpdateWithoutEstimateInput = {
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
    job?: JobReportUpdateOneWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutEstimateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    jobs?: JobReportCreateNestedManyWithoutUserInput
    confirmedRepairs?: ActualRepairCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    jobs?: JobReportUncheckedCreateNestedManyWithoutUserInput
    confirmedRepairs?: ActualRepairUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbacksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
  }

  export type JobReportCreateWithoutFeedbacksInput = {
    id?: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    user: UserCreateNestedOneWithoutJobsInput
    vehicle: VehicleCreateNestedOneWithoutJobsInput
    images?: ImageCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataCreateNestedManyWithoutJobInput
  }

  export type JobReportUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    vin: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    images?: ImageUncheckedCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageUncheckedCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateUncheckedCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairUncheckedCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobReportCreateOrConnectWithoutFeedbacksInput = {
    where: JobReportWhereUniqueInput
    create: XOR<JobReportCreateWithoutFeedbacksInput, JobReportUncheckedCreateWithoutFeedbacksInput>
  }

  export type RepairEstimateCreateWithoutFeedbackInput = {
    id?: string
    timeEstimate: number
    costEstimate: number
    createdAt?: Date | string
    job: JobReportCreateNestedOneWithoutRepairEstimatesInput
  }

  export type RepairEstimateUncheckedCreateWithoutFeedbackInput = {
    id?: string
    jobId: string
    timeEstimate: number
    costEstimate: number
    createdAt?: Date | string
  }

  export type RepairEstimateCreateOrConnectWithoutFeedbackInput = {
    where: RepairEstimateWhereUniqueInput
    create: XOR<RepairEstimateCreateWithoutFeedbackInput, RepairEstimateUncheckedCreateWithoutFeedbackInput>
  }

  export type UserUpsertWithoutFeedbacksInput = {
    update: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    jobs?: JobReportUpdateManyWithoutUserNestedInput
    confirmedRepairs?: ActualRepairUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    jobs?: JobReportUncheckedUpdateManyWithoutUserNestedInput
    confirmedRepairs?: ActualRepairUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JobReportUpsertWithoutFeedbacksInput = {
    update: XOR<JobReportUpdateWithoutFeedbacksInput, JobReportUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<JobReportCreateWithoutFeedbacksInput, JobReportUncheckedCreateWithoutFeedbacksInput>
    where?: JobReportWhereInput
  }

  export type JobReportUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: JobReportWhereInput
    data: XOR<JobReportUpdateWithoutFeedbacksInput, JobReportUncheckedUpdateWithoutFeedbacksInput>
  }

  export type JobReportUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutJobsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutJobsNestedInput
    images?: ImageUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageUncheckedUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUncheckedUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUncheckedUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUncheckedUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUncheckedUpdateManyWithoutJobNestedInput
  }

  export type RepairEstimateUpsertWithoutFeedbackInput = {
    update: XOR<RepairEstimateUpdateWithoutFeedbackInput, RepairEstimateUncheckedUpdateWithoutFeedbackInput>
    create: XOR<RepairEstimateCreateWithoutFeedbackInput, RepairEstimateUncheckedCreateWithoutFeedbackInput>
    where?: RepairEstimateWhereInput
  }

  export type RepairEstimateUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: RepairEstimateWhereInput
    data: XOR<RepairEstimateUpdateWithoutFeedbackInput, RepairEstimateUncheckedUpdateWithoutFeedbackInput>
  }

  export type RepairEstimateUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeEstimate?: FloatFieldUpdateOperationsInput | number
    costEstimate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobReportUpdateOneRequiredWithoutRepairEstimatesNestedInput
  }

  export type RepairEstimateUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timeEstimate?: FloatFieldUpdateOperationsInput | number
    costEstimate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TruckSectionCreateWithoutImagesInput = {
    id?: string
    name: string
    vehicleParts?: VehiclePartCreateNestedManyWithoutTruckSectionInput
  }

  export type TruckSectionUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    vehicleParts?: VehiclePartUncheckedCreateNestedManyWithoutTruckSectionInput
  }

  export type TruckSectionCreateOrConnectWithoutImagesInput = {
    where: TruckSectionWhereUniqueInput
    create: XOR<TruckSectionCreateWithoutImagesInput, TruckSectionUncheckedCreateWithoutImagesInput>
  }

  export type ImageVehiclePartCreateWithoutImageInput = {
    vehiclePart: VehiclePartCreateNestedOneWithoutImagesInput
  }

  export type ImageVehiclePartUncheckedCreateWithoutImageInput = {
    vehiclePartId: string
  }

  export type ImageVehiclePartCreateOrConnectWithoutImageInput = {
    where: ImageVehiclePartWhereUniqueInput
    create: XOR<ImageVehiclePartCreateWithoutImageInput, ImageVehiclePartUncheckedCreateWithoutImageInput>
  }

  export type ImageVehiclePartCreateManyImageInputEnvelope = {
    data: ImageVehiclePartCreateManyImageInput | ImageVehiclePartCreateManyImageInput[]
    skipDuplicates?: boolean
  }

  export type ImageDamageTypeCreateWithoutImageInput = {
    damageType: DamageTypeCreateNestedOneWithoutImagesInput
  }

  export type ImageDamageTypeUncheckedCreateWithoutImageInput = {
    damageTypeId: string
  }

  export type ImageDamageTypeCreateOrConnectWithoutImageInput = {
    where: ImageDamageTypeWhereUniqueInput
    create: XOR<ImageDamageTypeCreateWithoutImageInput, ImageDamageTypeUncheckedCreateWithoutImageInput>
  }

  export type ImageDamageTypeCreateManyImageInputEnvelope = {
    data: ImageDamageTypeCreateManyImageInput | ImageDamageTypeCreateManyImageInput[]
    skipDuplicates?: boolean
  }

  export type SeverityLevelCreateWithoutImagesInput = {
    id?: string
    name: string
  }

  export type SeverityLevelUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
  }

  export type SeverityLevelCreateOrConnectWithoutImagesInput = {
    where: SeverityLevelWhereUniqueInput
    create: XOR<SeverityLevelCreateWithoutImagesInput, SeverityLevelUncheckedCreateWithoutImagesInput>
  }

  export type JobReportCreateWithoutImagesInput = {
    id?: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    user: UserCreateNestedOneWithoutJobsInput
    vehicle: VehicleCreateNestedOneWithoutJobsInput
    detectedDamages?: DetectedDamageCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataCreateNestedManyWithoutJobInput
  }

  export type JobReportUncheckedCreateWithoutImagesInput = {
    id?: string
    vin: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    detectedDamages?: DetectedDamageUncheckedCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateUncheckedCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairUncheckedCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobReportCreateOrConnectWithoutImagesInput = {
    where: JobReportWhereUniqueInput
    create: XOR<JobReportCreateWithoutImagesInput, JobReportUncheckedCreateWithoutImagesInput>
  }

  export type TruckSectionUpsertWithoutImagesInput = {
    update: XOR<TruckSectionUpdateWithoutImagesInput, TruckSectionUncheckedUpdateWithoutImagesInput>
    create: XOR<TruckSectionCreateWithoutImagesInput, TruckSectionUncheckedCreateWithoutImagesInput>
    where?: TruckSectionWhereInput
  }

  export type TruckSectionUpdateToOneWithWhereWithoutImagesInput = {
    where?: TruckSectionWhereInput
    data: XOR<TruckSectionUpdateWithoutImagesInput, TruckSectionUncheckedUpdateWithoutImagesInput>
  }

  export type TruckSectionUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vehicleParts?: VehiclePartUpdateManyWithoutTruckSectionNestedInput
  }

  export type TruckSectionUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vehicleParts?: VehiclePartUncheckedUpdateManyWithoutTruckSectionNestedInput
  }

  export type ImageVehiclePartUpsertWithWhereUniqueWithoutImageInput = {
    where: ImageVehiclePartWhereUniqueInput
    update: XOR<ImageVehiclePartUpdateWithoutImageInput, ImageVehiclePartUncheckedUpdateWithoutImageInput>
    create: XOR<ImageVehiclePartCreateWithoutImageInput, ImageVehiclePartUncheckedCreateWithoutImageInput>
  }

  export type ImageVehiclePartUpdateWithWhereUniqueWithoutImageInput = {
    where: ImageVehiclePartWhereUniqueInput
    data: XOR<ImageVehiclePartUpdateWithoutImageInput, ImageVehiclePartUncheckedUpdateWithoutImageInput>
  }

  export type ImageVehiclePartUpdateManyWithWhereWithoutImageInput = {
    where: ImageVehiclePartScalarWhereInput
    data: XOR<ImageVehiclePartUpdateManyMutationInput, ImageVehiclePartUncheckedUpdateManyWithoutImageInput>
  }

  export type ImageVehiclePartScalarWhereInput = {
    AND?: ImageVehiclePartScalarWhereInput | ImageVehiclePartScalarWhereInput[]
    OR?: ImageVehiclePartScalarWhereInput[]
    NOT?: ImageVehiclePartScalarWhereInput | ImageVehiclePartScalarWhereInput[]
    imageId?: StringFilter<"ImageVehiclePart"> | string
    vehiclePartId?: StringFilter<"ImageVehiclePart"> | string
  }

  export type ImageDamageTypeUpsertWithWhereUniqueWithoutImageInput = {
    where: ImageDamageTypeWhereUniqueInput
    update: XOR<ImageDamageTypeUpdateWithoutImageInput, ImageDamageTypeUncheckedUpdateWithoutImageInput>
    create: XOR<ImageDamageTypeCreateWithoutImageInput, ImageDamageTypeUncheckedCreateWithoutImageInput>
  }

  export type ImageDamageTypeUpdateWithWhereUniqueWithoutImageInput = {
    where: ImageDamageTypeWhereUniqueInput
    data: XOR<ImageDamageTypeUpdateWithoutImageInput, ImageDamageTypeUncheckedUpdateWithoutImageInput>
  }

  export type ImageDamageTypeUpdateManyWithWhereWithoutImageInput = {
    where: ImageDamageTypeScalarWhereInput
    data: XOR<ImageDamageTypeUpdateManyMutationInput, ImageDamageTypeUncheckedUpdateManyWithoutImageInput>
  }

  export type ImageDamageTypeScalarWhereInput = {
    AND?: ImageDamageTypeScalarWhereInput | ImageDamageTypeScalarWhereInput[]
    OR?: ImageDamageTypeScalarWhereInput[]
    NOT?: ImageDamageTypeScalarWhereInput | ImageDamageTypeScalarWhereInput[]
    imageId?: StringFilter<"ImageDamageType"> | string
    damageTypeId?: StringFilter<"ImageDamageType"> | string
  }

  export type SeverityLevelUpsertWithoutImagesInput = {
    update: XOR<SeverityLevelUpdateWithoutImagesInput, SeverityLevelUncheckedUpdateWithoutImagesInput>
    create: XOR<SeverityLevelCreateWithoutImagesInput, SeverityLevelUncheckedCreateWithoutImagesInput>
    where?: SeverityLevelWhereInput
  }

  export type SeverityLevelUpdateToOneWithWhereWithoutImagesInput = {
    where?: SeverityLevelWhereInput
    data: XOR<SeverityLevelUpdateWithoutImagesInput, SeverityLevelUncheckedUpdateWithoutImagesInput>
  }

  export type SeverityLevelUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SeverityLevelUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type JobReportUpsertWithoutImagesInput = {
    update: XOR<JobReportUpdateWithoutImagesInput, JobReportUncheckedUpdateWithoutImagesInput>
    create: XOR<JobReportCreateWithoutImagesInput, JobReportUncheckedCreateWithoutImagesInput>
    where?: JobReportWhereInput
  }

  export type JobReportUpdateToOneWithWhereWithoutImagesInput = {
    where?: JobReportWhereInput
    data: XOR<JobReportUpdateWithoutImagesInput, JobReportUncheckedUpdateWithoutImagesInput>
  }

  export type JobReportUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutJobsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutJobsNestedInput
    detectedDamages?: DetectedDamageUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    detectedDamages?: DetectedDamageUncheckedUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUncheckedUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUncheckedUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobReportCreateWithoutDetectedDamagesInput = {
    id?: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    user: UserCreateNestedOneWithoutJobsInput
    vehicle: VehicleCreateNestedOneWithoutJobsInput
    images?: ImageCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataCreateNestedManyWithoutJobInput
  }

  export type JobReportUncheckedCreateWithoutDetectedDamagesInput = {
    id?: string
    vin: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    images?: ImageUncheckedCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateUncheckedCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairUncheckedCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobReportCreateOrConnectWithoutDetectedDamagesInput = {
    where: JobReportWhereUniqueInput
    create: XOR<JobReportCreateWithoutDetectedDamagesInput, JobReportUncheckedCreateWithoutDetectedDamagesInput>
  }

  export type JobReportUpsertWithoutDetectedDamagesInput = {
    update: XOR<JobReportUpdateWithoutDetectedDamagesInput, JobReportUncheckedUpdateWithoutDetectedDamagesInput>
    create: XOR<JobReportCreateWithoutDetectedDamagesInput, JobReportUncheckedCreateWithoutDetectedDamagesInput>
    where?: JobReportWhereInput
  }

  export type JobReportUpdateToOneWithWhereWithoutDetectedDamagesInput = {
    where?: JobReportWhereInput
    data: XOR<JobReportUpdateWithoutDetectedDamagesInput, JobReportUncheckedUpdateWithoutDetectedDamagesInput>
  }

  export type JobReportUpdateWithoutDetectedDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutJobsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutJobsNestedInput
    images?: ImageUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateWithoutDetectedDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageUncheckedUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUncheckedUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUncheckedUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobReportCreateWithoutActualRepairsInput = {
    id?: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    user: UserCreateNestedOneWithoutJobsInput
    vehicle: VehicleCreateNestedOneWithoutJobsInput
    images?: ImageCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataCreateNestedManyWithoutJobInput
  }

  export type JobReportUncheckedCreateWithoutActualRepairsInput = {
    id?: string
    vin: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    images?: ImageUncheckedCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageUncheckedCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateUncheckedCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutJobInput
    vinMetadata?: VINMetadataUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobReportCreateOrConnectWithoutActualRepairsInput = {
    where: JobReportWhereUniqueInput
    create: XOR<JobReportCreateWithoutActualRepairsInput, JobReportUncheckedCreateWithoutActualRepairsInput>
  }

  export type UserCreateWithoutConfirmedRepairsInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    jobs?: JobReportCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConfirmedRepairsInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    jobs?: JobReportUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConfirmedRepairsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConfirmedRepairsInput, UserUncheckedCreateWithoutConfirmedRepairsInput>
  }

  export type JobReportUpsertWithoutActualRepairsInput = {
    update: XOR<JobReportUpdateWithoutActualRepairsInput, JobReportUncheckedUpdateWithoutActualRepairsInput>
    create: XOR<JobReportCreateWithoutActualRepairsInput, JobReportUncheckedCreateWithoutActualRepairsInput>
    where?: JobReportWhereInput
  }

  export type JobReportUpdateToOneWithWhereWithoutActualRepairsInput = {
    where?: JobReportWhereInput
    data: XOR<JobReportUpdateWithoutActualRepairsInput, JobReportUncheckedUpdateWithoutActualRepairsInput>
  }

  export type JobReportUpdateWithoutActualRepairsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutJobsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutJobsNestedInput
    images?: ImageUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateWithoutActualRepairsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageUncheckedUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUncheckedUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUncheckedUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserUpsertWithoutConfirmedRepairsInput = {
    update: XOR<UserUpdateWithoutConfirmedRepairsInput, UserUncheckedUpdateWithoutConfirmedRepairsInput>
    create: XOR<UserCreateWithoutConfirmedRepairsInput, UserUncheckedCreateWithoutConfirmedRepairsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConfirmedRepairsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConfirmedRepairsInput, UserUncheckedUpdateWithoutConfirmedRepairsInput>
  }

  export type UserUpdateWithoutConfirmedRepairsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    jobs?: JobReportUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConfirmedRepairsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    jobs?: JobReportUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JobReportCreateWithoutVinMetadataInput = {
    id?: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    user: UserCreateNestedOneWithoutJobsInput
    vehicle: VehicleCreateNestedOneWithoutJobsInput
    images?: ImageCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackCreateNestedManyWithoutJobInput
  }

  export type JobReportUncheckedCreateWithoutVinMetadataInput = {
    id?: string
    vin: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
    images?: ImageUncheckedCreateNestedManyWithoutJobInput
    detectedDamages?: DetectedDamageUncheckedCreateNestedManyWithoutJobInput
    repairEstimates?: RepairEstimateUncheckedCreateNestedManyWithoutJobInput
    actualRepairs?: ActualRepairUncheckedCreateNestedManyWithoutJobInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobReportCreateOrConnectWithoutVinMetadataInput = {
    where: JobReportWhereUniqueInput
    create: XOR<JobReportCreateWithoutVinMetadataInput, JobReportUncheckedCreateWithoutVinMetadataInput>
  }

  export type JobReportUpsertWithoutVinMetadataInput = {
    update: XOR<JobReportUpdateWithoutVinMetadataInput, JobReportUncheckedUpdateWithoutVinMetadataInput>
    create: XOR<JobReportCreateWithoutVinMetadataInput, JobReportUncheckedCreateWithoutVinMetadataInput>
    where?: JobReportWhereInput
  }

  export type JobReportUpdateToOneWithWhereWithoutVinMetadataInput = {
    where?: JobReportWhereInput
    data: XOR<JobReportUpdateWithoutVinMetadataInput, JobReportUncheckedUpdateWithoutVinMetadataInput>
  }

  export type JobReportUpdateWithoutVinMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutJobsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutJobsNestedInput
    images?: ImageUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateWithoutVinMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageUncheckedUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUncheckedUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUncheckedUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUncheckedUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutJobNestedInput
  }

  export type VehiclePartCreateWithoutTruckSectionInput = {
    id?: string
    name: string
    images?: ImageVehiclePartCreateNestedManyWithoutVehiclePartInput
  }

  export type VehiclePartUncheckedCreateWithoutTruckSectionInput = {
    id?: string
    name: string
    images?: ImageVehiclePartUncheckedCreateNestedManyWithoutVehiclePartInput
  }

  export type VehiclePartCreateOrConnectWithoutTruckSectionInput = {
    where: VehiclePartWhereUniqueInput
    create: XOR<VehiclePartCreateWithoutTruckSectionInput, VehiclePartUncheckedCreateWithoutTruckSectionInput>
  }

  export type VehiclePartCreateManyTruckSectionInputEnvelope = {
    data: VehiclePartCreateManyTruckSectionInput | VehiclePartCreateManyTruckSectionInput[]
    skipDuplicates?: boolean
  }

  export type ImageCreateWithoutTruckSectionInput = {
    id?: string
    imagePath: string
    notes?: string | null
    uploadedAt?: Date | string
    vehicleParts?: ImageVehiclePartCreateNestedManyWithoutImageInput
    damageTypes?: ImageDamageTypeCreateNestedManyWithoutImageInput
    severity?: SeverityLevelCreateNestedOneWithoutImagesInput
    job: JobReportCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutTruckSectionInput = {
    id?: string
    jobId: string
    imagePath: string
    severityId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
    vehicleParts?: ImageVehiclePartUncheckedCreateNestedManyWithoutImageInput
    damageTypes?: ImageDamageTypeUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutTruckSectionInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutTruckSectionInput, ImageUncheckedCreateWithoutTruckSectionInput>
  }

  export type ImageCreateManyTruckSectionInputEnvelope = {
    data: ImageCreateManyTruckSectionInput | ImageCreateManyTruckSectionInput[]
    skipDuplicates?: boolean
  }

  export type VehiclePartUpsertWithWhereUniqueWithoutTruckSectionInput = {
    where: VehiclePartWhereUniqueInput
    update: XOR<VehiclePartUpdateWithoutTruckSectionInput, VehiclePartUncheckedUpdateWithoutTruckSectionInput>
    create: XOR<VehiclePartCreateWithoutTruckSectionInput, VehiclePartUncheckedCreateWithoutTruckSectionInput>
  }

  export type VehiclePartUpdateWithWhereUniqueWithoutTruckSectionInput = {
    where: VehiclePartWhereUniqueInput
    data: XOR<VehiclePartUpdateWithoutTruckSectionInput, VehiclePartUncheckedUpdateWithoutTruckSectionInput>
  }

  export type VehiclePartUpdateManyWithWhereWithoutTruckSectionInput = {
    where: VehiclePartScalarWhereInput
    data: XOR<VehiclePartUpdateManyMutationInput, VehiclePartUncheckedUpdateManyWithoutTruckSectionInput>
  }

  export type VehiclePartScalarWhereInput = {
    AND?: VehiclePartScalarWhereInput | VehiclePartScalarWhereInput[]
    OR?: VehiclePartScalarWhereInput[]
    NOT?: VehiclePartScalarWhereInput | VehiclePartScalarWhereInput[]
    id?: StringFilter<"VehiclePart"> | string
    name?: StringFilter<"VehiclePart"> | string
    truckSectionId?: StringFilter<"VehiclePart"> | string
  }

  export type ImageUpsertWithWhereUniqueWithoutTruckSectionInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutTruckSectionInput, ImageUncheckedUpdateWithoutTruckSectionInput>
    create: XOR<ImageCreateWithoutTruckSectionInput, ImageUncheckedCreateWithoutTruckSectionInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutTruckSectionInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutTruckSectionInput, ImageUncheckedUpdateWithoutTruckSectionInput>
  }

  export type ImageUpdateManyWithWhereWithoutTruckSectionInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutTruckSectionInput>
  }

  export type TruckSectionCreateWithoutVehiclePartsInput = {
    id?: string
    name: string
    images?: ImageCreateNestedManyWithoutTruckSectionInput
  }

  export type TruckSectionUncheckedCreateWithoutVehiclePartsInput = {
    id?: string
    name: string
    images?: ImageUncheckedCreateNestedManyWithoutTruckSectionInput
  }

  export type TruckSectionCreateOrConnectWithoutVehiclePartsInput = {
    where: TruckSectionWhereUniqueInput
    create: XOR<TruckSectionCreateWithoutVehiclePartsInput, TruckSectionUncheckedCreateWithoutVehiclePartsInput>
  }

  export type ImageVehiclePartCreateWithoutVehiclePartInput = {
    image: ImageCreateNestedOneWithoutVehiclePartsInput
  }

  export type ImageVehiclePartUncheckedCreateWithoutVehiclePartInput = {
    imageId: string
  }

  export type ImageVehiclePartCreateOrConnectWithoutVehiclePartInput = {
    where: ImageVehiclePartWhereUniqueInput
    create: XOR<ImageVehiclePartCreateWithoutVehiclePartInput, ImageVehiclePartUncheckedCreateWithoutVehiclePartInput>
  }

  export type ImageVehiclePartCreateManyVehiclePartInputEnvelope = {
    data: ImageVehiclePartCreateManyVehiclePartInput | ImageVehiclePartCreateManyVehiclePartInput[]
    skipDuplicates?: boolean
  }

  export type TruckSectionUpsertWithoutVehiclePartsInput = {
    update: XOR<TruckSectionUpdateWithoutVehiclePartsInput, TruckSectionUncheckedUpdateWithoutVehiclePartsInput>
    create: XOR<TruckSectionCreateWithoutVehiclePartsInput, TruckSectionUncheckedCreateWithoutVehiclePartsInput>
    where?: TruckSectionWhereInput
  }

  export type TruckSectionUpdateToOneWithWhereWithoutVehiclePartsInput = {
    where?: TruckSectionWhereInput
    data: XOR<TruckSectionUpdateWithoutVehiclePartsInput, TruckSectionUncheckedUpdateWithoutVehiclePartsInput>
  }

  export type TruckSectionUpdateWithoutVehiclePartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: ImageUpdateManyWithoutTruckSectionNestedInput
  }

  export type TruckSectionUncheckedUpdateWithoutVehiclePartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: ImageUncheckedUpdateManyWithoutTruckSectionNestedInput
  }

  export type ImageVehiclePartUpsertWithWhereUniqueWithoutVehiclePartInput = {
    where: ImageVehiclePartWhereUniqueInput
    update: XOR<ImageVehiclePartUpdateWithoutVehiclePartInput, ImageVehiclePartUncheckedUpdateWithoutVehiclePartInput>
    create: XOR<ImageVehiclePartCreateWithoutVehiclePartInput, ImageVehiclePartUncheckedCreateWithoutVehiclePartInput>
  }

  export type ImageVehiclePartUpdateWithWhereUniqueWithoutVehiclePartInput = {
    where: ImageVehiclePartWhereUniqueInput
    data: XOR<ImageVehiclePartUpdateWithoutVehiclePartInput, ImageVehiclePartUncheckedUpdateWithoutVehiclePartInput>
  }

  export type ImageVehiclePartUpdateManyWithWhereWithoutVehiclePartInput = {
    where: ImageVehiclePartScalarWhereInput
    data: XOR<ImageVehiclePartUpdateManyMutationInput, ImageVehiclePartUncheckedUpdateManyWithoutVehiclePartInput>
  }

  export type ImageDamageTypeCreateWithoutDamageTypeInput = {
    image: ImageCreateNestedOneWithoutDamageTypesInput
  }

  export type ImageDamageTypeUncheckedCreateWithoutDamageTypeInput = {
    imageId: string
  }

  export type ImageDamageTypeCreateOrConnectWithoutDamageTypeInput = {
    where: ImageDamageTypeWhereUniqueInput
    create: XOR<ImageDamageTypeCreateWithoutDamageTypeInput, ImageDamageTypeUncheckedCreateWithoutDamageTypeInput>
  }

  export type ImageDamageTypeCreateManyDamageTypeInputEnvelope = {
    data: ImageDamageTypeCreateManyDamageTypeInput | ImageDamageTypeCreateManyDamageTypeInput[]
    skipDuplicates?: boolean
  }

  export type ImageDamageTypeUpsertWithWhereUniqueWithoutDamageTypeInput = {
    where: ImageDamageTypeWhereUniqueInput
    update: XOR<ImageDamageTypeUpdateWithoutDamageTypeInput, ImageDamageTypeUncheckedUpdateWithoutDamageTypeInput>
    create: XOR<ImageDamageTypeCreateWithoutDamageTypeInput, ImageDamageTypeUncheckedCreateWithoutDamageTypeInput>
  }

  export type ImageDamageTypeUpdateWithWhereUniqueWithoutDamageTypeInput = {
    where: ImageDamageTypeWhereUniqueInput
    data: XOR<ImageDamageTypeUpdateWithoutDamageTypeInput, ImageDamageTypeUncheckedUpdateWithoutDamageTypeInput>
  }

  export type ImageDamageTypeUpdateManyWithWhereWithoutDamageTypeInput = {
    where: ImageDamageTypeScalarWhereInput
    data: XOR<ImageDamageTypeUpdateManyMutationInput, ImageDamageTypeUncheckedUpdateManyWithoutDamageTypeInput>
  }

  export type ImageCreateWithoutSeverityInput = {
    id?: string
    imagePath: string
    notes?: string | null
    uploadedAt?: Date | string
    truckSection?: TruckSectionCreateNestedOneWithoutImagesInput
    vehicleParts?: ImageVehiclePartCreateNestedManyWithoutImageInput
    damageTypes?: ImageDamageTypeCreateNestedManyWithoutImageInput
    job: JobReportCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutSeverityInput = {
    id?: string
    jobId: string
    imagePath: string
    truckSectionId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
    vehicleParts?: ImageVehiclePartUncheckedCreateNestedManyWithoutImageInput
    damageTypes?: ImageDamageTypeUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutSeverityInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutSeverityInput, ImageUncheckedCreateWithoutSeverityInput>
  }

  export type ImageCreateManySeverityInputEnvelope = {
    data: ImageCreateManySeverityInput | ImageCreateManySeverityInput[]
    skipDuplicates?: boolean
  }

  export type ImageUpsertWithWhereUniqueWithoutSeverityInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutSeverityInput, ImageUncheckedUpdateWithoutSeverityInput>
    create: XOR<ImageCreateWithoutSeverityInput, ImageUncheckedCreateWithoutSeverityInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutSeverityInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutSeverityInput, ImageUncheckedUpdateWithoutSeverityInput>
  }

  export type ImageUpdateManyWithWhereWithoutSeverityInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutSeverityInput>
  }

  export type ImageCreateWithoutVehiclePartsInput = {
    id?: string
    imagePath: string
    notes?: string | null
    uploadedAt?: Date | string
    truckSection?: TruckSectionCreateNestedOneWithoutImagesInput
    damageTypes?: ImageDamageTypeCreateNestedManyWithoutImageInput
    severity?: SeverityLevelCreateNestedOneWithoutImagesInput
    job: JobReportCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutVehiclePartsInput = {
    id?: string
    jobId: string
    imagePath: string
    truckSectionId?: string | null
    severityId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
    damageTypes?: ImageDamageTypeUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutVehiclePartsInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutVehiclePartsInput, ImageUncheckedCreateWithoutVehiclePartsInput>
  }

  export type VehiclePartCreateWithoutImagesInput = {
    id?: string
    name: string
    truckSection: TruckSectionCreateNestedOneWithoutVehiclePartsInput
  }

  export type VehiclePartUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    truckSectionId: string
  }

  export type VehiclePartCreateOrConnectWithoutImagesInput = {
    where: VehiclePartWhereUniqueInput
    create: XOR<VehiclePartCreateWithoutImagesInput, VehiclePartUncheckedCreateWithoutImagesInput>
  }

  export type ImageUpsertWithoutVehiclePartsInput = {
    update: XOR<ImageUpdateWithoutVehiclePartsInput, ImageUncheckedUpdateWithoutVehiclePartsInput>
    create: XOR<ImageCreateWithoutVehiclePartsInput, ImageUncheckedCreateWithoutVehiclePartsInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutVehiclePartsInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutVehiclePartsInput, ImageUncheckedUpdateWithoutVehiclePartsInput>
  }

  export type ImageUpdateWithoutVehiclePartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    truckSection?: TruckSectionUpdateOneWithoutImagesNestedInput
    damageTypes?: ImageDamageTypeUpdateManyWithoutImageNestedInput
    severity?: SeverityLevelUpdateOneWithoutImagesNestedInput
    job?: JobReportUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutVehiclePartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    truckSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    severityId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    damageTypes?: ImageDamageTypeUncheckedUpdateManyWithoutImageNestedInput
  }

  export type VehiclePartUpsertWithoutImagesInput = {
    update: XOR<VehiclePartUpdateWithoutImagesInput, VehiclePartUncheckedUpdateWithoutImagesInput>
    create: XOR<VehiclePartCreateWithoutImagesInput, VehiclePartUncheckedCreateWithoutImagesInput>
    where?: VehiclePartWhereInput
  }

  export type VehiclePartUpdateToOneWithWhereWithoutImagesInput = {
    where?: VehiclePartWhereInput
    data: XOR<VehiclePartUpdateWithoutImagesInput, VehiclePartUncheckedUpdateWithoutImagesInput>
  }

  export type VehiclePartUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    truckSection?: TruckSectionUpdateOneRequiredWithoutVehiclePartsNestedInput
  }

  export type VehiclePartUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    truckSectionId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateWithoutDamageTypesInput = {
    id?: string
    imagePath: string
    notes?: string | null
    uploadedAt?: Date | string
    truckSection?: TruckSectionCreateNestedOneWithoutImagesInput
    vehicleParts?: ImageVehiclePartCreateNestedManyWithoutImageInput
    severity?: SeverityLevelCreateNestedOneWithoutImagesInput
    job: JobReportCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutDamageTypesInput = {
    id?: string
    jobId: string
    imagePath: string
    truckSectionId?: string | null
    severityId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
    vehicleParts?: ImageVehiclePartUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutDamageTypesInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutDamageTypesInput, ImageUncheckedCreateWithoutDamageTypesInput>
  }

  export type DamageTypeCreateWithoutImagesInput = {
    id?: string
    name: string
  }

  export type DamageTypeUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
  }

  export type DamageTypeCreateOrConnectWithoutImagesInput = {
    where: DamageTypeWhereUniqueInput
    create: XOR<DamageTypeCreateWithoutImagesInput, DamageTypeUncheckedCreateWithoutImagesInput>
  }

  export type ImageUpsertWithoutDamageTypesInput = {
    update: XOR<ImageUpdateWithoutDamageTypesInput, ImageUncheckedUpdateWithoutDamageTypesInput>
    create: XOR<ImageCreateWithoutDamageTypesInput, ImageUncheckedCreateWithoutDamageTypesInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutDamageTypesInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutDamageTypesInput, ImageUncheckedUpdateWithoutDamageTypesInput>
  }

  export type ImageUpdateWithoutDamageTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    truckSection?: TruckSectionUpdateOneWithoutImagesNestedInput
    vehicleParts?: ImageVehiclePartUpdateManyWithoutImageNestedInput
    severity?: SeverityLevelUpdateOneWithoutImagesNestedInput
    job?: JobReportUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutDamageTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    truckSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    severityId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleParts?: ImageVehiclePartUncheckedUpdateManyWithoutImageNestedInput
  }

  export type DamageTypeUpsertWithoutImagesInput = {
    update: XOR<DamageTypeUpdateWithoutImagesInput, DamageTypeUncheckedUpdateWithoutImagesInput>
    create: XOR<DamageTypeCreateWithoutImagesInput, DamageTypeUncheckedCreateWithoutImagesInput>
    where?: DamageTypeWhereInput
  }

  export type DamageTypeUpdateToOneWithWhereWithoutImagesInput = {
    where?: DamageTypeWhereInput
    data: XOR<DamageTypeUpdateWithoutImagesInput, DamageTypeUncheckedUpdateWithoutImagesInput>
  }

  export type DamageTypeUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutResetTokensInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    jobs?: JobReportCreateNestedManyWithoutUserInput
    confirmedRepairs?: ActualRepairCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResetTokensInput = {
    id?: string
    name: string
    email: string
    hashedPassword: string
    createdAt?: Date | string
    role?: string
    experienceLevel?: number
    jobs?: JobReportUncheckedCreateNestedManyWithoutUserInput
    confirmedRepairs?: ActualRepairUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
  }

  export type UserUpsertWithoutResetTokensInput = {
    update: XOR<UserUpdateWithoutResetTokensInput, UserUncheckedUpdateWithoutResetTokensInput>
    create: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResetTokensInput, UserUncheckedUpdateWithoutResetTokensInput>
  }

  export type UserUpdateWithoutResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    jobs?: JobReportUpdateManyWithoutUserNestedInput
    confirmedRepairs?: ActualRepairUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    experienceLevel?: IntFieldUpdateOperationsInput | number
    jobs?: JobReportUncheckedUpdateManyWithoutUserNestedInput
    confirmedRepairs?: ActualRepairUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VehicleCreateWithoutReferenceImagesInput = {
    id?: string
    vin: string
    type?: string | null
    make?: string | null
    model?: string | null
    year?: number | null
    weightClass?: string | null
    owner?: string | null
    notes?: string | null
    createdAt?: Date | string
    bodyClass?: string | null
    driveType?: string | null
    engineModel?: string | null
    engineCylinders?: number | null
    engineDisplacementL?: number | null
    fuelTypePrimary?: string | null
    brakeSystemType?: string | null
    manufacturerName?: string | null
    plantCity?: string | null
    plantState?: string | null
    plantCountry?: string | null
    trim?: string | null
    series?: string | null
    steeringLocation?: string | null
    transmissionStyle?: string | null
    vehicleType?: string | null
    gvwr?: string | null
    doors?: string | null
    wheels?: string | null
    entertainmentSystem?: string | null
    abs?: string | null
    airbagLocations?: string | null
    electronicStabilityControl?: string | null
    basePrice?: string | null
    bedLength?: string | null
    cabType?: string | null
    jobs?: JobReportCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutReferenceImagesInput = {
    id?: string
    vin: string
    type?: string | null
    make?: string | null
    model?: string | null
    year?: number | null
    weightClass?: string | null
    owner?: string | null
    notes?: string | null
    createdAt?: Date | string
    bodyClass?: string | null
    driveType?: string | null
    engineModel?: string | null
    engineCylinders?: number | null
    engineDisplacementL?: number | null
    fuelTypePrimary?: string | null
    brakeSystemType?: string | null
    manufacturerName?: string | null
    plantCity?: string | null
    plantState?: string | null
    plantCountry?: string | null
    trim?: string | null
    series?: string | null
    steeringLocation?: string | null
    transmissionStyle?: string | null
    vehicleType?: string | null
    gvwr?: string | null
    doors?: string | null
    wheels?: string | null
    entertainmentSystem?: string | null
    abs?: string | null
    airbagLocations?: string | null
    electronicStabilityControl?: string | null
    basePrice?: string | null
    bedLength?: string | null
    cabType?: string | null
    jobs?: JobReportUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutReferenceImagesInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutReferenceImagesInput, VehicleUncheckedCreateWithoutReferenceImagesInput>
  }

  export type VehicleUpsertWithoutReferenceImagesInput = {
    update: XOR<VehicleUpdateWithoutReferenceImagesInput, VehicleUncheckedUpdateWithoutReferenceImagesInput>
    create: XOR<VehicleCreateWithoutReferenceImagesInput, VehicleUncheckedCreateWithoutReferenceImagesInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutReferenceImagesInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutReferenceImagesInput, VehicleUncheckedUpdateWithoutReferenceImagesInput>
  }

  export type VehicleUpdateWithoutReferenceImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    weightClass?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyClass?: NullableStringFieldUpdateOperationsInput | string | null
    driveType?: NullableStringFieldUpdateOperationsInput | string | null
    engineModel?: NullableStringFieldUpdateOperationsInput | string | null
    engineCylinders?: NullableIntFieldUpdateOperationsInput | number | null
    engineDisplacementL?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelTypePrimary?: NullableStringFieldUpdateOperationsInput | string | null
    brakeSystemType?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturerName?: NullableStringFieldUpdateOperationsInput | string | null
    plantCity?: NullableStringFieldUpdateOperationsInput | string | null
    plantState?: NullableStringFieldUpdateOperationsInput | string | null
    plantCountry?: NullableStringFieldUpdateOperationsInput | string | null
    trim?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    steeringLocation?: NullableStringFieldUpdateOperationsInput | string | null
    transmissionStyle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    gvwr?: NullableStringFieldUpdateOperationsInput | string | null
    doors?: NullableStringFieldUpdateOperationsInput | string | null
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    entertainmentSystem?: NullableStringFieldUpdateOperationsInput | string | null
    abs?: NullableStringFieldUpdateOperationsInput | string | null
    airbagLocations?: NullableStringFieldUpdateOperationsInput | string | null
    electronicStabilityControl?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    bedLength?: NullableStringFieldUpdateOperationsInput | string | null
    cabType?: NullableStringFieldUpdateOperationsInput | string | null
    jobs?: JobReportUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutReferenceImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    weightClass?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyClass?: NullableStringFieldUpdateOperationsInput | string | null
    driveType?: NullableStringFieldUpdateOperationsInput | string | null
    engineModel?: NullableStringFieldUpdateOperationsInput | string | null
    engineCylinders?: NullableIntFieldUpdateOperationsInput | number | null
    engineDisplacementL?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelTypePrimary?: NullableStringFieldUpdateOperationsInput | string | null
    brakeSystemType?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturerName?: NullableStringFieldUpdateOperationsInput | string | null
    plantCity?: NullableStringFieldUpdateOperationsInput | string | null
    plantState?: NullableStringFieldUpdateOperationsInput | string | null
    plantCountry?: NullableStringFieldUpdateOperationsInput | string | null
    trim?: NullableStringFieldUpdateOperationsInput | string | null
    series?: NullableStringFieldUpdateOperationsInput | string | null
    steeringLocation?: NullableStringFieldUpdateOperationsInput | string | null
    transmissionStyle?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    gvwr?: NullableStringFieldUpdateOperationsInput | string | null
    doors?: NullableStringFieldUpdateOperationsInput | string | null
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    entertainmentSystem?: NullableStringFieldUpdateOperationsInput | string | null
    abs?: NullableStringFieldUpdateOperationsInput | string | null
    airbagLocations?: NullableStringFieldUpdateOperationsInput | string | null
    electronicStabilityControl?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    bedLength?: NullableStringFieldUpdateOperationsInput | string | null
    cabType?: NullableStringFieldUpdateOperationsInput | string | null
    jobs?: JobReportUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type JobReportCreateManyUserInput = {
    id?: string
    vin: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
  }

  export type ActualRepairCreateManyUserInput = {
    id?: string
    jobId: string
    actualHours: number
    notes?: string | null
    confirmedAt?: Date | string
  }

  export type FeedbackCreateManyUserInput = {
    id?: number
    jobId?: string | null
    estimateId?: string | null
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
  }

  export type JobReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle?: VehicleUpdateOneRequiredWithoutJobsNestedInput
    images?: ImageUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageUncheckedUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUncheckedUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUncheckedUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUncheckedUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActualRepairUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobReportUpdateOneRequiredWithoutActualRepairsNestedInput
  }

  export type ActualRepairUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualRepairUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutUserInput = {
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobReportUpdateOneWithoutFeedbacksNestedInput
    estimate?: RepairEstimateUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    estimateId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    estimateId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobReportCreateManyVehicleInput = {
    id?: string
    uploadedById: string
    createdAt?: Date | string
    status?: string
    aiEstimate?: number | null
    aiResponse?: string | null
  }

  export type VehicleReferenceImageCreateManyVehicleInput = {
    id?: string
    imageUrl: string
    angle?: string | null
  }

  export type JobReportUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutJobsNestedInput
    images?: ImageUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ImageUncheckedUpdateManyWithoutJobNestedInput
    detectedDamages?: DetectedDamageUncheckedUpdateManyWithoutJobNestedInput
    repairEstimates?: RepairEstimateUncheckedUpdateManyWithoutJobNestedInput
    actualRepairs?: ActualRepairUncheckedUpdateManyWithoutJobNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutJobNestedInput
    vinMetadata?: VINMetadataUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobReportUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    aiEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    aiResponse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleReferenceImageUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    angle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleReferenceImageUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    angle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleReferenceImageUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    angle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageCreateManyJobInput = {
    id?: string
    imagePath: string
    truckSectionId?: string | null
    severityId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
  }

  export type DetectedDamageCreateManyJobInput = {
    id?: string
    aiOutputJson: string
    generatedAt?: Date | string
  }

  export type RepairEstimateCreateManyJobInput = {
    id?: string
    timeEstimate: number
    costEstimate: number
    createdAt?: Date | string
  }

  export type ActualRepairCreateManyJobInput = {
    id?: string
    actualHours: number
    notes?: string | null
    confirmedById?: string | null
    confirmedAt?: Date | string
  }

  export type FeedbackCreateManyJobInput = {
    id?: number
    userId: string
    estimateId?: string | null
    feedbackType?: string
    message: string
    actualHours?: number | null
    experienceScoreSnapshot?: number | null
    createdAt?: Date | string
  }

  export type VINMetadataCreateManyJobInput = {
    id?: string
    vin: string
    make?: string | null
    model?: string | null
    year?: number | null
    engine?: string | null
    misc?: string | null
    decodedAt?: Date | string
  }

  export type ImageUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    truckSection?: TruckSectionUpdateOneWithoutImagesNestedInput
    vehicleParts?: ImageVehiclePartUpdateManyWithoutImageNestedInput
    damageTypes?: ImageDamageTypeUpdateManyWithoutImageNestedInput
    severity?: SeverityLevelUpdateOneWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    truckSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    severityId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleParts?: ImageVehiclePartUncheckedUpdateManyWithoutImageNestedInput
    damageTypes?: ImageDamageTypeUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    truckSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    severityId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedDamageUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiOutputJson?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedDamageUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiOutputJson?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedDamageUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiOutputJson?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairEstimateUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeEstimate?: FloatFieldUpdateOperationsInput | number
    costEstimate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUpdateOneWithoutEstimateNestedInput
  }

  export type RepairEstimateUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeEstimate?: FloatFieldUpdateOperationsInput | number
    costEstimate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateOneWithoutEstimateNestedInput
  }

  export type RepairEstimateUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeEstimate?: FloatFieldUpdateOperationsInput | number
    costEstimate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualRepairUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutConfirmedRepairsNestedInput
  }

  export type ActualRepairUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedById?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActualRepairUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    actualHours?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedById?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutJobInput = {
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
    estimate?: RepairEstimateUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    estimateId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    estimateId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScoreSnapshot?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VINMetadataUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    misc?: NullableStringFieldUpdateOperationsInput | string | null
    decodedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VINMetadataUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    misc?: NullableStringFieldUpdateOperationsInput | string | null
    decodedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VINMetadataUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    misc?: NullableStringFieldUpdateOperationsInput | string | null
    decodedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageVehiclePartCreateManyImageInput = {
    vehiclePartId: string
  }

  export type ImageDamageTypeCreateManyImageInput = {
    damageTypeId: string
  }

  export type ImageVehiclePartUpdateWithoutImageInput = {
    vehiclePart?: VehiclePartUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageVehiclePartUncheckedUpdateWithoutImageInput = {
    vehiclePartId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageVehiclePartUncheckedUpdateManyWithoutImageInput = {
    vehiclePartId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageDamageTypeUpdateWithoutImageInput = {
    damageType?: DamageTypeUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageDamageTypeUncheckedUpdateWithoutImageInput = {
    damageTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageDamageTypeUncheckedUpdateManyWithoutImageInput = {
    damageTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type VehiclePartCreateManyTruckSectionInput = {
    id?: string
    name: string
  }

  export type ImageCreateManyTruckSectionInput = {
    id?: string
    jobId: string
    imagePath: string
    severityId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
  }

  export type VehiclePartUpdateWithoutTruckSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: ImageVehiclePartUpdateManyWithoutVehiclePartNestedInput
  }

  export type VehiclePartUncheckedUpdateWithoutTruckSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: ImageVehiclePartUncheckedUpdateManyWithoutVehiclePartNestedInput
  }

  export type VehiclePartUncheckedUpdateManyWithoutTruckSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUpdateWithoutTruckSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleParts?: ImageVehiclePartUpdateManyWithoutImageNestedInput
    damageTypes?: ImageDamageTypeUpdateManyWithoutImageNestedInput
    severity?: SeverityLevelUpdateOneWithoutImagesNestedInput
    job?: JobReportUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutTruckSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    severityId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleParts?: ImageVehiclePartUncheckedUpdateManyWithoutImageNestedInput
    damageTypes?: ImageDamageTypeUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateManyWithoutTruckSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    severityId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageVehiclePartCreateManyVehiclePartInput = {
    imageId: string
  }

  export type ImageVehiclePartUpdateWithoutVehiclePartInput = {
    image?: ImageUpdateOneRequiredWithoutVehiclePartsNestedInput
  }

  export type ImageVehiclePartUncheckedUpdateWithoutVehiclePartInput = {
    imageId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageVehiclePartUncheckedUpdateManyWithoutVehiclePartInput = {
    imageId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageDamageTypeCreateManyDamageTypeInput = {
    imageId: string
  }

  export type ImageDamageTypeUpdateWithoutDamageTypeInput = {
    image?: ImageUpdateOneRequiredWithoutDamageTypesNestedInput
  }

  export type ImageDamageTypeUncheckedUpdateWithoutDamageTypeInput = {
    imageId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageDamageTypeUncheckedUpdateManyWithoutDamageTypeInput = {
    imageId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateManySeverityInput = {
    id?: string
    jobId: string
    imagePath: string
    truckSectionId?: string | null
    notes?: string | null
    uploadedAt?: Date | string
  }

  export type ImageUpdateWithoutSeverityInput = {
    id?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    truckSection?: TruckSectionUpdateOneWithoutImagesNestedInput
    vehicleParts?: ImageVehiclePartUpdateManyWithoutImageNestedInput
    damageTypes?: ImageDamageTypeUpdateManyWithoutImageNestedInput
    job?: JobReportUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutSeverityInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    truckSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleParts?: ImageVehiclePartUncheckedUpdateManyWithoutImageNestedInput
    damageTypes?: ImageDamageTypeUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateManyWithoutSeverityInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    truckSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleCountOutputTypeDefaultArgs instead
     */
    export type VehicleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobReportCountOutputTypeDefaultArgs instead
     */
    export type JobReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImageCountOutputTypeDefaultArgs instead
     */
    export type ImageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TruckSectionCountOutputTypeDefaultArgs instead
     */
    export type TruckSectionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TruckSectionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehiclePartCountOutputTypeDefaultArgs instead
     */
    export type VehiclePartCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehiclePartCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DamageTypeCountOutputTypeDefaultArgs instead
     */
    export type DamageTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DamageTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeverityLevelCountOutputTypeDefaultArgs instead
     */
    export type SeverityLevelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeverityLevelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleDefaultArgs instead
     */
    export type VehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobReportDefaultArgs instead
     */
    export type JobReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RepairEstimateDefaultArgs instead
     */
    export type RepairEstimateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RepairEstimateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackDefaultArgs instead
     */
    export type FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImageDefaultArgs instead
     */
    export type ImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetectedDamageDefaultArgs instead
     */
    export type DetectedDamageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetectedDamageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActualRepairDefaultArgs instead
     */
    export type ActualRepairArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActualRepairDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingImageDefaultArgs instead
     */
    export type TrainingImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VINMetadataDefaultArgs instead
     */
    export type VINMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VINMetadataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TruckSectionDefaultArgs instead
     */
    export type TruckSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TruckSectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehiclePartDefaultArgs instead
     */
    export type VehiclePartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehiclePartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DamageTypeDefaultArgs instead
     */
    export type DamageTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DamageTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeverityLevelDefaultArgs instead
     */
    export type SeverityLevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeverityLevelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImageVehiclePartDefaultArgs instead
     */
    export type ImageVehiclePartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageVehiclePartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImageDamageTypeDefaultArgs instead
     */
    export type ImageDamageTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageDamageTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleReferenceImageDefaultArgs instead
     */
    export type VehicleReferenceImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleReferenceImageDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}